#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <errno.h>
#include <algorithm>
#include <assert.h>
#include <math.h>

#include "zjh.h"
#include "game.h"
#include "log.h"
#include "table.h"
#include "client.h"
#include "player.h"
#include "proto.h"
#include "card.h"

extern ZJH zjh;
extern Log mjlog;

#define PREREADY_TIME_OUT 6
#define SINGLE_READY_TIME_OUNT 8
#define READY_TIME_OUT 6
#define START_TIME_OUT 1
#define BET_TIME_OUT 10
#define COMPARE_TIME_OUT 7
#define READY_OUT_TIME_OUT 60
#define DISMISS_TIME_OUT  30

#define SUBS_TIME_OUT 108000

Table::Table() :
preready_timer_stamp(PREREADY_TIME_OUT),
ready_timer_stamp(READY_TIME_OUT),
start_timer_stamp(START_TIME_OUT),
bet_timer_stamp(BET_TIME_OUT),
compare_timer_stamp(COMPARE_TIME_OUT),
dismiss_timer_stamp(DISMISS_TIME_OUT),     
subs_timer_stamp(SUBS_TIME_OUT)
{
	preready_timer.data = this;
	ev_timer_init(&preready_timer, Table::preready_timer_cb,
			preready_timer_stamp, preready_timer_stamp);

	ready_timer.data = this;
	ev_timer_init(&ready_timer, Table::ready_timer_cb, ready_timer_stamp,
			ready_timer_stamp);

	start_timer.data = this;
	ev_timer_init(&start_timer, Table::start_timer_cb, start_timer_stamp, start_timer_stamp);

	bet_timer.data = this;
	ev_timer_init(&bet_timer, Table::bet_timer_cb, bet_timer_stamp, bet_timer_stamp);

	compare_timer.data = this;
	ev_timer_init(&compare_timer, Table::compare_timer_cb, compare_timer_stamp, compare_timer_stamp);
    //single_ready_timer.data = this;
    //ev_timer_init(&single_ready_timer, Table::single_ready_timer_cb, single_ready_timer_stamp, single_ready_timer_stamp);

    dismiss_timer_stamp = zjh.conf["tables"]["dismiss_time"].asInt();
    dismiss_timer.data = this;
    ev_timer_init(&dismiss_timer, Table::dismiss_timer_cb, dismiss_timer_stamp, dismiss_timer_stamp);
	ahead_start_timer_stamp = zjh.conf["tables"]["ahead_time"].asInt();
	ahead_start_timer.data = this;
	ev_timer_init(&ahead_start_timer, Table::ahead_start_timer_cb, ahead_start_timer_stamp, ahead_start_timer_stamp);

    subs_timer.data = this;
    ev_timer_init(&subs_timer, Table::subs_timer_cb, subs_timer_stamp, subs_timer_stamp);

	cur_flow_mode = FLOW_END;

    owner_uid = -1;
	owner_name = "";
	owner_remote_ip = "";
    origin_owner_uid = -1;
    transfer_flag = false;
    game_end_flag = 0;
}

Table::~Table()
{
	ev_timer_stop(zjh.loop, &preready_timer);
	ev_timer_stop(zjh.loop, &ready_timer);
	ev_timer_stop(zjh.loop, &start_timer);
	ev_timer_stop(zjh.loop, &bet_timer);
	ev_timer_stop(zjh.loop, &compare_timer);

	ev_timer_stop(zjh.loop, &dismiss_timer);
	ev_timer_stop(zjh.loop, &ahead_start_timer);
	ev_timer_stop(zjh.loop, &subs_timer);
}

int Table::init(int my_tid, int my_vid, int my_zid, int my_type, float my_fee,
		int my_min_money, int my_max_money, int my_base_money, int my_base_ratio,
		int my_min_round, int my_max_round)
{
	// mjlog.debug("begin to init table [%d]\n", table_id);
	tid = my_tid;
    ttid = my_tid;
	vid = my_vid;
	zid = my_zid;
	type = my_type;
	fee = my_fee;
	min_money = my_min_money;
	max_money = my_max_money;
	base_money = my_base_money;
	base_ratio = my_base_ratio;
	min_round = my_min_round;
	max_round = my_max_round;
	seat_max = 4;
    max_play_board = 4;
    round_count = 0;

	cur_players = 0;
	players.clear();
	ready_players = 0;
	for (int i = 0; i < seat_max; i++)
	{
		seats[i].clear();
		seats[i].seatid = i;
	}

	reset();
    dismiss_flag = 0;
    dismiss_uid = 0;
    hu_seat = -1;
    get_card_seat = -1;
    gang_hu_seat = -1;
    pao_hu_seat = -1;
    pao_hu_count = 0;
    gang_hu_count = 0;
    next_dealer_seat = -1;
    tian_hu_flag = 0; //天胡
    di_hu_flag = 0; //地胡
    hai_di_hu_flag = 0;//海底胡
    gang_shang_hua_flag = 0; //杠上花
    gang_shang_hua_seat = -1;
    gang_shang_pao = 0; //杠上炮
    quan_qiu_ren_pao = 0; //全求人炮
    hai_di_pao = 0; //海底炮

    chi_count = 0;
    peng_count = 0;
    gang_count = 0;
    max_ready_players = seat_max;

    state = ROOM_WAIT_GAME;
	redpackes.clear();
	red_type = 0;
    set_card_flag = zjh.conf["tables"]["set_card_flag"].asInt();
    ts = time(NULL);
    create_rmb = 0;
	create_aa_rmb = 0;
	return 0;
}


// int fish_flag = val["fish_flag"].asInt();
//         int fish_calcul_flag = val["fish_calcul_flag"].asInt();
//         int fish_num = val["fish_num"].asInt();
//         int fish_score = val["fish_score"].asInt();
//         int table_type = val["table_type"].asInt();    
//         int max_play_count = val["max_play_count"].asInt();
//         int men_qing_flag = val["men_qing_flag"].asInt();
//         int jj_flag = val["jj_flag"].asInt();
//         int chi_san_bi = val["chi_san_bi"].asInt();
//         int forbid_hu = val["forbid_hu"].asInt();
//         int calcul_flag = val["calcul_flag"].asInt();

void Table::init_table_type(int set_type, int set_men_qing, int set_jj, int set_chi_san_bi, int set_forbid_hu, int set_calcal_flag,
                            int set_fish_flag, int set_fish_calcul_flag, int set_fish_num, int set_fish_score, int set_max_board,
                            int set_si_bi_forbid_hu, int set_substitute, int set_cost_select_flag , int set_zi_mo_upper_limit)
{
    type = set_type;
    has_ghost = 0;
    has_feng = 1;
    hu_pair = 1;
	redpackes.clear();
    max_play_board = set_max_board;
    fang_pao = 1;

    men_qing_flag = set_men_qing;
    hu_men_qing_flag = 0;
    jj_flag = set_jj;
    chi_san_bi = 1;
    forbid_hu = 0;
    calcul_flag = set_calcal_flag;
    fish_flag = set_fish_flag;
    fish_calcul_flag = set_fish_calcul_flag;
    fish_num = set_fish_num;
    fish_score = set_fish_score;
    si_bi_forbid_hu = set_si_bi_forbid_hu;
	substitute = set_substitute;
	cost_select_flag = set_cost_select_flag;
	zi_mo_upper_limit = set_zi_mo_upper_limit;
    ts = time(NULL);

    deck.init(has_feng, has_ghost, fish_num, hu_pair);
}

int Table::get_card_type(int salt)
{
	int tmp = random(0, 99, salt);
	mjlog.debug("get_card_type[%d] salt[%d].\n", tmp, salt);
    return 0;
}

int Table::broadcast(Player *p, const std::string &packet)
{
	Player *player;
	std::map<int, Player*>::iterator it;
	for (it = players.begin(); it != players.end(); it++)
	{
		player = it->second;
		if (player == p || player->client == NULL)
		{
			continue;
		}
		player->client->send(packet);
	}

	return 0;
}

int Table::unicast(Player *p, const std::string &packet)
{
	if (p->client)
	{
		return p->client->send(packet);
	}
	return -1;
}

int Table::random(int start, int end)
{
	srand((unsigned) time(NULL));
	return start + rand() % (end - start + 1);
}

int Table::random(int start, int end, int seed)
{
	srand((unsigned) time(NULL) + seed);
	return start + rand() % (end - start + 1);
}

void Table::reset()
{
	state = READY;
	ready_players = 0;
	start_seat = 0;
	cur_seat = 0;
	cur_action = 0;
	cur_bet = 0;
	total_bet = 0;
    last_action = 0;
    last_card.set_value(0);
    last_gang_card.set_value(0);
    win_seatid = -1;
    gang_hu_seat = -1;
    pao_hu_seat = -1;
    pao_hu_count = 0;
    gang_hu_count = 0;

    tian_hu_flag = 0; //天胡
    di_hu_flag = 0; //地胡
    hai_di_hu_flag = 0;//海底胡
    gang_shang_hua_flag = 0; //杠上花
    gang_shang_pao = 0; //杠上炮
    quan_qiu_ren_pao = 0;
    hai_di_pao = 0;
    gang_shang_hua_seat = -1;
    chu_seat = -1;

    chi_count = 0;
    peng_count = 0;
    gang_count = 0;

    wait_handle_action = -1;
    wait_handler_seat = -1;

    forbid_hu_record.clear();
    ahead_start_flag = 0;
    ahead_start_uid = -1;
	reset_actions();
    hu_men_qing_flag = 0;
}

void Table::vector_to_json_array(std::vector<Card> &cards, Jpacket &packet, string key)
{
	for (unsigned int i = 0; i < cards.size(); i++)
	{
		packet.val[key].append(cards[i].value);
	}

	if (cards.size() == 0)
	{
		packet.val[key].append(0);
	}
}

void Table::vector_to_json_array(std::vector<Card> &cards, Json::Value &val, string key)
{
	for (unsigned int i = 0; i < cards.size(); i++)
	{
		val[key].append(cards[i].value);
	}
}

void Table::vector_to_json_array(std::vector<int> &values, Json::Value &val, string key)
{
	for (unsigned int i = 0; i < values.size(); i++)
	{
		val[key].append(values[i]);
	}
}

void Table::vector_to_json_array(std::list<Card> &cards, Jpacket &packet, string key)
{
    std::list<Card>::iterator it = cards.begin();
    for (; it != cards.end(); it++)
    {
        packet.val[key].append(it->value);
    }

	if (cards.size() == 0)
	{
		packet.val[key].append(0);
	}
}

void Table::map_to_json_array(std::map<int, Card> &cards, Jpacket &packet,
		string key)
{
	std::map<int, Card>::iterator it;
	for (it = cards.begin(); it != cards.end(); it++)
	{
		Card &card = it->second;
		packet.val[key].append(card.value);
	}
}

void Table::json_array_to_vector(std::vector<Card> &cards, Jpacket &packet,
		string key)
{
	Json::Value &val = packet.tojson();

	for (unsigned int i = 0; i < val[key].size(); i++)
	{
		Card card(val[key][i].asInt());

		cards.push_back(card);
	}
}

//处理登录信息
int Table::handler_login(Player *player)
{  


    //将传递过来的字符串转化成json对象
    Json::Value &val = player->client->packet.tojson();
    //是否是创建table的命令
    bool is_create = (val["cmd"].asInt() == CLIENT_CREATE_TABLE_REQ);


    if (substitute == 1 && is_create)
    {
        handler_substitute_req(player);
        ev_timer_again(zjh.loop, &subs_timer);//------
    
        return 0;
    }

    //没有玩家
	if (players.find(player->uid) == players.end())
	{
		players[player->uid] = player;
		player->tid = tid;
		// todo check.
		player->seatid = sit_down(player);
		Seat &seat = seats[player->seatid];
		// seat.ready = 0;
		seat.uid = player->uid;
		if (player->seatid < 0)
		{
			return -1;
		}
		cur_players++;

        //先单播给传送消息的客户端，在广播给除了这个客户端以外的客户端
		handler_login_succ_uc(player);
		handler_login_succ_bc(player);

		if (is_create)
		{
			owner_uid = player->uid;
			owner_name = player->name;
			owner_remote_ip = player->remote_ip;
			origin_owner_uid = owner_uid;
			state = ROOM_WAIT_GAME;
		}

        //组织这个玩家的桌面信息，单播给这个玩家
		handler_table_info(player);

        //将准备就绪的信息广播给所有玩家
		if (player->uid < 1000 && player->uid > 100)
		{
			handler_ready(player);
		}

        if (substitute == 1)
        {
            modify_substitute_info(player, 1);
        }

		mjlog.info("handler login succ uid[%d] money[%d] cur_players[%d] tid[%d].\n", player->uid, player->money, cur_players, tid);

		return 0;
	}

	return -1;
}

//将玩家放置到某个位置
int Table::sit_down(Player *player)
{
    std::vector<int> tmp;
    //将空位置放到数组
	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].occupied == 0)//是否已经占有的位置
		{
			tmp.push_back(i);
		}
	}

    //将对应空位置放置玩家
	int len = tmp.size();
	if (len > 0)
	{
		int index = random(0, len - 1);
		int i = tmp[index];
		mjlog.debug("len[%d] index[%d] i[%d]\n", len, index, i);
		// seats[i].reset(); 
		seats[i].occupied = 1;
		seats[i].player = player;
		return i;
	}

	return -1;
}

//将这个玩家对应的位置清空
void Table::stand_up(Player *player)
{
    //将玩家对应的位置信息清空
	seats[player->seatid].clear();
}

//删除某个玩家
int Table::del_player(Player *player)
{
    //在player map中根据玩家id查找，直到最后一个元素
	if (players.find(player->uid) == players.end())
	{
		mjlog.debug("player uid[%d] talbe del_player is error.", player->uid);
		return -1;
    }
    
    Seat &seat = seats[player->seatid];
    //
	if (seat.ready == 1)
	{
		ready_players--;
	}
	player->stop_offline_timer();
	players.erase(player->uid);
	stand_up(player);
	cur_players--;

    modify_substitute_info(player, 0);

	// if (player->uid == owner_uid)
	// {
	// 	owner_uid = -1;
	// 	zjh.game->table_owners.erase(player->uid);
	// }

	return 0;
}

//单播登录消息
int Table::handler_login_succ_uc(Player *player)
{
	Jpacket packet;
	packet.val["cmd"] = SERVER_LOGIN_SUCC_UC;
	packet.val["vid"] = player->vid;
	packet.val["zid"] = player->zid;
	packet.val["tid"] = player->tid;

	packet.end();//-----
	unicast(player, packet.tostring());

	return 0;
}

//广播登录消息
// SERVER_LOGIN_SUCC_BC
int Table::handler_login_succ_bc(Player *player)
{
	Seat &seat = seats[player->seatid];

	Jpacket packet;
	packet.val["cmd"] = SERVER_LOGIN_SUCC_BC;
	// packet.val["vid"] = player->vid;
	// packet.val["zid"] = player->zid;
	// packet.val["tid"] = player->tid;
	packet.val["seatid"] = player->seatid;
	packet.val["ready"] = seat.ready;
	packet.val["betting"] = seat.betting;
	packet.val["role"] = seat.role;
	packet.val["status"] = seat.status;
	packet.val["bet"] = seat.bet;

	packet.val["uid"] = player->uid;
	packet.val["name"] = player->name;
	packet.val["sex"] = player->sex;
	packet.val["avatar"] = player->avatar;
	packet.val["zone"] = player->zone;

	packet.val["rmb"] = player->rmb;
	packet.val["money"] = player->money;
	packet.val["total_board"] = player->total_board;
    packet.val["pay_total"] = player->pay_total;

    packet.val["ip"] = player->remote_ip;
	packet.end();

	broadcast(player, packet.tostring());
	return 0;
}

//组织这个玩家的桌面信息单播给这个玩家
int Table::handler_table_info(Player *player)
{
	Jpacket packet;
	packet.val["cmd"] = SERVER_TABLE_INFO_UC;
	packet.val["vid"] = player->vid;
	packet.val["zid"] = player->zid;
	packet.val["tid"] = player->tid;
    packet.val["ttid"] = ttid;
	packet.val["seatid"] = player->seatid;

    if (round_count == 0)
    {
        state = ROOM_WAIT_GAME;
    }
	packet.val["state"] = state;
	packet.val["dealer"] = dealer;
	packet.val["cur_seat"] = cur_seat;
	packet.val["cur_bet"] = cur_bet;
	packet.val["total_bet"] = total_bet;
    packet.val["base_money"] = base_money;
    packet.val["remain_cards"] = deck.size();
    packet.val["robot_flag"] = seats[player->seatid].robot_flag;
    packet.val["owner_uid"] = owner_uid;
    packet.val["cur_round"] = round_count;
    packet.val["total_round"] = max_play_board;
    packet.val["dismiss"] = dismiss_flag;

    packet.val["has_feng"] = has_feng;
    packet.val["has_ghost"] = has_ghost;
    packet.val["hu_pair"] = hu_pair;
    packet.val["fish_num"] = fish_num;
    packet.val["max_play_count"] = max_play_board;
    packet.val["table_type"] = type;
    packet.val["fang_pao"] = fang_pao;
    packet.val["ahead_start_flag"] = ahead_start_flag;
    packet.val["ahead_start_uid"] = ahead_start_uid;
    packet.val["chu_seat"] = chu_seat;
    packet.val["chu_card"] = last_card.value;
	 packet.val["substitute"] = substitute;
    packet.val["cost_select_flag"] = cost_select_flag;
	mjlog.debug("handler_table_info redpackes.size() [%d] seats[%d].already_get_red [%d]\n", 
			redpackes.size(), player->seatid, seats[player->seatid].already_get_red);
	if(redpackes.size() > 0 && seats[player->seatid].already_get_red == 0)//-------
	{
		packet.val["get_red"] = 1;
	}
	else 
	{
		packet.val["get_red"] = 0;
	}

    if (has_ghost == 1)
    {
        packet.val["ghost_card"] = Card::ZhongV;
    }
    else
    {
        packet.val["ghost_card"] = 0;
    }
    packet.val["trun_card"] = 0;

    packet.val["tian_hu_flag"] = tian_hu_flag; //天胡
    packet.val["di_hu_flag"] = di_hu_flag; //地胡
    packet.val["hai_di_hu_flag"] = hai_di_hu_flag; //海底胡
    packet.val["gang_shang_hua_flag"] = gang_shang_hua_flag; //杠上花
    packet.val["gang_shang_pao"] = gang_shang_pao; //杠上炮

    if (dismiss_flag)
    {
        packet.val["dismiss_time"] = (int)ev_timer_remaining(zjh.loop, &dismiss_timer);
        packet.val["dismiss_uid"] = dismiss_uid;
    }
    else
    {
        packet.val["dismiss_time"] = 0;
        packet.val["dismiss_uid"] = 0;
    }

    if (ahead_start_flag)
    {
        packet.val["ahead_start_time"] = (int)ev_timer_remaining(zjh.loop, &ahead_start_timer);
    }
    else
    {
        packet.val["ahead_start_time"] = 0;
    }

    if (state == BETTING)
    {
        packet.val["remain_time"] = ev_timer_remaining(zjh.loop, &bet_timer);
    }

    packet.val["fish_flag"] = fish_flag;
    packet.val["fish_calcul_flag"] = fish_calcul_flag;
    packet.val["fish_num"] = fish_num;
    packet.val["fish_score"] = fish_score;    
    packet.val["men_qing_flag"] = men_qing_flag;
    packet.val["jj_flag"] = jj_flag;
    packet.val["chi_san_bi"] = chi_san_bi;
    packet.val["forbid_hu"] = forbid_hu;
    packet.val["calcul_flag"] = calcul_flag;
    packet.val["si_bi_forbid_hu"] = si_bi_forbid_hu;

	std::map<int, Player*>::iterator it;
	int i = 0;
	for (it = players.begin(); it != players.end(); it++)
	{
		Player *p = it->second;
		Seat &seat = seats[p->seatid];

		packet.val["players"][i]["uid"] = p->uid;
		packet.val["players"][i]["seatid"] = p->seatid;
		packet.val["players"][i]["ready"] = seat.ready;
		packet.val["players"][i]["betting"] = seat.betting;
		packet.val["players"][i]["role"] = seat.role;
		packet.val["players"][i]["status"] = seat.status;
		packet.val["players"][i]["bet"] = seat.bet;
        packet.val["players"][i]["robot_flag"] =  seat.robot_flag;
        packet.val["players"][i]["dismiss"] = seat.dismiss;
        packet.val["players"][i]["ahead_start"] = seat.ahead_start;
        packet.val["players"][i]["net_status"] = (p->client == NULL) ? 0 : 1;

        packet.val["players"][i]["forbid_hu"] = seat.forbid_hu;
        packet.val["players"][i]["forbid"] = seat.forbid_hu;
        packet.val["players"][i]["forbided_seatid"] = -1;

        for (unsigned int j = 0; j < seat.obsorb_seats.size(); j++)
        {
            packet.val["players"][i]["obsorb_seats"].append(seat.obsorb_seats[j]);
        }
  
		if (player == p)
		{
            if (state == BETTING)
            {
                std::vector<Card>::iterator vit;

                if (seat.hole_cards.cards.size() % 3 == 1)
                {
                    vit = seat.hole_cards.cards.begin();
                    for (; vit != seat.hole_cards.cards.end(); vit++)
                    {
                        packet.val["players"][i]["holes"].append(vit->value);
                    }
                }
                else
                {
                    vit = seat.hole_cards.oldcards.begin();
                    for (; vit != seat.hole_cards.oldcards.end(); vit++)
                    {
                        packet.val["players"][i]["holes"].append(vit->value);
                    }
                }

                if (seat.gang_hu_flag == 1 || seat.pao_hu_flag == 1)
                {
                    packet.val["players"][i]["pao_hu_card"] = hu_card;
                }
             
                int osize = seat.hole_cards.obsorb_cards.size();
                for (int j = 0; j < osize; j++)
                {
                    vit = seat.hole_cards.obsorb_cards[j].begin();
                    for (; vit != seat.hole_cards.obsorb_cards[j].end(); vit++)
                    {
                        packet.val["players"][i]["obsorb_holes"][j].append(vit->value);
                    }
                }

                std::list<Card>::iterator lit = seat.hole_cards.discard_cards.begin();

                for (; lit != seat.hole_cards.discard_cards.end(); lit++)
                {
                    packet.val["players"][i]["discard_holes"].append(lit->value);
                }
            
                packet.val["players"][i]["ting_flag"] = seat.ting;
                if (seat.ting == 1)
                {
                    osize = seat.hole_cards.hu_cards.size();

                    for (int j = 0; j < osize; j++)
                    {
                        packet.val["players"][i]["hu_cards"].append(seat.hole_cards.hu_cards[j].value);
                    }
                }

                if (cur_seat == seat.seatid)
                {
                    for (int j = 0; j < NOTICE_SIZE; j++)
                    {
                        packet.val["players"][i]["action"].append(actions[j]);
                    }

                    if (actions[NOTICE_GANG] == 1)
                    {
                        packet.val["gang_flag"] = seat.hole_cards.gang_flags.back();
                        vector_to_json_array(seat.hole_cards.gang_cards, packet, "gang_cards");
                        for (unsigned int j = 0; j < seat.hole_cards.gang_flags.size(); j++)
                        {
                            packet.val["gang_flags"].append(seat.hole_cards.gang_flags[j]);
                        }
                    }

                    if (actions[NOTICE_TING] == 1)
                    {       
                        int index = 0;
                        std::map<int, vector<Card> >::iterator it = seat.hole_cards.ting_cards.begin();
                        for (; it != seat.hole_cards.ting_cards.end(); it++)
                        {
                            packet.val["ting_cards"].append(it->first);
                            int size = it->second.size();
                            for (int j = 0; j < size; j++)
                            {
                                packet.val["ting_pattern"][index].append(it->second[j].value);
                            }
                            index++;
                        }  
                    }

                    if (actions[NOTICE_CHI] == 1)
                    {
                        vector_to_json_array(seat.hole_cards.eat_cards, packet, "chi_cards");
                        packet.val["card"] = 0;
                        packet.val["chi_card"] = last_card.value;
                    }

                    if (actions[NOTICE_PENG] == 1)
                    {
                        packet.val["card"] = 0;
                        packet.val["peng_card"] = last_card.value;
                    }

                    if (actions[NOTICE_HU] == 1)
                    {
                        if (seat.hole_cards.size() % 3 == 1)
                        {
                            packet.val["card"] = 0;
                            packet.val["hu_card"] = hu_card;
                            packet.val["players"][i]["pao_hu_card"] = hu_card;
                        }
                        else
                        {
                            packet.val["card"] = seat.hole_cards.last_card.value;
                            packet.val["hu_card"] = seat.hole_cards.last_card.value;
                        }
                    }
                }

                if (last_action == PLAYER_CHI)
                {
                    packet.val["players"][i]["chi_card"] = last_card.value;
                    for (unsigned int j = 0; j < seat.hole_cards.forbid_chu.size(); j++)
                    {
                        packet.val["players"][i]["forbid_chu"].append(seat.hole_cards.forbid_chu[j].value); 
                    }
                }
                else
                {
                    packet.val["players"][i]["chi_card"] = 0;
                }
            }
		}
        else
        {
            if (state == BETTING)
            {
                std::vector<Card>::iterator it = seat.hole_cards.cards.begin();
                for (; it != seat.hole_cards.cards.end(); it++)
                {
                    packet.val["players"][i]["holes"].append(0);
                }

                int osize = seat.hole_cards.obsorb_cards.size();
                for (int j = 0; j < osize; j++)
                {
                    it = seat.hole_cards.obsorb_cards[j].begin();

                    if (seat.hole_cards.obsorb_cards[j].size() == 4 && it->value == 0)
                    {
                        packet.val["players"][i]["obsorb_holes"][j].append(0);
                        packet.val["players"][i]["obsorb_holes"][j].append(0);
                        packet.val["players"][i]["obsorb_holes"][j].append(0);
                        packet.val["players"][i]["obsorb_holes"][j].append(0);
                        continue;
                    }

                    for (; it != seat.hole_cards.obsorb_cards[j].end(); it++)
                    {
                        packet.val["players"][i]["obsorb_holes"][j].append(it->value);
                    }
                }

                std::list<Card>::iterator lit = seat.hole_cards.discard_cards.begin();

                for (; lit != seat.hole_cards.discard_cards.end(); lit++)
                {
                    packet.val["players"][i]["discard_holes"].append(lit->value);
                }

                packet.val["players"][i]["ting_flag"] = seat.ting;
            }
        }

		packet.val["players"][i]["name"] = p->name;
		packet.val["players"][i]["sex"] = p->sex;
		packet.val["players"][i]["avatar"] = p->avatar;
		packet.val["players"][i]["rmb"] = p->rmb;
		packet.val["players"][i]["money"] = p->money;
        packet.val["players"][i]["ip"] = p->remote_ip;

		i++;
	}

	packet.end();
	unicast(player, packet.tostring());

    check_ip_conflict();

    zjh.game->set_in_game_flag(player, 1);
	return 0;
}

// int Table::single_ready_timeout()
// {
//     ready_players = 0;
// 	for (int i = 0; i < seat_max; i++) {
// 		if (seats[i].occupied == 1) {
// 			Player *player = seats[i].player;
// 			if (player == NULL)
// 				continue;
// 			seats[i].ready = 1;
// 			seats[i].betting = 1;
//             ready_players++;
// 		}
// 	}

//     int ret = test_game_start();

//     if (ret != 0)
//     {
//         ev_timer_again(zjh.loop, &single_ready_timer);
//     }

// 	return 0;
// }


//组织准备信息广播给所有玩家
int Table::handler_ready(Player *player)
{
	if (state != READY  && state != ROOM_WAIT_GAME)
	{
		mjlog.error("handler_ready state[%d] uid[%d] ttid[%d]\n", state, player->uid, ttid);
		return -1;
	}

	if (seats[player->seatid].ready == 1)
	{
		mjlog.error("player[%d] have been seted for game ready\n", player->uid);
		return -1;
	}

	player->stop_offline_timer();

	ready_players++;
	seats[player->seatid].ready = 1;
	seats[player->seatid].betting = 1;

	Jpacket packet;
	packet.val["cmd"] = SERVER_READY_SUCC_BC;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = player->seatid;
	packet.end();
	broadcast(NULL, packet.tostring());

    mjlog.debug("handler_ready cur_players[%d], ready_players[%d]\n", cur_players, ready_players);

	if (ready_players == cur_players)
	{
		if (ready_players >= max_ready_players)
		{
			return test_game_start();
		}
	}

	// if (ready_players == 2)
	// {
	//     ev_timer_stop(zjh.loop, &ready_timer);
	// }

	return 0;
}

//组织下轮准备信息，广播给所有玩家
int Table::handler_preready()
{
    if (game_end_flag == 1)
    {
        clean_table();
        game_end_flag = 0;
        return 0;
    }

    for (int i = 0; i < seat_max; i++)
	{
		seats[i].reset();
    }

    reset();


	std::map<int, Player*>::iterator it;
	for (it = players.begin(); it != players.end(); it++)
	{
		Player *player = it->second;		
	    player->reset();
	}

	Jpacket packet;
	packet.val["cmd"] = SERVER_GAME_PREREADY_BC;
	for (it = players.begin(); it != players.end(); it++)
	{
		Player *player = it->second;
		packet.val["seatids"].append(player->seatid);
	}
	packet.end();
	broadcast(NULL, packet.tostring());

    ev_timer_again(zjh.loop, &ready_timer);

	return 0;
}

//定时回调函数----准备下轮
void Table::preready_timer_cb(struct ev_loop *loop, struct ev_timer *w,
		int revents)
{
	Table *table = (Table*) w->data;
	ev_timer_stop(zjh.loop, &table->preready_timer);
	table->handler_preready();
}

//定时回调函数----第一次准备
void Table::ready_timer_cb(struct ev_loop *loop, struct ev_timer *w,
		int revents)
{
	Table *table = (Table*) w->data;
	ev_timer_stop(zjh.loop, &table->ready_timer);

	table->ready_timeout();
}


int Table::ready_timeout()
{
    test_game_start();

    // if (ret != 0)
    // {
    //     ev_timer_again(zjh.loop, &ready_timer);
    // }

	return 0;  
}

void Table::start_timer_cb(struct ev_loop *loop, struct ev_timer *w, int revents)
{
	Table *table = (Table*) w->data;
	ev_timer_stop(zjh.loop, &table->start_timer);

	table->start_next_bet(0);
}

//判断准备的玩家数量----是否开始游戏
int Table::test_game_start()
{
    int start_players = std::max(max_ready_players, 2);

	if (ready_players < start_players)
	{
		ev_timer_stop(zjh.loop, &ready_timer);
		mjlog.debug("current ready players less than 2\n");
		return 1;
	}

	if (state != READY && state != ROOM_WAIT_GAME)
	{
		mjlog.debug("game state isn't Ready\n");
		return 2;
	}

	ev_timer_stop(zjh.loop, &ready_timer);
	/* here to start the first board */
	game_start();

	return 0;
}

//开始游戏
int Table::game_start()
{
	ev_timer_stop(zjh.loop, &subs_timer);
	ts = time(NULL);
	state = BETTING;
	mjlog.debug("game start.\n");
	cur_flow_mode = zjh.game->flow_mode;
	mjlog.info("current flow mode is %d, tid %d.\n", cur_flow_mode, tid);

	cur_bet = base_money;
	total_bet = 0;

	deck.fill();
	deck.shuffle(tid);
	//deck.debug();

	if (round_count == 0)
	{
		round_ts = time(NULL);
        if (substitute == 1)
        {
            modify_substitute_info(1);
			zjh.game->del_subs_table(owner_uid);
        }
    }

    round_count++;

	if (round_count == 2 && max_ready_players == seat_max)
	{
		handler_redpacket();
    }
    //初始化庄家信息
    init_dealer();

    
	int current_betting_seats = count_betting_seats();
	int next = next_betting_seat(dealer);

    for (int c = 0; c < current_betting_seats; c++)
    {
		Seat &seat = seats[next];
		Player *player = seat.player;
		if (player == NULL)
        {
			mjlog.warn("game start player is NULL seatid[%d] tid[%d].\n", next, tid);
			continue;
		}

		Jpacket packet;
		packet.val["cmd"] = SERVER_GAME_START_BC;
		packet.val["uid"] = player->uid;
		packet.val["seatid"] = player->seatid;
        packet.val["dealer"] = dealer;
        packet.val["base_money"] = base_money;
        packet.val["remain_cards"] = int(deck.cards.size());
        packet.val["cur_round"] = round_count;
        packet.val["total_round"] = max_play_board;
        for (int i = 0; i < seat_max; i++)
        {
            if (seats[i].ready != 1)
            {
                continue;
            }
            packet.val["cur_seats"].append(i);
        }

		deck.get_hole_cards(seat.hole_cards);
        dump_hole_cards(seat.hole_cards.cards, next, 0);
        vector_to_json_array(seat.hole_cards.cards, packet, "holes");
		packet.end();
		unicast(player, packet.tostring());
        next = next_betting_seat(next);
	}

	start_seat = cur_seat = dealer;

  //  modify_substitute_info(1);
	ev_timer_again(zjh.loop, &start_timer);

	return 0;
}

//得到下家----下家出牌
int Table::count_next_bet()
{
	int _seat = next_player_seat();
	if (_seat == -1)
	{
		mjlog.error("count next bet no active player.\n");
		handler_preready();
		return -1;
	}

	cur_seat = _seat;
	start_next_bet(0);

	return 0;
}

//下家出牌
int Table::start_next_bet(int flag)
{
	Seat &seat = seats[cur_seat];
	Player *player = seat.player;
    int handler = 0;
    int fetch_flag = 0;

	Jpacket packet;
	packet.val["cmd"] = SERVER_NEXT_BET_BC;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = seat.seatid;
	packet.val["money"] = player->money;
    packet.val["card"] = 0;
    packet.val["remain_cards"] = deck.size();
    packet.val["remain_time"] = BET_TIME_OUT;
    packet.val["robot_flag"] = seat.robot_flag;
    packet.val["fetch_flag"] = 0;

    reset_actions();

     // 处理托管
    if (seat.robot_flag == 1)
    {
        if (deck.permit_get() == 0)
        {
            // 结束游戏
            mjlog.debug("deck no card, liuju\n");
            game_end();
            return 0;
        }

        deck.get_next_card(seat.hole_cards);
        get_card_seat = cur_seat;
        packet.val["card"] = seat.hole_cards.last_card.value;
        packet.val["remain_cards"] = deck.size();
        packet.val["fetch_flag"] = 1;
        fetch_flag = 1;
        handler = 1;    
    }

    if (gang_hu_count > 1 || pao_hu_count > 1)
    {
        mjlog.debug("gang_hu_count %d, pao_hu_count %d\n", gang_hu_count, pao_hu_count);
        //hu_card = last_card.value;
        game_end();
        return 0;
    }

    // 处理抢杠胡
    if (last_action == PLAYER_GANG && gang_hu_seat >= 0 && handler == 0 && gang_hu_seat != cur_seat)
    {
        if (seat.hole_cards.permit_hu(last_gang_card.value))
        {
            actions[NOTICE_HU] = 1;
            actions[NOTICE_GUO] = 1;

            packet.val["hu_card"] = last_gang_card.value;
            handler = 1;
        }
    }
  
    if ((last_action == PLAYER_CHU || last_action == PLAYER_GUO) && handler == 0)
    {
        mjlog.debug("start_next_bet last_action is player_chu\n");
        if (seat.hole_cards.permit_hu(last_card.value) && seat.forbid_hu != 1  && seat.handler_flag == 0)
        {
            if (seat.guo_hu_flag <= 0)
            {
                seat.hole_cards.analysis_card_type(calcul_flag, last_card.value);
                //if (seat.card_type != CARD_TYPE_PING_HU || fang_pao == 1)
                if (fang_pao == 1)
                {
                    actions[NOTICE_HU] = 1;
                    actions[NOTICE_GUO] = 1;
                    // if (seat.jiabei < MAX_JIABEI)
                    // {
                    //     actions[NOTICE_JIABEI] = 1;
                    // }
                    packet.val["hu_card"] = last_card.value;
                    handler = 1;
                }
            }
        }

        if (seat.ting != 1)
        {
            mjlog.debug("start_next_bet last_action is player_chu, not hu card\n");
            // 没牌摸了，不允许杠

            if (seat.hole_cards.permit_gang(last_card.value) && deck.permit_get() == 1 && seat.handler_flag == 0) 
            {
                mjlog.debug("start_next_bet last_action permit gang\n");
                actions[NOTICE_GANG] = 1;
                actions[NOTICE_GUO] = 1;
                packet.val["gang_card"] = last_card.value;
                handler = 1;
            }

            if (seat.hole_cards.permit_peng(last_card.value) && seat.handler_flag == 0)
            {
                vector<int> &cards = seat.guo_peng_cards;
                if (find(cards.begin(), cards.end(), last_card.value) == cards.end())
                {
                    actions[NOTICE_PENG] = 1;
                    packet.val["peng_card"] = last_card.value;
                    actions[NOTICE_GUO] = 1;
                    mjlog.debug("start_next_bet last_action permit peng\n");
                    handler = 1;
                }        
            }

			int other_peng = 0;
			if(actions[NOTICE_HU] == 1)
			{
				for (int i = 1; i < seat_max; i++)
				{
					int next = (cur_seat + i) % seat_max;
					if (next == chu_seat )
					{
						continue;
					}
					if (seats[next].ready != 1)
					{
						continue;
					}
					if (seats[next].hole_cards.permit_peng(last_card.value)||
							seats[next].hole_cards.permit_gang(last_card.value))
					{
						other_peng = 1;
					}
				}
			}
			if (seat.hole_cards.permit_chi(last_card.value, seat.last_chu_card) 
					&& next_betting_seat(chu_seat) == cur_seat && other_peng == 0 && seat.guo_chi == 0)
			{
					mjlog.debug("start_next_bet last_action permit chi NOTICE_HU [%d] other_peng[%d] handler_flag[%d] guo_chi[%d]\n",
							actions[NOTICE_HU], other_peng, seat.handler_flag , seat.guo_chi);

				mjlog.debug("start_next_bet last_action permit chi\n");
				actions[NOTICE_CHI] = 1;
				actions[NOTICE_GUO] = 1;
				packet.val["chi_card"] = last_card.value;
				vector_to_json_array(seat.hole_cards.eat_cards, packet, "chi_cards");
				handler = 1;
				
			}
		}     
	}

    if (handler == 0)
    {
        // 吃和碰的时候不需要抓牌
        if (seat.hole_cards.size() % 3 == 1)
        {
            if (deck.permit_get() == 0)
            {
                // 结束游戏
                mjlog.debug("deck no card, liuju\n");
                game_end();
                return 0;
            }

            if (set_card_flag == 1 && seat.need_card > 0)
            {
                deck.get_next_card(seat.hole_cards, seat.need_card);
            }
            else
            {
                deck.get_next_card(seat.hole_cards);
            }
            seat.guo_hu_flag = 0;
            seat.guo_peng_cards.clear();
            seat.hole_cards.forbid_chu.clear();
            seat.last_chu_card = 0;
            dump_hole_cards(seat.hole_cards.cards, cur_seat, 4);
           
            get_card_seat = cur_seat;
            packet.val["card"] = seat.hole_cards.last_card.value;
            packet.val["remain_cards"] = deck.size();
            packet.val["fetch_flag"] = 1;
            fetch_flag = 1;
        }
        else
        {
            seat.hole_cards.last_card.set_value(0);
        }

        seat.hole_cards.analysis();

        mjlog.debug("start_next_bet last_action get next card[%d]\n", seat.hole_cards.last_card.value);
        
        if (seat.hole_cards.permit_hu()
            && last_action != PLAYER_PENG
            && last_action != PLAYER_CHI
            && seat.forbid_hu != 1)
        {
            actions[NOTICE_HU] = 1;
            actions[NOTICE_GUO] = 1;
            hu_card = seat.hole_cards.last_card.value;
            packet.val["hu_card"] = seat.hole_cards.last_card.value;
            seat.hu = 1;
        }

        if (seat.ting != 1)
        {
            // if (seat.hole_cards.ting_cards.size() > 0)
            // {
            //     actions[NOTICE_TING] = 1;
            //     actions[NOTICE_GUO] = 1;
            //     handler = 1;
            // }
            // 最后一张不允许杠
            if (seat.hole_cards.permit_gang() && handler == 0
                && deck.permit_get() == 1
                && last_action != PLAYER_PENG)
            {
                actions[NOTICE_GANG] = 1;
                actions[NOTICE_GUO] = 1;
            }

            if (actions[NOTICE_HU] == 1 && actions[NOTICE_GANG] == 1)
            {
                vector<Card> gang_cards = seat.hole_cards.gang_cards;
                if (find(gang_cards.begin(), gang_cards.end(), seat.hole_cards.last_card.value) == gang_cards.end())
                {
                    actions[NOTICE_GANG] = 0;
                }
            }
        }   
    }
    
    for (int i = 0; i < NOTICE_SIZE; i++)
    {
        packet.val["action"].append(actions[i]);
    }

    if (actions[NOTICE_GANG] == 1)
    {
        packet.val["gang_flag"] = seat.hole_cards.gang_flags.back();
        vector_to_json_array(seat.hole_cards.gang_cards, packet, "gang_cards");
        for (unsigned int i = 0; i < seat.hole_cards.gang_flags.size(); i++)
        {
            packet.val["gang_flags"].append(seat.hole_cards.gang_flags[i]);
        }
    }

    if (actions[NOTICE_TING] == 1)
    {       
        int index = 0;
        std::map<int, vector<Card> >::iterator it = seat.hole_cards.ting_cards.begin();
        for (; it != seat.hole_cards.ting_cards.end(); it++)
        {
            packet.val["ting_cards"].append(it->first);
            int size = it->second.size();
            for (int i = 0; i < size; i++)
            {
                packet.val["ting_pattern"][index].append(it->second[i].value);
            }
            index++;
        }  
    }

	packet.end();
    unicast(seat.player, packet.tostring());

    Jpacket packet1;
    packet1.val["cmd"] = SERVER_NEXT_BET_BC;
	packet1.val["uid"] = player->uid;
	packet1.val["seatid"] = seat.seatid;
    packet1.val["remain_time"] = BET_TIME_OUT;
    packet1.val["remain_cards"] = deck.size();
    packet1.val["fetch_flag"] = fetch_flag;
    packet1.val["robot_flag"] = seat.robot_flag;
    if (actions[NOTICE_GANG] == 1)
    {
        packet1.val["gang_flag"] = seat.hole_cards.gang_flag;
    }   
    packet1.end();
    broadcast(seat.player, packet1.tostring());

    if (seat.robot_flag == 1 || (seat.ting == 1 && actions[NOTICE_HU] != 1))
    {
        ev_timer_set(&bet_timer, 2, 2);
        ev_timer_again(zjh.loop, &bet_timer);
    }
    else
    {
        ev_timer_set(&bet_timer, BET_TIME_OUT, BET_TIME_OUT);
        ev_timer_again(zjh.loop, &bet_timer);
    }

	return 0;
}

//定时回调函数，出牌
void Table::bet_timer_cb(struct ev_loop *loop, struct ev_timer *w, int revents)
{
	Table *table = (Table*) w->data;
	ev_timer_stop(zjh.loop, &table->bet_timer);
	mjlog.debug("bet_timer_cb\n");
	table->bet_timeout();
}

void Table::compare_timer_cb(struct ev_loop *loop, struct ev_timer *w, int revents)
{
	Table *table = (Table*) w->data;
	ev_timer_stop(zjh.loop, &table->compare_timer);
	//log.debug("compare_timer_cb\n");
	//table->compare_timeout();
}

int Table::handler_bet(Player *player)
{
	int ret;
    Json::Value &val = player->client->packet.tojson();
	int action = val["action"].asInt();

	if (state != BETTING)
	{
		mjlog.error("handler_bet state is not betting[%d]\n", state);
        handler_bet_error(player, action);
		return -1;
	}

	Seat &seat = seats[player->seatid];
	if (seat.player != player)
	{
        handler_bet_error(player, action);
		mjlog.error("handler_bet player is no match with seat.player\n");
		return -1;
	}

    //player->noplay_count = 0;

	if (cur_seat != player->seatid && (action != PLAYER_TUOGUAN) && (action != PLAYER_CANCEL_TUOGUAN))
	{
		mjlog.error("handler_bet player->seatid[%d] cur_seat[%d]\n",
				player->seatid, cur_seat);
		return -1;
	}

	if (action == PLAYER_GUO)
	{
		ret = handler_guo(player);
		if (ret < 0)
		{
			return -1;
		}
		//ev_timer_stop(zjh.loop, &bet_timer);
		// count_next_bet();
		return 0;
	}

	if (action == PLAYER_CHI)
	{
		ret = handler_chi(player);
		if (ret < 0)
		{
			return -1;
		}

        start_next_bet(0);

		return 0;
	}
	else if (action == PLAYER_CHU)
	{
        ret = handler_chu(player);
        if (ret < 0)
		{
			return -1;
		}
		ev_timer_stop(zjh.loop, &bet_timer);
        count_next_bet();
		return 0;
	}
    else if (action == PLAYER_PENG)
    {
        ret = handler_peng(player);
		if (ret < 0)
		{
			return -1;
		}

        start_next_bet(0);
		return 0;
    }
    else if (action == PLAYER_GANG)
    {
        ret = handler_gang(player);
		if (ret < 0)
		{
			return -1;
		}

        ev_timer_stop(zjh.loop, &bet_timer);
        ev_timer_again(zjh.loop, &bet_timer);
        count_next_bet();
		// ev_timer_stop(zjh.loop, &bet_timer);
		return 0;
    }
    else if (action == PLAYER_HU)
    {
        ret = handler_hu(player);
        if (ret < 0)
		{
			return -1;
		}
		ev_timer_stop(zjh.loop, &bet_timer);
        mjlog.debug("player[%d] req hu card\n", player->uid);
        game_end();

		return 0;
    }
    else if (action == PLAYER_TING)
    {
        ret = handler_ting(player);
        if (ret < 0)
		{
			return -1;
		}
		ev_timer_stop(zjh.loop, &bet_timer);
        count_next_bet();
		return 0;
    }
    else if (action == PLAYER_CANCEL)
    {
        ret = handler_cancel(player);
        if (ret < 0)
		{
			return -1;
		}
		ev_timer_stop(zjh.loop, &bet_timer);
		return 0;
    }
    else if (action == PLAYER_JIABEI)
    {
        ret = handler_jiabei(player);
        if (ret < 0)
		{
			return -1;
		}
        
        if (seat.hole_cards.size() % 3 != 2)
        {
            ev_timer_stop(zjh.loop, &bet_timer);
            start_next_bet(0);
        }
        else
        {
            //start_next_bet(0);
        }
        return 0;
    }

	return 0;
}

void Table::bet_timeout()
{
	// Seat &seat = seats[cur_seat];
	// Player *player = seat.player;

	// if (player == NULL)
	// {
	// 	mjlog.error(
	// 			"bet timeout null player ready_players[%d] cur_players[%d] tid[%d].\n",
	// 			ready_players, cur_players, tid);
	// 	return;
	// }

    // if (seat.hu == 1)
    // {
    //     win_seatid = cur_seat;

    //     vector<Card> cards = seat.hole_cards.cards;
    //     if (cards.size() % 3 == 2)
    //     {
    //         vector<Card>::iterator it = find(cards.begin(), cards.end(), seat.hole_cards.last_card);
    //         if (it != cards.end())
    //         {
    //             cards.erase(it);
    //         }
    //     }

    //     Jpacket packet;
    //     packet.val["cmd"] = SERVER_BET_SUCC_BC;
    //     packet.val["seatid"] = player->seatid;
    //     packet.val["uid"] = player->uid;
    //     packet.val["action"] = PLAYER_HU;
    //     packet.val["card"] = seat.hole_cards.last_card.value;
    //     packet.val["hu_card"] = seat.hole_cards.last_card.value;
    //     packet.val["time_out"] = 0;
    //     vector_to_json_array(cards, packet, "holes");
    //     packet.end();
    //     unicast(player, packet.tostring());

    //     Jpacket packet1;
    //     packet1.val["cmd"] = SERVER_BET_SUCC_BC;
    //     packet1.val["seatid"] = player->seatid;
    //     packet1.val["uid"] = player->uid;
    //     packet1.val["action"] = PLAYER_HU;
    //     packet1.val["card"] = seat.hole_cards.last_card.value;
    //     packet1.val["hu_card"] = seat.hole_cards.last_card.value;
    //     packet1.val["time_out"] = 0;
    //     vector_to_json_array(cards, packet1, "holes");
    //     packet1.end();
    //     broadcast(player, packet1.tostring());

    //     mjlog.debug("player[%d] get a card, hu card on timeout\n", player->uid);
    //     game_end();
    //     return;
    // }
    // else
    // {
    //     return;
    // }	
}

void Table::compare_timeout()
{
	if (state != BETTING)
	{
		mjlog.error("compare timeout state[%d] is not BETTING.\n", state);
		return;
	}
	int ret = test_game_end();
	if (ret < 0)
	{
		count_next_bet();
	}
}

void Table::lose_update(Player *player)
{
	Seat &seat = seats[player->seatid];

    player->incr_money(1, seat.bet);
	player->incr_total_board(vid, 1);
	mjlog.debug("lose_update total_board [%d] pre_uid[%d] \n",player->total_board ,player->pre_uid);
	if ( player->pre_uid > 1000)
	{
		handler_invite_advantage(player);
	}
}

void Table::win_update(Player *player)
{
	Seat &seat = seats[player->seatid];
 
    player->incr_money(0, seat.bet);
	player->incr_total_board(vid, 1);
	mjlog.debug("win_update total_board [%d] pre_uid[%d] \n",player->total_board ,player->pre_uid);
	if (player->pre_uid > 1000)
	{
		handler_invite_advantage(player);
	}
}

void Table::update_money(Player *player, int value)
{
    if (cur_flow_mode != FLOW_IMMEDIATE)
    {
        return;
    }
	player->incr_money(1, value);
}

int Table::test_game_end()
{
	int betting_players = count_betting_seats();
	if (betting_players == 1)
	{
        for (int i = 0; i < seat_max; i++)
        {
            if (seats[i].betting == 1)
            {
                win_seatid = i;
                break;
            }
        }

        mjlog.debug("bet player only one, game end\n");
		game_end();
		return 0;
	}

	return -1;
}

int Table::game_end(int flag)
{
	mjlog.debug("game_end[%d]\n", start_seat);
	ev_timer_stop(zjh.loop, &bet_timer);
	ev_timer_stop(zjh.loop, &start_timer);
	ev_timer_stop(zjh.loop, &compare_timer);

	state = END_GAME;

    if (players.size() == 0)
    {
        mjlog.debug("allready game end\n");
        return 0;
    }

    accumulate_hu();

    Jpacket packet;
	packet.val["cmd"] = SERVER_GAME_END_BC;
	packet.val["win_seatid"] = win_seatid;
	packet.val["total_bet"] = total_bet;
    packet.val["cur_round"] = round_count;
    packet.val["remain_cards"] = (int)deck.size();

    if (pao_hu_seat >= 0)
    {
        packet.val["fang_pao_seat"] = pao_hu_seat;
    }
    else if (gang_hu_seat >= 0)
    {
        packet.val["fang_pao_seat"] = gang_hu_seat;
    }
    else
    {
        packet.val["fang_pao_seat"] = -1;
    }

    vector_to_json_array(deck.fish_cards, packet, "fish_cards");
	   
    if (win_seatid < 0 && gang_hu_count < 2 && pao_hu_count < 2)
    {
        win_bet = 0;
        packet.val["is_liuju"] = 1;

        int size = deck.fish_cards.size();
        for (int i = 0; i < size; i++)
        {
            packet.val["zhong_fish"].append(0);
        }

        for (int i = 0; i < seat_max; i++)
        {
            seats[i].bet = 0;
        }

        update_account_bet();

        for (int i = 0; i < seat_max; i++)
        {
			if (seats[i].ready != 1)
			{
				continue;
			}

            if (seats[i].bet > 0)
            {
                win_update(seats[i].player);
            }
            else
            {
                lose_update(seats[i].player);
            }
        }
         // 记录结果
        insert_flow_record();
    }
    else
    {
        packet.val["is_liuju"] = 0; 
        update_account_bet();

         // 记录结果
        insert_flow_record();

        for (int i = 0; i < seat_max; i++)
        {
            // if (i == win_seatid || seats[i].gang_hu_flag == 1)
            // {
            //     win_update(seats[i].player);
            // }
            // else
            // {
            //     lose_update(seats[i].player);
            // }
            if (seats[i].ready != 1)
			{
				continue;
			}

            if (seats[i].bet > 0)
            {
                win_update(seats[i].player);
            }
            else
            {
                lose_update(seats[i].player);
            }
        }
    }

    packet.val["tian_hu_flag"] = tian_hu_flag; //天胡
    packet.val["di_hu_flag"] = di_hu_flag; //地胡
    packet.val["hai_di_hu_flag"] = hai_di_hu_flag; //海底胡
    packet.val["gang_shang_hua_flag"] = gang_shang_hua_flag; //杠上花
    packet.val["gang_shang_pao"] = gang_shang_pao; //杠上炮

	int j = 0;
	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].occupied == 1)
		{
			Player *player = seats[i].player;
			if (player)
			{
				packet.val["players"][j]["seatid"] = player->seatid;
				packet.val["players"][j]["uid"] = player->uid;
				packet.val["players"][j]["name"] = player->name;
				packet.val["players"][j]["rmb"] = player->rmb;
				packet.val["players"][j]["money"] = player->money;
				packet.val["players"][j]["total_board"] = player->total_board;
                packet.val["players"][j]["pay_total"] = player->pay_total;
        
                packet.val["players"][j]["fish_count"] = seats[i].fish_count;
            
				
				if (seats[i].fish_cards.size() > 0)
                {
                    vector_to_json_array(seats[i].fish_cards, packet.val["players"][j], "fish_cards");
                    vector_to_json_array(seats[i].zhong_fish, packet.val["players"][j], "zhong_fish");
                    packet.val["players"][j]["display_fish"] = 1;
                }
                else
                {
                    // vector_to_json_array(deck.fish_cards, packet.val["players"][j], "fish_cards");
                    // for (int z = 0; z < deck.fish_cards.size(); z++)
                    // {
                    //     packet.val["players"][j]["zhong_fish"].append(0);
                    // }
                    packet.val["players"][j]["display_fish"] = 0;
                }            

                for (unsigned int z = 0; z < seats[i].obsorb_seats.size(); z++)
                {
                    packet.val["players"][j]["obsorb_seats"].append(seats[i].obsorb_seats[z]);
                }
             
                if (seats[i].chi_san_bi_record.size() != 0)
                {
                    std::map<int, int>::iterator bit = seats[i].chi_san_bi_record.begin();
                  
                    for (; bit != seats[i].chi_san_bi_record.end(); bit++)
                    {
                        if (bit->second >= 3)
                        {
                            packet.val["players"][j]["chi_san_bi_seatid"] = bit->first;
                            break;
                        }
                    }

                    if (bit == seats[i].chi_san_bi_record.end())
                    {
                        packet.val["players"][j]["chi_san_bi_seatid"] = -1;
                    }
                }
                else
                {
                    packet.val["players"][j]["chi_san_bi_seatid"] = -1;
                }

				if (seats[i].seatid == win_seatid)
				{
                    packet.val["players"][j]["card_type"] = seats[i].hole_cards.card_type;
                    packet.val["players"][j]["gang_hu_flag"] = seats[i].gang_hu_flag;
					packet.val["players"][j]["pao_hu_flag"] = seats[i].pao_hu_flag;
                    string desc = format_card_desc(seats[i].hole_cards.card_type);
                    packet.val["players"][j]["card_desc"] = desc.c_str();
					packet.val["players"][j]["win"] = 1;

					for (unsigned int k = 0; k < seats[i].hole_cards.oldcards.size(); k++)
					{
						packet.val["players"][j]["holes"].append(seats[i].hole_cards.oldcards[k].value);
					}

                    if (seats[i].hole_cards.cards.size() % 3 != 2)
                    {
                        packet.val["players"][j]["holes"].append(hu_card);
                    }

                    std::vector<Card>::iterator vit;
                    int osize = seats[i].hole_cards.obsorb_cards.size();
                    for (int z = 0; z < osize; z++)
                    {
                        vit = seats[i].hole_cards.obsorb_cards[z].begin();
                        for (; vit != seats[i].hole_cards.obsorb_cards[z].end(); vit++)
                        {
                            packet.val["players"][j]["obsorb_holes"][z].append(vit->value);
                        }
                    }

                    packet.val["players"][j]["fang_gang_count"] = seats[i].fang_gang_count;

                    for (int k = 0; k < 4; k++)
                    {
                        packet.val["players"][j]["gang_count"].append(seats[i].gang_count[k]);
                    }
                    packet.val["players"][j]["bet"] = seats[i].bet;
				}
				else
				{
                    if ((seats[i].gang_hu_flag == 1 && gang_hu_count > 1) || (seats[i].pao_hu_flag == 1 && pao_hu_count > 1))
                    {
                        packet.val["players"][j]["card_type"] = seats[i].hole_cards.card_type;
                        string desc = format_card_desc(seats[i].hole_cards.card_type);
                        packet.val["players"][j]["card_desc"] = desc.c_str();
                        packet.val["players"][j]["win"] = 1;
                        packet.val["players"][j]["gang_hu_flag"] = seats[i].gang_hu_flag;
                        packet.val["players"][j]["pao_hu_flag"] = seats[i].pao_hu_flag;
                    }
                    else
                    {
                        packet.val["players"][j]["card_type"] = 0;
                        packet.val["players"][j]["card_desc"] = "";
                        packet.val["players"][j]["win"] = 0;
                        packet.val["players"][j]["gang_hu_flag"] = 0;
                        packet.val["players"][j]["pao_hu_flag"] = 0;
                    }
					
					for (unsigned int k = 0; k < seats[i].hole_cards.oldcards.size(); k++)
					{
						packet.val["players"][j]["holes"].append(seats[i].hole_cards.oldcards[k].value);
					}

                    if ((seats[i].gang_hu_flag == 1 && gang_hu_count > 1) || (seats[i].pao_hu_flag == 1 && pao_hu_count > 1))
                    {
                        packet.val["players"][j]["holes"].append(hu_card);
                    }

                    std::vector<Card>::iterator vit;
                    int osize = seats[i].hole_cards.obsorb_cards.size();
                    for (int z = 0; z < osize; z++)
                    {
                        vit = seats[i].hole_cards.obsorb_cards[z].begin();
                        for (; vit != seats[i].hole_cards.obsorb_cards[z].end(); vit++)
                        {
                            packet.val["players"][j]["obsorb_holes"][z].append(vit->value);
                        }
                    }

                    packet.val["players"][j]["fang_gang_count"] = seats[i].fang_gang_count;

                    for (int k = 0; k < 4; k++)
                    {
                        packet.val["players"][j]["gang_count"].append(seats[i].gang_count[k]);
                    }

                    packet.val["players"][j]["bet"] = seats[i].bet;

				}
		
				j++;
			}
		}
	}

    int init_money = zjh.conf["tables"]["init_money"].asInt();
    packet.val["flag"] = 0;
    packet.val["owner_uid"] = owner_uid;

	if (flag == 1 || round_count >= max_play_board || zjh.game->terminal_flag == 1)
    {
        packet.val["flag"] = 1;
        j = 0;
        for (int i = 0; i < seat_max; i++) {
            if (seats[i].occupied == 1) {
                Player *player = seats[i].player;
				Seat &seat = seats[i];
                if (player) {
                    packet.val["players1"][j]["seatid"] = player->seatid;
                    packet.val["players1"][j]["uid"] = player->uid;
                    packet.val["players1"][j]["name"] = player->name;
                    packet.val["players1"][j]["rmb"] = player->rmb;
                    packet.val["players1"][j]["money"] = player->money;
                    packet.val["players1"][j]["bet"] = player->money - init_money;
                    packet.val["players1"][j]["avatar"] = player->avatar;
                    packet.val["players1"][j]["ip"] = player->remote_ip;
                    const char* record_desc[] = {"自摸次数", "接炮次数", "点炮次数", "暗杠次数", "明杠次数"};
                    for (int z = 0; z < 5; z++)
                    {
                        packet.val["players1"][j]["total_record_desc"].append(record_desc[z]);
                    }

                    packet.val["players1"][j]["total_record"].append(seat.total_zimo);
                    packet.val["players1"][j]["total_record"].append(seat.total_jie_pao);
                    packet.val["players1"][j]["total_record"].append(seat.total_fang_pao);
                    packet.val["players1"][j]["total_record"].append(seat.total_an_gang);
                    packet.val["players1"][j]["total_record"].append(seat.total_ming_gang);
                    j++;
                }
            }
        }
        insert_flow_round_record();
        game_end_flag = 1;
    }
	packet.end();
	broadcast(NULL, packet.tostring());
  
	ev_timer_again(zjh.loop, &preready_timer);

	return 0;
}

int Table::handler_fold(Player *player)

{
	Seat &seat = seats[player->seatid];

	if (seat.betting == 0)
	{
		mjlog.error("handler_fold seat betting[0] uid[%d] tid[%d].\n",
				player->uid, tid);
		return -1;
	}

	//lose_update(seat.player);
	seat.betting = 0;

	return 0;
}

int Table::handler_logout(Player *player)
{
	// if (state == BETTING)
	// {
	// 	Seat &seat = seats[player->seatid];
	// 	if (seat.betting == 1)
	// 	{
	// 		handler_fold(player);
	// 		int ret = test_game_end();
	// 		if (ret < 0)
	// 		{
	// 			if (player->seatid == cur_seat)
	// 			{
	// 				count_next_bet();
	// 			}
	// 		}
	// 	}
	// }

	Jpacket packet;
	packet.val["cmd"] = SERVER_LOGOUT_SUCC_BC;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = player->seatid;
	packet.val["type"] = player->logout_type;
	packet.end();
	broadcast(NULL, packet.tostring());

	return 0;
}

int Table::handler_chat(Player *player)
{
	Json::Value &val = player->client->packet.tojson();

	Jpacket packet;
	packet.val["cmd"] = SERVER_CHAT_BC;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = player->seatid;
	packet.val["text"] = val["text"];
	packet.val["chatid"] = val["chatid"];
    packet.val["sex"] = val["sex"];
	packet.end();
	broadcast(NULL, packet.tostring());

    //player->noplay_count = 0;
	return 0;
}

int Table::handler_face(Player *player)
{
	Json::Value &val = player->client->packet.tojson();

	Jpacket packet;
	packet.val["cmd"] = SERVER_FACE_BC;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = player->seatid;
	packet.val["faceid"] = val["faceid"];
	packet.end();
	broadcast(NULL, packet.tostring());

    //player->noplay_count = 0;

	return 0;
}

int Table::handler_interFace(Player *player)
{
	Json::Value &val = player->client->packet.tojson();

	Jpacket packet;
	packet.val["cmd"] = SERVER_INTERFACE_BC;
	packet.val["uid"] = player->uid;
	packet.val["fromid"] = player->seatid;
	packet.val["toid"] = val["toid"];
	packet.val["faceid"] = val["faceid"];
	packet.end();
	broadcast(NULL, packet.tostring());

    //player->noplay_count = 0;
	return 0;
}

int Table::handler_player_info(Player *player)
{
	int ret = 0;
    //player->noplay_count = 0;
	ret = player->update_info();
	if (ret < 0)
	{
		mjlog.error("handler_player_info update_info error.\n");
		return -1;
	}

	if (state == BETTING)
	{
		Seat &seat = seats[player->seatid];
		if (seat.betting == 1)
		{
			player->money -= seat.bet;
			mjlog.info("handler_player_info o uid[%d] money[%d] bet[%d].\n",
					player->uid, player->money, seat.bet);
		}
	}

	Jpacket packet;
	packet.val["cmd"] = SERVER_PLAYER_INFO_BC;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = player->seatid;
	packet.val["money"] = player->money;
	packet.val["rmb"] = player->rmb;
	packet.val["total_board"] = player->total_board;

	packet.end();
	broadcast(NULL, packet.tostring());

	mjlog.info("handler_player_info uid[%d] seatid[%d] money[%d] tid[%d].\n",
			player->uid, player->seatid, player->money, tid);

	return 0;
}

int Table::handler_prop(Player *player)
{
	Json::Value &val = player->client->packet.tojson();
	int action = val["action"].asInt();

	if (type != 0)
	{
		mjlog.error("handler_prop error uid[%d] money[%d] is not in prop\n",
				player->uid, player->money);
		return 0;
	}

	if (state != BETTING)
	{
		mjlog.error("handler_prop state[%d] is not betting tid[%d]\n", state,
				tid);
		return -1;
	}

	Seat &seat = seats[player->seatid];
	if (seat.player != player)
	{
		mjlog.error("handler_prop player is no match with seat.player\n");
		return -1;
	}

	mjlog.info("handler_prop succ. uid[%d] seatid[%d] action[%d] tid[%d].\n",
			player->uid, player->seatid, action, tid);
	return 0;
}

void Table::handler_prop_error(Player *player, int action)
{
	Jpacket packet;
	packet.val["cmd"] = SERVER_PROP_ERR_UC;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
	packet.end();
	unicast(player, packet.tostring());
}

void Table::handler_bet_error(Player *player, int action)
{
	Jpacket packet;
	packet.val["cmd"] = SERVER_BET_ERR_UC;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
    packet.val["chu_seat"] = chu_seat;

    Seat &seat = seats[player->seatid];

    vector_to_json_array(seat.hole_cards.cards, packet, "holes");

    std::list<Card>::iterator lit = seat.hole_cards.discard_cards.begin();
    for (; lit != seat.hole_cards.discard_cards.end(); lit++)
    {
        packet.val["discard_holes"].append(lit->value);
    }      

	packet.end();
	unicast(player, packet.tostring());

    //handler_table_info(player);
}

int Table::next_betting_seat(int pos)
{
	int cur = pos;

	for (int i = 0; i < seat_max; i++)
	{
		cur++;
		if (cur >= seat_max)
			cur = 0;

		if (seats[cur].betting == 1)
		{
			mjlog.debug("cur is betting seat[%d]\n", cur);
			return cur;
		}
	}

	mjlog.error("error active player\n");

	return -1;
}

int Table::next_player_seat()
{
    int first_hu_seat = -1;
    pao_hu_count = 0;
    gang_hu_count = 0;

    if (last_action == PLAYER_CHU)
    {
        for (int i = 1; i < seat_max; i++)
        {
            int next = (cur_seat + i) % seat_max;
            Seat &seat = seats[next];
            if (seats[next].ready != 1)
            {
				continue;
			}

            if (seat.hole_cards.permit_hu(last_card.value) && seat.forbid_hu != 1)
            {
                if (seat.guo_hu_flag > 0 )
                {
                    mjlog.debug("cur_seat[%d], next hu seat[%d], guo hu\n", cur_seat, next);
                    continue;
                }

                // seat.hole_cards.analysis_card_type(calcul_flag);
                // if (seat.hole_cards.card_type == CARD_TYPE_PING_HU && fang_pao == 0)
                // {
                //     continue;
                // }

                mjlog.debug("cur_seat[%d], next hu seat[%d]\n", cur_seat, next);
                if (first_hu_seat == -1)
                {
                    first_hu_seat = next;
                }
                hu_card = last_card.value;
                seat.pao_hu_flag = 1;
                pao_hu_count++;
            }
        }

        if (pao_hu_count == 2)
        {
            next_dealer_seat = first_hu_seat;
        }
        else if (pao_hu_count == 3)
        {
            next_dealer_seat = cur_seat;
        }

        if (first_hu_seat >= 0)
        {
            pao_hu_seat = cur_seat;
            return first_hu_seat;
        }

        for (int i = 1; i < seat_max; i++)
        {
            int next = (cur_seat + i) % seat_max;
			
			if (seats[next].ready != 1)
            {
				continue;
			}

            vector<int> &cards = seats[next].guo_peng_cards;
            if (find(cards.begin(), cards.end(), last_card.value) != cards.end())
            {
                mjlog.debug("cur_seat[%d], guo peng seat[%d]\n", cur_seat, next);
                continue;
            }

            if (seats[next].hole_cards.permit_peng(last_card.value)
                || seats[next].hole_cards.permit_gang(last_card.value))
            {
                mjlog.debug("cur_seat[%d], next peng gang seat[%d]\n", cur_seat, next);
                return next;        
            }
        }
    }

    if (last_action == PLAYER_GANG)
    {
        if (seats[cur_seat].hole_cards.gang_flag == 1)
        {
            for (int i = 1; i < seat_max; i++)
            {
                int next = (cur_seat + i) % seat_max;
                if (seats[next].ready != 1)
                {
                    continue;
                }

                if (seats[next].hole_cards.permit_hu(last_gang_card.value)
					&& seats[next].forbid_hu != 1)
                {
                    // 抢杠胡
                    mjlog.debug("cur_seat[%d], next hu seat[%d]\n", cur_seat, next);
                    
                    if (first_hu_seat == -1)
                    {
                        first_hu_seat = next;
                    }
                    hu_card = last_gang_card.value;
                    seats[next].gang_hu_flag = 1;
                    gang_hu_count++;
                }
            }
        }

        if (gang_hu_count == 2)
        {
            next_dealer_seat = first_hu_seat;
        }
        else if (gang_hu_count == 3)
        {
            next_dealer_seat = cur_seat;
        }

        if (first_hu_seat >= 0)
        {
            gang_hu_seat = cur_seat;
            return first_hu_seat;
        }
        else
        {
            return cur_seat;
        }
    }

    if (last_action == PLAYER_GUO)
    {
        if (wait_handle_action == PLAYER_CHU)
        {
            for (int i = 1; i < seat_max; i++)
            {
                int next = (cur_seat + i) % seat_max;

                if (seats[next].ready != 1)
                {
                    continue;
                }

                if (seats[next].handler_flag == 1 || next == wait_handler_seat)
                {
                    continue;
                }

                vector<int> &cards = seats[next].guo_peng_cards;
                if (find(cards.begin(), cards.end(), last_card.value) != cards.end())
                {
                    mjlog.debug("cur_seat[%d], guo peng seat[%d]\n", cur_seat, next);
                    continue;
                }

                if (seats[next].hole_cards.permit_peng(last_card.value)
                    || seats[next].hole_cards.permit_gang(last_card.value))
                {
                    mjlog.debug("cur_seat[%d], next peng gang seat[%d]\n", cur_seat, next);
					return next;
                }
            }

            int seatid = next_betting_seat(wait_handler_seat);
            if (seatid >= 0)
            {
                mjlog.debug("guo pai, cur_seat[%d], next play seat[%d]\n", cur_seat, seatid);
                return seatid;
            }
            else
            {
                mjlog.error("guo pai error next player\n");
                return -1;
            }
        }
        else if (wait_handle_action == PLAYER_GANG)
        {
            return wait_handler_seat;
        }
    }

    int seatid = next_betting_seat(cur_seat);
    if (seatid >= 0)
    {
        mjlog.debug("cur_seat[%d], next play seat[%d]\n", cur_seat, seatid);
        return seatid;
    }
    else
    {
        mjlog.error("error next player\n");
        return -1;
    }
}


int Table::prev_betting_seat(int pos)
{
	int cur = pos;

	for (int i = 0; i < seat_max; i++)
	{
		cur--;
		if (cur < 0)
			cur = seat_max - 1;

		if (seats[cur].betting == 1)
		{
			mjlog.debug("cur is betting seat[%d]\n", cur);
			return cur;
		}
	}

	mjlog.error("error active player\n");

	return -1;
}

int Table::count_betting_seats()
{
	int count = 0;

	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].betting == 1)
		{
			count++;
		}
	}

	return count;
}

int Table::get_last_betting()
{
	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].betting == 1)
		{
			return i;
		}
	}

	return -1;
}

/*  type: 1、钻石 2、金币 3、踢人卡 4、换牌 5、禁比卡 6、四倍卡 7、八倍卡 8、座驾 9、兑换券
	flag: 1、加 0、减
 	pos: 51、转转乐 52、摇摇乐
		 60、充值-购买钻石  61、钻石兑换金币 62、钻石兑换道具 63、钻石购买座驾 65、奖券兑换奖品
		 70、注册 71、登录领奖 72、破产领取 73、参拜财神 74、充值抽奖 75、领取邮件礼物 76、发送邮件礼物
		 77、玩N局奖励  78、领取任务奖励
*/
int Table::insert_flow_log(int ts, int uid, string ip, int pos, int vid, int zid, int tid, int type, int flag, int num, int anum)
{
	Jpacket packet;
    packet.val["roomid"] = ttid;
    packet.val["masterid"] = owner_uid;

    int index = 0;
    for (int i = 0; i < seat_max; i++)
    {
        Player* player = seats[i].player;

        int occ = 1;
        if (player == NULL)
        {
            occ = 0;
        }
        else if (player->uid == owner_uid)
        {
            continue;
        }

        switch (index)
        {
        case 0:
            packet.val["player1"] = occ == 1 ? player->uid : 0;
            break;
        case 1:
            packet.val["player2"] = occ == 1 ? player->uid : 0;
            break;
        case 2:
            packet.val["player3"] = occ == 1 ? player->uid : 0;
            break;
        default:
            break;
        }

        index++;
    }

    packet.val["rmb"] = num;
    packet.val["vid"] = type;
    packet.val["ts"] = (int)time(NULL);

    string str = packet.val.toStyledString().c_str();
    int ret = zjh.temp_rc->command("LPUSH rmb_flow_list %s", str.c_str());

    if (ret < 0)
    {
        mjlog.error("insert rmb_flow_record %s", str.c_str());
        return - 1;
    }
	return 0;
}

int Table::handler_send_gift_req(Player *player)
{ 
    return 0;
}

void Table::send_result_to_robot()
{
   
}

void Table::init_dealer()
{
    // 第一轮庄家做主
    if (round_count == 1)
    {
		int owner_flag = 0;
        for (int i = 0; i < seat_max; i++)
        {
			if(seats[i].ready == 0)
			{
				continue;
			}
            if (seats[i].uid == owner_uid)
            {
				owner_flag = 1;
                dealer = i;
                return;
            }
        }
		if (substitute == 1 && owner_flag == 0)
		{
			std::vector<int> tmp;
			for (int i = 0; i < seat_max; i++)
			{
				if (seats[i].occupied == 1)
				{
					tmp.push_back(i);
				}
			}
			int len = tmp.size();
			if (len > 0)
			{
				int index = random(0, len - 1);
				dealer = tmp[index];
				return;
			}
		}
	}
    // 后续谁胡谁做庄
    if (hu_seat >= 0)
    {
        dealer = hu_seat;
        hu_seat = -1;
        return;
    }

    // 一炮双响由第一个放炮的人做庄，一炮三响由点炮的人做庄
    if (next_dealer_seat >= 0)
    {
        dealer = next_dealer_seat;
        next_dealer_seat = -1;
    }

    // 荒庄由当局者做庄
    return;
}

int Table::handler_chi(Player* player)
{
    Json::Value &val = player->client->packet.tojson();
    Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();
    int card = val["card"].asInt();
    int pattern[3] = {0, };
    int size = val["pattern"].size();

    for (int index = 0; index < size; index++)
    {
        pattern[index] = val["pattern"][index].asInt();
    }

	if (seat.betting == 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_chi error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

    if (last_action != PLAYER_CHU && last_action != PLAYER_GUO)
    {
        handler_bet_error(player, action);
		mjlog.error("handler_chi action  error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    if (last_card.value != card)
    {
        handler_bet_error(player, action);
		mjlog.error("handler_chi value  error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    if (actions[NOTICE_CHI] != 1)
    {
        handler_bet_error(player, action);
		mjlog.error("handler_chi notice error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    last_action = PLAYER_CHI;

    seat.hole_cards.handler_chi(card, pattern, 0);
    seats[chu_seat].hole_cards.handler_chi(card, pattern, 1);

    seat.guo_peng_cards.clear();
	seat.obsorb_seats.push_back(chu_seat);
    seat.last_chu_card = 0;
	seat.guo_hu_flag = 0;

    dump_hole_cards(seat.hole_cards.cards, cur_seat, 1);


    if (seat.chi_san_bi_record.find(chu_seat) == seat.chi_san_bi_record.end())
    {
        seat.chi_san_bi_record[chu_seat] = 1;      
    }
    else
    {
        seat.chi_san_bi_record[chu_seat] += 1;
    }
	
	seat.last_actions[1] = seat.last_actions[0];
	seat.last_actions[0] = action;
	chi_count++;

    Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
    packet.val["card"] = card;
    packet.val["pattern"] = val["pattern"];
    packet.val["chu_seat"] = chu_seat;
    for (unsigned int j = 0; j < seat.hole_cards.forbid_chu.size(); j++)
    {
        packet.val["forbid_chu"].append(seat.hole_cards.forbid_chu[j].value); 
    }

    vector_to_json_array(seat.hole_cards.cards, packet, "holes");
	packet.end();
	unicast(player, packet.tostring());

    Jpacket packet1;
	packet1.val["cmd"] = SERVER_BET_SUCC_BC;
	packet1.val["seatid"] = player->seatid;
	packet1.val["uid"] = player->uid;
	packet1.val["action"] = action;
    packet1.val["card"] = card;
    packet1.val["chu_seat"] = chu_seat;
    packet1.val["pattern"] = val["pattern"];
    size = seat.hole_cards.cards.size();
    for (int i = 0; i < size; i++)
    {
        packet1.val["holes"].append(0);
    }
	packet1.end();
	broadcast(player, packet1.tostring());

    if (seat.chi_san_bi_record[chu_seat] == 2 && (forbid_hu == 1 || si_bi_forbid_hu == 1))
    {
        broadcast_forbid_hu(seats[chu_seat].player, 2);
    }
    else if (seat.chi_san_bi_record[chu_seat] == 3 && (forbid_hu == 1 || si_bi_forbid_hu == 1))
    {
        if (forbid_hu == 1)
        {
            seats[chu_seat].forbid_hu = 1;
            forbid_hu_record[seat.seatid] = chu_seat;
        }
        
        broadcast_forbid_hu(seats[chu_seat].player, 3);
    }
    else if (seat.chi_san_bi_record[chu_seat] == 4 && si_bi_forbid_hu == 1)
    {
        seats[chu_seat].forbid_hu = 1;
        forbid_hu_record[seat.seatid] = chu_seat;
        broadcast_forbid_hu(seats[chu_seat].player, 4);
    }

    if (seat.chi_san_bi_record[chu_seat] == 3)
    {
        seat.chi_san_bi.insert(chu_seat);
        seats[chu_seat].chi_san_bi.insert(player->seatid);
    }

    return 0;
}

int Table::handler_chu(Player* player)
{
    Json::Value &val = player->client->packet.tojson();
    Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();
    int card  = val["card"].asInt();
	
	int prev_seat = prev_betting_seat(player->seatid);
	if(seats[prev_seat].guo_hu_flag == 1)
	{
		seats[prev_seat].guo_hu_flag = 0;
	}
	
	if (seat.betting == 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_chu error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

    if (player->seatid != cur_seat)
    {
        handler_bet_error(player, action);
		mjlog.error("handler_chu seat error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    if (!seat.hole_cards.has_card(card))
    {
        handler_bet_error(player, action);
		mjlog.error("handler_chu card error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    if (seat.ting == 1 && card != seat.hole_cards.last_card.value)
    {
        handler_bet_error(player, action);
		mjlog.error("handler_chu card error, because has ting. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    if (seat.robot_flag == 1)
    {
        handler_bet_error(player, action);
		mjlog.error("handler_chu card error, because has robot flag. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    if (seat.hole_cards.cards.size() % 3 != 2)
    {
        handler_bet_error(player, action);
		mjlog.error("handler_chu card size error, because has robot flag. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    if (last_action == PLAYER_CHI && last_card.value == card)
    {
        handler_bet_error(player, action);
		mjlog.error("handler_chu card can't play before chi card. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    if (find(seat.hole_cards.forbid_chu.begin(), seat.hole_cards.forbid_chu.end(), card) != seat.hole_cards.forbid_chu.end())
    {
        handler_bet_error(player, action);
		mjlog.error("handler_chu card can't play last combinate card. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    last_action = PLAYER_CHU;
    last_card.set_value(card);
    chu_seat = seat.seatid;

    seat.hole_cards.handler_chu(card);
    seat.guo_peng_cards.push_back(last_card.value);
    seat.timeout_count = 0;
    seat.last_chu_card = card;

    dump_hole_cards(seat.hole_cards.cards, cur_seat, 5);

    seat.last_actions[1] = seat.last_actions[0];
    seat.last_actions[0] = action;
    // 测试可否胡牌
    // seat.hole_cards.analysis();
    if (seat.pao_hu_flag == 1)
    {
        seat.pao_hu_flag = 0;
        pao_hu_seat = -1;
    }

    if (seat.gang_hu_flag == 1)
    {
        seat.gang_hu_flag = 1;
        gang_hu_seat = -1;
    }

    int pg_flag = 0;
    for (int i = 0; i < seat_max; i++)
    {
        if (i == player->seatid)
        {
            continue;
        }

        if (seats[i].hole_cards.permit_peng(card)
            || seats[i].hole_cards.permit_gang(card))
        {
            pg_flag = 1;
            mjlog.debug("next peng gang seat is seat[%d]\n", i);
            break;
        }
    }

    if (seats[(player->seatid + 1) % 4].hole_cards.permit_chi(card))
    {
        pg_flag = 1;
        mjlog.debug("next chi seat\n");
    }

    for (int i = 0; i < seat_max; i++)
    {
        seats[i].handler_flag = 0;
        seats[i].guo_chi = 0;
    }

    wait_handle_action = action;
    wait_handler_seat = player->seatid;

    Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
    packet.val["card"] = card;
    packet.val["time_out"] = 0;
    packet.val["pg_flag"] = pg_flag;
    packet.val["chu_seat"] = -1;
    vector_to_json_array(seat.hole_cards.cards, packet, "holes");

    seat.hole_cards.handler_ting(card);
    if (seat.hole_cards.hu_cards.size() > 0)
    {
        vector_to_json_array(seat.hole_cards.hu_cards, packet, "hu_cards");
    }

	packet.end();
	unicast(player, packet.tostring());

    Jpacket packet1;
	packet1.val["cmd"] = SERVER_BET_SUCC_BC;
	packet1.val["seatid"] = player->seatid;
	packet1.val["uid"] = player->uid;
	packet1.val["action"] = action;
    packet1.val["card"] = card;
    packet1.val["time_out"] = 0;
    packet1.val["pg_flag"] = pg_flag;
    packet1.val["chu_seat"] = -1;

    int size = seat.hole_cards.cards.size();
    for (int i = 0; i < size; i++)
    {
        packet1.val["holes"].append(0);
    }
	packet1.end();
	broadcast(player, packet1.tostring());
    return 0;

}

int Table::handler_peng(Player* player)
{
    Json::Value &val = player->client->packet.tojson();
    Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();
    int card = val["card"].asInt();

	if(player->seatid != next_betting_seat(chu_seat))
	{
		for(int i = 0; i < seat_max; i++)
		{
			int next_id = next_betting_seat(chu_seat);
			if (next_id == player->seatid)
			{
				break;
			}

			if (seats[next_id].guo_hu_flag > 0)
			{
				seats[next_id].guo_hu_flag = 0;
			}
		}
	}

	if (seat.betting == 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_peng error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (cur_seat != player->seatid)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_peng seat error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (last_action != PLAYER_CHU && last_action != PLAYER_GUO)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_peng action  error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (last_card.value != card || actions[NOTICE_PENG] != 1)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_peng value  error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	last_action = PLAYER_PENG;
	seat.hole_cards.handler_peng(card, 0);
	seat.guo_hu_flag = 0;
	seat.guo_peng_cards.clear();
	seat.hole_cards.forbid_chu.clear();
	seats[chu_seat].hole_cards.handler_peng(card, 1);
	dump_hole_cards(seat.hole_cards.cards, cur_seat, 2);
	seat.obsorb_seats.push_back(chu_seat);
	seat.last_chu_card = 0;

	if (seat.chi_san_bi_record.find(chu_seat) == seat.chi_san_bi_record.end())
	{
		seat.chi_san_bi_record[chu_seat] = 1;      
	}
	else
	{
		seat.chi_san_bi_record[chu_seat] += 1;
	}
	seat.peng_card_record[card] = chu_seat;
	peng_count++;
	seat.last_actions[1] = seat.last_actions[0];
	seat.last_actions[0] = action;

	if (seat.pao_hu_flag == 1)
	{
		seat.pao_hu_flag = 0;
		pao_hu_seat = -1;
	}

	if (seat.gang_hu_flag == 1)
	{
		seat.gang_hu_flag = 1;
		gang_hu_seat = -1;
	}


	Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
	packet.val["card"] = card;
	packet.val["chu_seat"] = chu_seat;
	vector_to_json_array(seat.hole_cards.cards, packet, "holes");
	packet.end();
	unicast(player, packet.tostring());

	Jpacket packet1;
	packet1.val["cmd"] = SERVER_BET_SUCC_BC;
	packet1.val["seatid"] = player->seatid;
	packet1.val["uid"] = player->uid;
	packet1.val["action"] = action;
    packet1.val["card"] = card;
    packet1.val["chu_seat"] = chu_seat;
    int size = seat.hole_cards.cards.size();
    for (int i = 0; i < size; i++)
    {
        packet1.val["holes"].append(0);
    }
	packet1.end();
	broadcast(player, packet1.tostring());

    if (seat.chi_san_bi_record[chu_seat] == 2 && (forbid_hu == 1 || si_bi_forbid_hu == 1))
    {
        broadcast_forbid_hu(seats[chu_seat].player, 2);
    }
    else if (seat.chi_san_bi_record[chu_seat] == 3 && (forbid_hu == 1 || si_bi_forbid_hu == 1))
    {
        if (forbid_hu == 1)
        {
            seats[chu_seat].forbid_hu = 1;
            forbid_hu_record[seat.seatid] = chu_seat;
        }
        
        broadcast_forbid_hu(seats[chu_seat].player, 3);
    }
    else if (seat.chi_san_bi_record[chu_seat] == 4 && si_bi_forbid_hu == 1)
    {
        seats[chu_seat].forbid_hu = 1;
        forbid_hu_record[seat.seatid] = chu_seat;
        broadcast_forbid_hu(seats[chu_seat].player, 4);
    }

    if (seat.chi_san_bi_record[chu_seat] == 3)
    {
        seat.chi_san_bi.insert(chu_seat);
        seats[chu_seat].chi_san_bi.insert(player->seatid);
    }

    return 0;
}

int Table::handler_gang(Player* player)
{
    Json::Value &val = player->client->packet.tojson();
    Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();
    int card = val["card"].asInt();
    int gang_flag = val["gang_flag"].asInt();
	
	if(player->seatid != next_betting_seat(chu_seat))
	{
		for(int i = 0; i < seat_max; i++)
		{
			int next_id = next_betting_seat(chu_seat);
			if (next_id == player->seatid)
			{
				break;
			}

			if (seats[next_id].guo_hu_flag > 0)
			{
				seats[next_id].guo_hu_flag = 0;
			}
		}
	}

	if (seat.betting == 0)
	{
		handler_prop_error(player, action);
		mjlog.error("handler_gang error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

    if (cur_seat != player->seatid)
    {
        handler_prop_error(player, action);
		mjlog.error("handler_gang seat error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    if (actions[NOTICE_GANG] != 1)
    {
        handler_bet_error(player, action);
		mjlog.error("handler_gang notice error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    vector<Card>::iterator bit = seat.hole_cards.gang_cards.begin();
    vector<Card>::iterator eit = seat.hole_cards.gang_cards.end();

    if (find(bit, eit, card) == eit)
    {
        handler_bet_error(player, action);
		mjlog.error("handler_gang flag error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    int i = 0;
    for (; bit != eit; bit++)
    {
        if (seat.hole_cards.gang_cards[i].value == card)
        {
            gang_flag = seat.hole_cards.gang_flags[i];
            break;
        }
        i++;
    }

    last_action = PLAYER_GANG;
    seat.hole_cards.handler_gang(card, gang_flag, 0);
    seat.guo_hu_flag = 0;
    seat.guo_peng_cards.clear();
    seat.hole_cards.forbid_chu.clear();
    dump_hole_cards(seat.hole_cards.cards, cur_seat, 3);
    last_gang_card.set_value(card);
    seat.last_chu_card = 0;
	
	seat.last_actions[1] = seat.last_actions[0];
    seat.last_actions[0] = action;

    if (gang_flag == 0)
    {
        seat.obsorb_seats.push_back(chu_seat);
    }
    else if (gang_flag > 1)
    {
        seat.obsorb_seats.push_back(-1);
    }

    wait_handle_action = action;
    wait_handler_seat = player->seatid;
    // 只有是杠别的玩家的牌的时候才需要下面的处理(自己已有三个，别人打出来一个形成杠)
    if (gang_flag == 0)
    {
        seats[chu_seat].hole_cards.handler_gang(card, gang_flag, 1);

        if (seat.chi_san_bi_record.find(chu_seat) == seat.chi_san_bi_record.end())
        {
            seat.chi_san_bi_record[chu_seat] = 1;      
        }
        else
        {
            seat.chi_san_bi_record[chu_seat] += 1;
        }
    }

    if (gang_flag == 0)
    {
        seat.gang_seats.push_back(chu_seat);
        seat.total_ming_gang++;
    }
    else if (gang_flag == 1)
    {
        seat.gang_seats.push_back(seat.peng_card_record[card]);
        seat.total_ming_gang++;
    }
    else
    {
        seat.gang_seats.push_back(-1);
        seat.total_an_gang++;
    }

	if (seat.pao_hu_flag == 1)
    {
        seat.pao_hu_flag = 0;
        pao_hu_seat = -1;
    }

    if (seat.gang_hu_flag == 1)
    {
        seat.gang_hu_flag = 1;
        gang_hu_seat = -1;
    }
    
    Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
    packet.val["card"] = card;
    packet.val["gang_flag"] = gang_flag;
    vector_to_json_array(seat.hole_cards.cards, packet, "holes");
    if (gang_flag == 0)
    {
        packet.val["chu_seat"] = chu_seat;
    }
    else if (gang_flag == 1)
    {
        packet.val["chu_seat"] = seat.peng_card_record[card];
    }
    else
    {
        packet.val["chu_seat"] = -1;
    }
	packet.end();
	unicast(player, packet.tostring());

    Jpacket packet1;
	packet1.val["cmd"] = SERVER_BET_SUCC_BC;
	packet1.val["seatid"] = player->seatid;
	packet1.val["uid"] = player->uid;
	packet1.val["action"] = action;
    packet1.val["card"] = card;
    packet1.val["gang_flag"] = gang_flag;
    if (gang_flag == 0)
    {
        packet1.val["chu_seat"] = chu_seat;
    }
    else if (gang_flag == 1)
    {
        packet1.val["chu_seat"] = seat.peng_card_record[card];
    }
    else
    {
        packet1.val["chu_seat"] = -1;
    }
    //vector_to_json_array(seat.hole_cards.obsorb_cards, packet1, "obsorb_holes");
    int size = seat.hole_cards.cards.size();
    for (int i = 0; i < size; i++)
    {
        packet1.val["holes"].append(0);
    }
	packet1.end();
	broadcast(player, packet1.tostring());

    seat.gang_count[gang_flag]++;
    gang_count++;

    if (gang_flag == 0)
    {
        seats[chu_seat].fang_gang_count++;
    }
    else if (gang_flag == 1)
    {
        int fang_gang_seat = seat.peng_card_record[card];
        if (fang_gang_seat >= 0)
        {
            seats[fang_gang_seat].fang_gang_count++;
        }        
    }

    if (seat.chi_san_bi_record[chu_seat] == 2 && gang_flag == 0 && (forbid_hu == 1 || si_bi_forbid_hu == 1))
    {
        broadcast_forbid_hu(seats[chu_seat].player, 2);
    }
    else if (seat.chi_san_bi_record[chu_seat] == 3 && gang_flag == 0 && (forbid_hu == 1 || si_bi_forbid_hu == 1))
    {
        if (forbid_hu == 1)
        {
            seats[chu_seat].forbid_hu = 1;
            forbid_hu_record[seat.seatid] = chu_seat;
        }
        
        broadcast_forbid_hu(seats[chu_seat].player, 3);
    }
    else if (seat.chi_san_bi_record[chu_seat] == 4 && gang_flag == 0 && si_bi_forbid_hu == 1)
    {
        seats[chu_seat].forbid_hu = 1;
        forbid_hu_record[seat.seatid] = chu_seat;
        broadcast_forbid_hu(seats[chu_seat].player, 4);
    }

    if (seat.chi_san_bi_record[chu_seat] == 3 && gang_flag == 0)
    {
        seat.chi_san_bi.insert(chu_seat);
        seats[chu_seat].chi_san_bi.insert(player->seatid);
    }

    return 0;
}

int Table::handler_hu(Player* player)
{
    Json::Value &val = player->client->packet.tojson();
    Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();
    int card = val["card"].asInt();
    int hu_flag = 0;

	if (seat.betting == 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_hu error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

    if (seat.hole_cards.cards.size() % 3 == 1)
    {
        if (card != last_card.value && card != last_gang_card.value)
        {
            handler_bet_error(player, action);
            mjlog.error("handler_hu error. betting[1] uid[%d] seatid[%d] tid[%d].\n",
                      player->uid, player->seatid, tid);
            return -1;
        }
    }

    if (seat.hole_cards.size() % 3 == 1)
    {
        if (seat.hole_cards.permit_hu(card))
        {
            win_seatid = player->seatid;
            hu_flag = 0;
        }
    }
    else if (seat.hole_cards.permit_hu())
    {
        win_seatid = player->seatid;
        hu_flag = 1;      
    }
  
    if (win_seatid < 0)
    {
        handler_bet_error(player, action);
		mjlog.error("handler_hu error. betting[2] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    last_action = PLAYER_HU;

    seat.last_actions[1] = seat.last_actions[0];
    seat.last_actions[0] = action;

    vector<Card> cards = seat.hole_cards.cards;
    if (cards.size() % 3 == 2)
    {
        vector<Card>::iterator it = find(cards.begin(), cards.end(), card);
        if (it != cards.end())
        {
            cards.erase(it);
        }
    }

    hu_seat = player->seatid;
    hu_card = card;

    Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
    packet.val["card"] = card;
    packet.val["hu_flag"] = hu_flag;
    vector_to_json_array(cards, packet, "holes");
	packet.end();
	unicast(player, packet.tostring());

    Jpacket packet1;
	packet1.val["cmd"] = SERVER_BET_SUCC_BC;
	packet1.val["seatid"] = player->seatid;
	packet1.val["uid"] = player->uid;
	packet1.val["action"] = action;
    packet1.val["card"] = card;
    packet1.val["hu_flag"] = hu_flag;
    vector_to_json_array(cards, packet1, "holes");
	packet1.end();
	broadcast(player, packet1.tostring());

    return 0;
}

int Table::handler_guo(Player* player)
{
    Json::Value &val = player->client->packet.tojson();
    Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();

	if (seat.betting == 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_chi error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

    // 过胡不胡
    if (actions[NOTICE_HU] == 1)
    {
		if (seat.hole_cards.size() % 3 != 2)
		{
			seat.guo_hu_flag = 1;
		}
		else 
		{
			seat.guo_hu_flag = 2;
		}
    }

    // 过碰不碰
    if (actions[NOTICE_PENG] == 1 && seat.hole_cards.size() % 3 == 1)
    {
        seat.guo_peng_cards.push_back(last_card.value);
    }

    last_action = PLAYER_GUO;

    Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_UC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;	
	packet.end();
    unicast(player, packet.tostring());

    if (seat.pao_hu_flag == 1)
    {
        seat.pao_hu_flag = 0;
        pao_hu_seat = -1;
    }

    if (seat.gang_hu_flag == 1)
    {
        seat.gang_hu_flag = 0;
        gang_hu_seat = -1;
    }

    seat.handler_flag = 1;

	if(actions[NOTICE_CHI] == 1 && seat.hole_cards.size() %3 != 2)
	{
		seat.guo_chi = 1;
	}

    if (seat.hole_cards.size() % 3 == 2)
    {
        
    }
    else
    {
        count_next_bet();    
    }
   
    return 0;
}

int Table::handler_ting(Player* player)
{
    Json::Value &val = player->client->packet.tojson();
    Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();
    int card = val["card"].asInt();

	if (seat.betting == 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_ting error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

    int ret = seat.hole_cards.handler_ting(card);
    if (ret < 0)
    {
        handler_bet_error(player, action);
		mjlog.error("handler_ting error. card[%d] uid[%d] seatid[%d] tid[%d].\n",
                  card, player->uid, player->seatid, tid);
		return -1;
    }

    last_action = PLAYER_TING;
    seat.ting = 1;

    Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
    packet.val["card"] = card;
    vector_to_json_array(seat.hole_cards.cards, packet, "holes");
	packet.end();
    unicast(player, packet.tostring());
  
    Jpacket packet1;
	packet1.val["cmd"] = SERVER_BET_SUCC_BC;
	packet1.val["seatid"] = player->seatid;
	packet1.val["uid"] = player->uid;
	packet1.val["action"] = action;
    packet1.val["card"] = card;
	packet1.end();
    broadcast(player, packet1.tostring());

    return 0;
}

int Table::handler_cancel(Player *player)
{
    Json::Value &val = player->client->packet.tojson();
    Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();

	if (seat.betting == 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_cancel error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

    last_action = PLAYER_CANCEL;
    seat.ting = 0;

    Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;	
	packet.end();
    unicast(player, packet.tostring());

    return 0;
}

int Table::handler_jiabei(Player *player)
{
    Json::Value &val = player->client->packet.tojson();
    Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();

    if (actions[NOTICE_JIABEI] != 1)
    {
        handler_bet_error(player, action);
		mjlog.error("handler_jiabei error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    if (seat.jiabei >= MAX_JIABEI)
    {
        handler_bet_error(player, action);
		mjlog.error("handler_jiabei limit error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    seat.hu = 0;
    seat.jiabei *= 2;
    actions[NOTICE_JIABEI] = 0;
    last_action = PLAYER_JIABEI;

    Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;	
	packet.end();
    unicast(player, packet.tostring());

    return 0;
}

void Table::reset_actions()
{
    for (int i = 0; i < NOTICE_SIZE; i++)
    {
        actions[i] = 0;
    }
}

int Table::handler_dismiss_table(Player *player)
{
    Json::Value &val = player->client->packet.tojson();
    int agree = val["flag"].asInt();

    if (round_count == 0)
    {
        if (player->uid == owner_uid)
        {
            Jpacket packet;
            packet.val["cmd"] = SERVER_DISMISS_TABLE_SUCC_BC;
            packet.val["uid"] = player->uid;
            packet.val["name"] = player->name;
            packet.val["seatid"] = player->seatid;
            packet.val["agree"] = agree;
            packet.val["flag"] = 0;
            packet.end();
            broadcast(NULL, packet.tostring());

            if (transfer_flag)
            {
                if (players.find(origin_owner_uid) != players.end())
                {
                    players[origin_owner_uid]->incr_rmb(create_rmb);
                    Player* player1 = players[origin_owner_uid];
                    insert_flow_log((int)time(NULL), player1->uid, player1->remote_ip, 0, type, zid, ttid, type, 1, create_rmb, player1->rmb);
                }          
            }

            clean_table();
            reset();       
        }
        else
        {
            zjh.game->del_player(player);
        }

        return 0;
    }

    // 有一个人拒绝就取消解散房间
    if (agree == 0)
    {
        seats[player->seatid].dismiss = 2;
        broadcast_dismiss_status(4);
        ev_timer_stop(zjh.loop, &dismiss_timer);
        dismiss.clear();
        dismiss_flag = 0;
        dismiss_uid = 0;

        for (int i = 0; i < seat_max; i++)
        {
            seats[i].dismiss = 0;
        }
        return 0;
    }

    //int dismiss_size = zjh.conf["tables"]["min_dis_players"].asInt();

    // 第一个人申请解散
    if (dismiss.size() == 0)
    {
        dismiss_uid = player->uid;
        dismiss_flag = 1;
        seats[player->seatid].dismiss = 1;     
        dismiss.insert(player->uid);

        broadcast_dismiss_status(1);

        ev_timer_again(zjh.loop, &dismiss_timer);
    }
    else if (dismiss.find(player->uid) == dismiss.end())
    {
        seats[player->seatid].dismiss = 1;
        dismiss.insert(player->uid);

        if (static_cast<int>(dismiss.size()) >= (max_ready_players - 1))   // 满足解散请求同意人数
        {
            broadcast_dismiss_status(3);
            ev_timer_stop(zjh.loop, &dismiss_timer);

            for (int i = 0; i < seat_max; i++)
            {
                seats[i].bet = 0;
            }

            game_end(1);
            dismiss.clear();
            //clean_table();
            reset();
        }
        else                                                           
        {            
            broadcast_dismiss_status(2);
        }     
    }
  
    return 0;
}

void Table::broadcast_dismiss_status(int flag)
{
    Jpacket packet;
    packet.val["cmd"] = SERVER_DISMISS_TABLE_SUCC_BC;
    packet.val["flag"] = flag;

    packet.val["dismiss"] = dismiss_flag;
    if (dismiss_flag)
    {
        packet.val["dismiss_time"] = (int)ev_timer_remaining(zjh.loop, &dismiss_timer);
        packet.val["dismiss_uid"] = dismiss_uid;
    }
    else
    {
        packet.val["dismiss_time"] = 0;
        packet.val["dismiss_uid"] = 0;
    }

	int i = 0;
    std::map<int, Player*>::iterator it;
	for (it = players.begin(); it != players.end(); it++) {
		Player *p = it->second;
		Seat &seat = seats[p->seatid];

		packet.val["players"][i]["uid"] = p->uid;
        packet.val["players"][i]["name"] = p->name;
		packet.val["players"][i]["seatid"] = p->seatid;	
        packet.val["players"][i]["dismiss"] = seat.dismiss;
        i++;
    }

    packet.end();
    broadcast(NULL, packet.tostring());
}

void Table::clean_table()
{
    std::map<int, Player*>::iterator it = players.begin();
    std::map<int, Player*>::iterator nit = players.begin();

    state = ROOM_WAIT_GAME;



	if (round_count == 0 && substitute == 1)
	{
		Player::incr_rmb(owner_uid, create_rmb);
		zjh.game->del_subs_table(owner_uid);
	}

	if (round_count > 0)
	{
		if (!transfer_flag && substitute != 1)
        {
			/*
            players[owner_uid]->incr_rmb(0 - create_rmb * ratio);
            Player* player = players[owner_uid];
            insert_flow_log((int)time(NULL), player->uid, player->remote_ip, 0, type, zid, ttid, type, 0, 1 * ratio, player->rmb);
            */
			create_table_cost();
        }

        for (int i = 0; i < seat_max; i++)
        {
            if (seats[i].player != NULL)
            {
                if (seats[i].player->uid == owner_uid)
                {                   
                    seats[i].player->incr_total_create(1);
                }
                seats[i].player->incr_total_play(1);
            }
        }
    }
    
    for (int i = 0; i < seat_max; i++)
    {
        seats[i].dismiss = 0;
    }

    for (; it != players.end(); it = nit)
    {
        ++nit;
        if (it->second != NULL)
        {
            for (int i = 0; i < seat_max; i++)
            {
                if (it->second == seats[i].player)
                {
                    mjlog.debug("clean table");
                    zjh.game->del_player(it->second);
                    break;
                }
            }
        }
    }

    ready_players = 0;
    cur_players = 0;
    round_count = 0;
    dismiss_flag = 0;
    dismiss_uid = 0;
	if (substitute == 1)
	{
		substitute = 0;
		zjh.game->substitute_tables.erase(tid);
		clear_substitute_info();
		modify_substitute_info(2);
	}

	zjh.temp_rc->command("LPUSH tids_list %d", ttid);
    zjh.game->table_ttid.erase(ttid);
    zjh.game->set_table_flag(ttid, 0);

    ttid = -1;
    owner_uid = -1;
	owner_name = "";
	owner_remote_ip = "";
    origin_owner_uid = -1;
    transfer_flag = false;
    max_ready_players = seat_max;
	hu_seat = -1;
    next_dealer_seat = -1;
    game_end_flag = 0;
	dismiss.clear();
	redpackes.clear();

    for (int i = 0; i < seat_max; i++)
	{
		seats[i].clear();
	}

    reset();

    ev_timer_stop(zjh.loop, &preready_timer);
    ev_timer_stop(zjh.loop, &ready_timer);
    ev_timer_stop(zjh.loop, &dismiss_timer);
	ev_timer_stop(zjh.loop, &subs_timer);
    ev_timer_stop(zjh.loop, &ahead_start_timer);
    //ev_timer_stop(zjh.loop, &single_ready_timer);
}

void Table::dismiss_timer_cb(struct ev_loop *loop, struct ev_timer *w, int revents)
{
    Table *table = (Table*) w->data;
    ev_timer_stop(zjh.loop, &table->dismiss_timer);

    table->dismiss_timeout();
}

int Table::dismiss_timeout()
{
    //broadcast_dismiss_status(5);
    if (players.size() == 0)
    {
        return 0;
    }
    
    for (int i = 0; i < seat_max; i++)
    {
        seats[i].bet = 0;
    }

    game_end(1);

    dismiss.clear();
    //clean_table();
    reset();
    return 0;
}

void Table::vector_to_json_string(std::vector<Card> &cards, Jpacket &packet, string key)
{
    char buff[256] = {0, };
    int len = 0;

    if (cards.size() > 0)
    {
        for (unsigned int i = 0; i < cards.size() - 1; i++) {
            len = strlen(buff);
            snprintf(buff + len, sizeof(buff) - len, "%d_", cards[i].value); 
        }

        len = strlen(buff);
        snprintf(buff + len, sizeof(buff) - len, "%d", cards[cards.size() - 1].value);
        len = strlen(buff);
        buff[len] = '\0';
    }
	
    packet.val[key] = buff;
}

int Table::insert_flow_record()
{
    Jpacket packet;
    char rid[32] = {0, };

    snprintf(rid, 32, "%d_%d", round_ts, ttid);
    packet.val["roundid"] = rid;
    packet.val["tid"] = ttid;
    packet.val["create_time"] = (int)time(NULL);

    packet.val["did"] = seats[dealer].player->uid;
    packet.val["dname"] = seats[dealer].player->name;
    packet.val["dbet"] = seats[dealer].bet;
    packet.val["dip"] = seats[dealer].player->remote_ip;
	packet.val["owner_uid"] = owner_uid;
    packet.val["owner_name"] = owner_name;
    packet.val["substitute"] = substitute;

    vector_to_json_string(seats[dealer].hole_cards.cards, packet, "dcards");

    // std::vecotr<vecotr<Card> >::iterator it = seats[dealer].hole_cards.obsorb_cards.begin();

    // for (; it != seats[dealer].hole_cards.obsorb_cards.end(); it++)
    // {
    //     vector_to_json_array(*it, packet, "docards");
    // }
    
    int index = 1;
    for (int i = 0; i < seat_max; i++)
    {
        if (i == dealer || seats[i].occupied == 0)
        {
            mjlog.error("insert_flow_record seatid %d don't dealed\n", i);
            continue;
        }

        Player* player = seats[i].player;

        switch (index)
        {
        case 1:
            packet.val["x1id"] = player->uid;
            packet.val["x1name"] = player->name;
            packet.val["x1bet"] = seats[i].bet; 
            //packet.val["x1ratio"] = seats[i].bet_ratio;
            packet.val["x1ip"] = player->remote_ip;
            vector_to_json_string(seats[i].hole_cards.cards, packet, "x1cards");
            //vector_to_json_array(seats[i].hole_cards.obsorb_cards, packet, "x1ocards");
            break;

        case 2:
            packet.val["x2id"] = player->uid;
            packet.val["x2name"] = player->name;
            packet.val["x2bet"] = seats[i].bet;
            packet.val["x2ip"] = player->remote_ip;
            //packet.val["x2ratio"] = seats[i].bet_ratio;
            vector_to_json_string(seats[i].hole_cards.cards, packet, "x2cards");
            //vector_to_json_array(seats[i].hole_cards.obsorb_cards, packet, "x2ocards");
            break;

        case 3:
            packet.val["x3id"] = player->uid;
            packet.val["x3name"] = player->name;
            packet.val["x3bet"] = seats[i].bet;
            packet.val["x3ip"] = player->remote_ip;
            //packet.val["x3ratio"] = seats[i].bet_ratio;
            vector_to_json_string(seats[i].hole_cards.cards, packet, "x3cards");
            //vector_to_json_array(seats[i].hole_cards.obsorb_cards, packet, "x3ocards");
            break;

        default:
            break;
        }
        index++;
    }

    string str = packet.val.toStyledString().c_str();
    
    int ret = zjh.temp_rc->command("LPUSH flow_list %s", str.c_str());

    if (ret < 0)
    {
        mjlog.error("insert_flow_record %s", str.c_str());
        return - 1;
    }

    return 0;
}

int Table::insert_flow_round_record()
{
    Jpacket packet;
    char rid[32] = {0, };

    int init_money = zjh.conf["tables"]["init_money"].asInt();

    snprintf(rid, 32, "%d_%d", round_ts, ttid);
    packet.val["roundid"] = rid;
    packet.val["tid"] = ttid;
    packet.val["create_time"] = (int)time(NULL);
    packet.val["table_owner"] = owner_uid;
    packet.val["owner_name"] = owner_name;
    packet.val["substitute"] = substitute;
    packet.val["type"] = zjh.conf["tables"]["type"].asInt();

    int index = 1;
    for (int i = 0; i < seat_max; i++)
    {
        if (seats[i].occupied == 0)
        {
            continue;
        }

        Player* player = seats[i].player;

        switch (index)
        {
        case 1:
            packet.val["p1id"] = player->uid;
            packet.val["p1name"] = player->name;
            packet.val["p1bet"] = player->money - init_money;
            packet.val["p1ip"] = player->remote_ip;
            break;
        case 2:
            packet.val["p2id"] = player->uid;
            packet.val["p2name"] = player->name;
            packet.val["p2bet"] = player->money - init_money;
            packet.val["p2ip"] = player->remote_ip;
            break;
        case 3:
            packet.val["p3id"] = player->uid;
            packet.val["p3name"] = player->name;
            packet.val["p3bet"] = player->money - init_money;
            packet.val["p3ip"] = player->remote_ip;
            break;
        case 4:
            packet.val["p4id"] = player->uid;
            packet.val["p4name"] = player->name;
            packet.val["p4bet"] = player->money - init_money;
            packet.val["p4ip"] = player->remote_ip;
        default:
            break;
        }
        index++;
    }


	int owner_flag = 0;
	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].occupied == 0)
		{
			mjlog.error("insert_flow_round_record seatid %d don't dealed\n", i);
			continue;
		}

		Player* player = seats[i].player;
		packet.val["uid"] = player->uid;
		packet.val["uname"] = player->name;
		packet.val["uip"] = player->remote_ip;

		if (player->uid == owner_uid)
		{
			owner_flag = 1;
		}

		string str = packet.val.toStyledString().c_str();
		int ret = zjh.temp_rc->command("LPUSH flow_round_list %s", str.c_str());

		if (ret < 0)
		{
			mjlog.error("insert_flow_round_record %s", str.c_str());
		}
	}

	if(owner_flag == 0 && substitute == 1)
	{	
		packet.val["uid"] = owner_uid;
		packet.val["uname"] = owner_name;
		packet.val["uip"] = owner_remote_ip;
		string str = packet.val.toStyledString().c_str();
		int ret = zjh.temp_rc->command("LPUSH flow_round_list %s", str.c_str());

		if (ret < 0)
		{
			mjlog.error("insert_flow_round_record %s", str.c_str());
		}
	}

	return 0;
}

void Table::handler_net_status(Player* player, int status)
{
    Jpacket packet;
	packet.val["cmd"] = SERVER_NET_STATUS_BC;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = player->seatid;
    packet.val["name"] = player->name;
	packet.val["money"] = player->money;
	packet.val["rmb"] = player->rmb;
	packet.val["total_board"] = player->total_board;
    packet.val["status"] = status;

	packet.end();
	broadcast(player, packet.tostring());
}

int Table::calculate_base_score(int sid, int pao)
{
    Seat &seat = seats[sid];

    if (pao_hu_seat >= 0)
    {
        seat.hole_cards.analysis_card_type(calcul_flag, last_card.value);
    }
    else if (gang_hu_seat >= 0)
    {
        seat.hole_cards.analysis_card_type(calcul_flag, last_gang_card.value);
    }
    else
    {
        seat.hole_cards.analysis_card_type(calcul_flag);
    }

    seat.card_type = seat.hole_cards.card_type;

    int score = 0;


    switch (seat.card_type)
    {
    case CARD_TYPE_PING_HU:
        if (pao == 1)
        {
            score = 1;
        }
        else
        {
            if (men_qing_flag != 0)
            {
                score = seat.hole_cards.men_qing_flag ? 2 : 1;
            }
            else
            {
                score = 1;
            }      
        }        
        break;
    case CARD_TYPE_PENG_HU:
        if (pao == 1)
        {
            score = 3;
        }
        else
        {
            if (men_qing_flag != 0)
            {
                score = seat.hole_cards.men_qing_flag ? 4 : 2;
            }
            else
            {
                score = 2;
            }      
        }
        break;
    case CARD_TYPE_QING_YI_SE:
        if (pao == 1)
        {
            score = 3;
        }
        else
        {
            if (men_qing_flag != 0)
            {
                score = seat.hole_cards.men_qing_flag ? 4 : 2;
            }
            else
            {
                score = 2;
            }      
        }        
        break;

    case CARD_TYPE_QUAN_QIU_REN:
        if (pao == 1)
        {
            score = 3;
        }
        else
        {
            score = 2;
        }
        break;
        
    case CARD_TYPE_QI_DUI:
        if (pao == 1)
        {
            score = 3;
        }
        else
        {
            score = 4;
        }        
        break;
    case CARD_TYPE_PENG_YI_SE:
        if (pao == 1)
        {
            score = 6;
        }
        else
        {
            if (men_qing_flag != 0)
            {
                score = seat.hole_cards.men_qing_flag ? 6 : 4;
            }
            else
            {
                score = 4;
            }      
        }        
        break;
    case CARD_TYPE_QING_QI_DUI:
        score = 6;
        break;
    case CARD_TYPE_QING_QUAN_QIU_REN:
        if (pao == 1)
        {
            score = 6;
        }
        else
        {
            score = 4;
        }
        break;
    case CARD_TYPE_PENG_QUAN_QIU_REN:
        if (pao == 1)
        {
            score = 6;
        }
        else
        {
            score = 4;
        }
        break;
    case CARD_TYPE_QING_PENG_QUAN_QIU_REN:
        if (pao == 1)
        {
            score = 9;
        }
        else
        {
            score = 6;
        }
        break;
    default:
        score = 1;
    }

	if (zi_mo_upper_limit > 0 && score > zi_mo_upper_limit && pao ==0)
	{
		score = zi_mo_upper_limit;
	}

    if (men_qing_flag == 1 && seat.hole_cards.men_qing_flag == 1)
    {
        hu_men_qing_flag = 1;
    }
    // 额外番
    // 天胡
    // if (deck.get_count == 1 && sid == dealer)
    // {
    //     tian_hu_flag = 1;
    //     score *= 2;
    // }

    // //地胡
    // if (deck.get_count == 1 && sid != dealer)
    // {
    //     di_hu_flag = 1;
    //     score *= 2;
    // }
    // else if (deck.get_count == 2 && sid != dealer)
    // {
    //     if (chi_count == 0 && peng_count == 0 && gang_count == 0)
    //     {
    //         di_hu_flag = 1;
    //         score *= 2;
    //     }
    // }

    if (seat.last_actions[0] == PLAYER_HU && seat.last_actions[1] == PLAYER_GANG)
    {
        gang_shang_hua_flag = 1;
        if (score < 2)
        {
            score = 2;
        }
        else
        {
            score += 2;
        }
        
        int size = seat.gang_seats.size();
        if (size > 0)
        {
            gang_shang_hua_seat = seat.gang_seats[size - 1];
        }     
    }

    if (deck.permit_get() == 0 )
    {
        hai_di_hu_flag = 1;
        if (score < 2)
        {
            score = 2;
        }
        else
        {
            score += 2;
        }
    }
	
	if (pao == 1 && pao_hu_seat >= 0)
    {
        if (seats[pao_hu_seat].last_actions[1] == PLAYER_GANG && seats[pao_hu_seat].last_actions[0] == PLAYER_CHU)
        {
            gang_shang_pao = 1;
            if (score < 3)
            {
                score = 3;
            }
            else
            {
                score += 3;
            }
        }
    }

    if (gang_hu_seat >= 0)
    {
        if (score < 3)
        {
            score = 3;
        }
        else
        {
            score += 3;
        }
    }
	
	return score;
}

void Table::handler_count_fish()
{
    // 处理钓鱼
    if (fish_num == 0)
    {
        return;
    }

    // 获取每个人的鱼牌
    if (pao_hu_seat >= 0 || gang_hu_seat >= 0)
    {
        int start_seat = 0;
        if (pao_hu_seat >= 0)
        {
            start_seat = pao_hu_seat;
        }
        else
        {
            start_seat = gang_hu_seat;
        }

        int count = 0;
        for (int i = start_seat + 1; i < start_seat + seat_max; i++)
        {
            int index = i % 4;
            if (seats[index].ready != 1)
            {
                continue;
            }

            if (seats[index].gang_hu_flag == 1 || seats[index].pao_hu_flag == 1)
            {
                if (count == 0)
                {
                    seats[index].fish_cards = deck.fish_cards;
                }
                else
                {
                    deck.get_fish_cards(seats[index].fish_cards, fish_num);
                }
                count++;
            }
        }
    }
    else
    {
        for (int i = 0; i < seat_max; i++)
        {
            if (i == win_seatid)
            {
                seats[i].fish_cards = deck.fish_cards;
                break;
            }
        }
    }
	
    if (fish_calcul_flag == 0) // 159算法
    {
        for (int j = 0; j < seat_max; j++)
        {
            if (seats[j].ready != 1)
            {
                continue;
            }

            if (j != win_seatid && seats[j].gang_hu_flag != 1 && seats[j].pao_hu_flag != 1)
            {
                continue;
            }

            int fnum = seats[j].fish_cards.size();
            for (int i = 0; i < fnum; i++)
            {
                seats[j].zhong_fish.push_back(0);
                if (seats[j].fish_cards[i].face % 4 == 1)
                {
                    seats[j].fish_count++;                
                    seats[j].zhong_fish[i] = 1;
                }
            }
        }
    }
    else if (fish_calcul_flag == 1) // 跟庄算法
    {
        for (int j = 0; j < seat_max; j++)
        {
            if (seats[j].ready != 1)
            {
                continue;
            }

            if (j != win_seatid && seats[j].gang_hu_flag != 1 && seats[j].pao_hu_flag != 1)
            {
                continue;
            }

            int diff_seat = (j - dealer + 4) % 4;

            int fnum = seats[j].fish_cards.size();
            for (int i = 0; i < fnum; i++)
            {
                seats[j].zhong_fish.push_back(0);
                if ((seats[j].fish_cards[i].face - 1) % 4 == diff_seat)
                {
                    seats[j].fish_count++;
                    seats[j].zhong_fish[i] = 1;
                }
            }
        }
    }
    else // 手牌钓鱼
    {
        for (int j = 0; j < seat_max; j++)
        {
            if (seats[j].ready != 1)
            {
                continue;
            }

            if (j != win_seatid && seats[j].gang_hu_flag != 1 && seats[j].pao_hu_flag != 1)
            {
                continue;
            }

            int fnum = seats[j].fish_cards.size();
            for (int i = 0; i < fnum; i++)
            {
                seats[j].zhong_fish.push_back(0);
                if (seats[j].hole_cards.has_card(seats[j].fish_cards[i].value, 1))
                {
                    seats[j].fish_count++;
                    seats[j].zhong_fish[i] = 1;
                }
            }
        }
    }
}

void Table::update_account_bet()
{
    for (int i = 0; i < seat_max; i++)
    {
        seats[i].bet -= 1 * seats[i].fang_gang_count;

        if (seats[i].gang_count[0] > 0)
        {
            seats[i].bet += 1 * seats[i].gang_count[0];
        }
        
        if (seats[i].gang_count[1] > 0)
        {
            seats[i].bet += 1 * seats[i].gang_count[1];
        }

        if (seats[i].gang_count[2] > 0)
        {
            seats[i].bet += (max_ready_players - 1) * 1 * seats[i].gang_count[2];

            for (int j = 1; j < seat_max; j++)
            {
                int index = (i + j) % seat_max;

                if (seats[index].ready != 1)
                {
                    continue;
                }

                seats[index].bet -= 1 * seats[i].gang_count[2];      
            }
        }

        if (seats[i].gang_count[3] > 0)
        {
            seats[i].bet += (max_ready_players - 1) * 1 * seats[i].gang_count[3];
            
            for (int j = 1; j < seat_max; j++)
            {
                int index = (i + j) % seat_max;

                if (seats[index].ready != 1)
                {
                    continue;
                }

                seats[index].bet -= 1 * seats[i].gang_count[3];         
            }
        }
    }

    for (int i = 0; i < seat_max; i++)
    {
        Player* player = seats[i].player;
        if (player == NULL)
        {
            continue;
        }
        mjlog.debug("update acount gang, uid[%d], money[%d], bet[%d]\n", player->uid, player->money, seats[i].bet);
    }    

    if (win_seatid < 0 && pao_hu_count < 2 && gang_hu_count < 2)
    {
        return;
    }

    handler_count_fish();

    if (pao_hu_seat >= 0) // 放炮胡
    {
         // 放炮算法
        for (int i = 0; i < seat_max; i++)
        {
			if (seats[i].ready != 1)
            {
                continue;
			}

            if (i == win_seatid || seats[i].pao_hu_flag == 1)
            {
                int base_score = calculate_base_score(i, 1);
                int score = base_score;

                if (fish_flag == 0)
                {
                    score += (base_score * seats[i].fish_count);
                }
                else
                {
                    score += (fish_score * seats[i].fish_count);
                }

                if (chi_san_bi)
                {
                    std::set<int>::iterator it = seats[i].chi_san_bi.begin();
                    for (; it != seats[i].chi_san_bi.end(); it++)
                    {
                        int bi = *it;
                        if (seats[bi].pao_hu_flag == 1)
                        {
                            if (seats[i].chi_san_bi_record.find(bi) != seats[i].chi_san_bi_record.end())
                            {
                                if (seats[i].chi_san_bi_record[bi] >= 3)
                                {
                                    seats[i].chi_san_bi_record.erase(bi);
                                }
                            }
                            continue;
                        }
                        seats[i].bet += score;
                        seats[bi].bet -= score;

                        mjlog.debug("update acount chi san bi 1, bi[%d], money[%d]\n", bi, seats[i].bet);
                    }
                }
                
                seats[i].bet += score;
                seats[pao_hu_seat].bet -= score;

                // if (forbid_hu_record.find(i) != forbid_hu_record.end())
                // {
                //     seats[i].bet += score;
                //     seats[forbid_hu_record[i]].bet -= score;
                // }

                // 处理吃三笔
            }
        }
    }
    else if (gang_hu_seat >= 0) //抢杠胡
    {
        for (int i = 0; i < seat_max; i++)
        {
			if (seats[i].ready != 1)
            {
                continue;
            }
			
            if (i == win_seatid || seats[i].gang_hu_flag == 1)
            {
                int base_score = calculate_base_score(i, 1);
                int score = base_score;

                if (fish_flag == 0)
                {
                    score += (base_score * seats[i].fish_count);
                }
                else
                {
                    score += (fish_score * seats[i].fish_count);
                }

                if (chi_san_bi == 1)
                {
                    std::set<int>::iterator it = seats[i].chi_san_bi.begin();
                    for (; it != seats[i].chi_san_bi.end(); it++)
                    {
                        int bi = *it;
                        if (seats[bi].gang_hu_flag == 1)
                        {
                            if (seats[i].chi_san_bi_record.find(bi) != seats[i].chi_san_bi_record.end())
                            {
                                if (seats[i].chi_san_bi_record[bi] >= 3)
                                {
                                    seats[i].chi_san_bi_record.erase(bi);
                                }
                            }
                            continue;
                        }
                        seats[i].bet += score;
                        seats[bi].bet -= score;
                        mjlog.debug("update acount chi san bi 2, bi[%d], money[%d]\n", bi, seats[i].bet);
                    }
                }
                
                seats[i].bet += score;
                seats[gang_hu_seat].bet -= score;
            }
        }
    }
    else //自摸
    {
        int base_score = calculate_base_score(win_seatid, 0);
        int score = base_score;
        if (fish_flag == 0)
        {
            score += (base_score * seats[win_seatid].fish_count);
        }
        else
        {
            score += (fish_score * seats[win_seatid].fish_count);
        }

        // 自摸平湖牌型基本算法
        for (int i = 0; i < seat_max; i++)
        {      
            if (i == win_seatid)
            {               
                seats[i].bet += (max_ready_players - 1) * score;
            }
            else
            {
				if (gang_shang_hua_seat >= 0)
				{
					seats[gang_shang_hua_seat].bet -= score;
				}
				else 
				{
                	seats[i].bet -= score;
				}
            }
        }

        if (chi_san_bi == 1)
        {
            std::set<int>::iterator it = seats[win_seatid].chi_san_bi.begin();
            for (; it != seats[win_seatid].chi_san_bi.end(); it++)
            {
                int bi = *it;
                seats[win_seatid].bet += (2 * score);
				if (gang_shang_hua_seat >= 0)
				{
					seats[gang_shang_hua_seat].bet -= (2 * score);
				}
				else 
				{
                	seats[bi].bet -= (2 * score);
				}
                mjlog.debug("update acount chi san bi 3, bi[%d], money[%d]\n", bi, seats[win_seatid].bet);
            }
        }      
    }

    for (int i = 0; i < seat_max; i++)
    {
        Player* player = seats[i].player;
        if (player == NULL)
        {
            continue;
        }
        mjlog.debug("update acount, uid[%d], money[%d], bet[%d]\n", player->uid, player->money, seats[i].bet);
    }    
}

// action: 0 为发牌状态，1为吃牌，2为碰牌，3为杠牌，4为摸牌
void Table::dump_hole_cards(std::vector<Card>& cards, int seatid, int action)
{
    char buff[256] = {0, };
    const char* action_desc[] = {"发牌", "吃", "碰", "杠", "摸牌", "出牌"};

    std::vector<Card>::iterator it = cards.begin();
    for (; it != cards.end(); it++)
    {
        int len = strlen(buff);
        snprintf(buff + len, 256 - len, "%s ", it->get_card().c_str());
    }

    mjlog.debug("dumpcards table[%d] uid[%d] seat[%d] action[%s]\n", tid,
              seats[seatid].player->uid, seatid, action_desc[action]);
    mjlog.debug("dumpcards: %s\n", buff);
}

void Table::check_ip_conflict()
{
    if (static_cast<int>(players.size()) == seat_max && round_count == 0)
    {
        std::map<string, int> ip_count;
        for (int i = 0; i < seat_max; i++)
        {
            string ip = seats[i].player->remote_ip;
            if (ip_count.find(ip) == ip_count.end())
            {
                ip_count[ip] = 1;
            }
            else
            {
                ip_count[ip] += 1;
            }
        }


        if (static_cast<int>(ip_count.size()) != seat_max)
        {
            Jpacket packet;
            packet.val["cmd"] = SERVER_IP_CONFLICT_BC;
            std::map<string, int>::iterator it;
            int j = 0;
            for (it = ip_count.begin(); it != ip_count.end(); it++)
            {
                if (it->second >= 2)
                {
                    for (int i = 0; i < seat_max; i++)
                    {
                        string ip = seats[i].player->remote_ip;
                        if (ip == it->first)
                        {
                            packet.val["sam_ip"][j].append(seats[i].player->name);
                        }
                    }
                    j++;
                }
            }

            packet.end();
            broadcast(NULL, packet.tostring());
        }
    }
}

void Table::broadcast_forbid_hu(Player* player, int num)
{
    Jpacket packet;
    packet.val["cmd"] = SERVER_FORBID_HU_BC;
    packet.val["name"] = player->name;
    packet.val["uid"] = player->uid;
    packet.val["seatid"] = player->seatid;
    packet.val["count"] = num;
    packet.end();

    broadcast(NULL, packet.tostring());
}


void Table::handler_gps_notice(Player* player)
{
   Json::Value &val = player->client->packet.tojson();
   float jingdu = val["jingdu"].asFloat();
   float weidu = val["weidu"].asFloat();

   Seat &seat = seats[player->seatid];
   seat.jingdu = jingdu;
   seat.weidu = weidu;

   Jpacket packet;
   packet.val["cmd"] = SERVER_GPS_POS_NOTICE_SUCC_UC;
   packet.val["name"] = player->name;
   packet.val["uid"] = player->uid;
   packet.val["seatid"] = player->seatid;
   packet.end();

   unicast(player, packet.tostring());
}

void Table::handler_gps_dist_req(Player* player)
{
    Json::Value &val = player->client->packet.tojson();
    int seatid = val["seatid"].asInt();
    std::set<int> seatids;

    Jpacket packet;
    packet.val["cmd"] = SERVER_GPS_DIS_SUCC_UC;
    packet.val["seatid"] = seatid;

    for (int i = 0; i < 4; i++)
    {
        int next = (seatid + i) % 4;
        if (seats[next].jingdu < 1.0f || seats[next].weidu < 1.0f)
        {
            packet.val["ndseatid"].append(next);
            seatids.insert(next);
        }
    }
    
    for (int i = 1; i < 4; i++)
    {
        int next = (seatid + i) % 4;
        if (seatids.find(next) == seatids.end() && seatids.find(seatid) == seatids.end())
        {
            double distance = GetDistance(seats[seatid].jingdu, seats[seatid].weidu, seats[next].jingdu, seats[next].weidu);
            int idis = (int)distance;
            packet.val["distances"].append(idis);
        }
        else
        {
            packet.val["distances"].append(-1);
        }
    }
    packet.end();

    broadcast(NULL, packet.tostring());
}

double Table::GetDistance(double dLongitude1, double dLatitude1, double dLongitude2, double dLatitude2)
{
    double lat1 = (M_PI / 180) * dLatitude1;
    double lat2 = (M_PI / 180) * dLatitude2;
    
    double lon1 = (M_PI / 180) * dLongitude1;
    double lon2 = (M_PI / 180) * dLongitude2;
    
    //地球半径
    double R = 6378.137;
    
    //两点间距离 km，如果想要米的话，结果*1000就可以了
    double d =  acos(sin(lat1) * sin(lat2) + cos(lat1) * cos(lat2) * cos(lon2-lon1)) * R;
    
    return d * 1000;
}

void Table::handler_voice_req(Player* player)
{
    Json::Value &val = player->client->packet.tojson();
    string url = val["url"].asString();
    int record_time = val["record_time"].asInt();

    Jpacket packet;
    packet.val["cmd"] = SERVER_VOICE_SUCC_BC;
    packet.val["name"] = player->name;
    packet.val["uid"] = player->uid;
    packet.val["seatid"] = player->seatid;
    packet.val["url"] = url;
    packet.val["record_time"] = record_time;
    packet.end();

    broadcast(NULL, packet.tostring());
}

string Table::format_card_desc(int card_type)
{
    string desc;
    string str = "";
    string str_special = "";

    switch(card_type)
    {
    case CARD_TYPE_PING_HU:			// 平胡
        str = "平胡";
        break;
    case CARD_TYPE_PENG_HU:          // 碰碰胡
        str = "碰碰胡";
        break;
    case CARD_TYPE_QING_YI_SE:       // 清一色
        str = "清一色";
        break;
	case CARD_TYPE_QI_DUI:		    // 7对
        str = "七小对";
        break;
	case CARD_TYPE_PENG_YI_SE:		// 清碰
        str = "清一色,碰碰胡";
        break;
    case CARD_TYPE_QING_QI_DUI:      // 清七对
        str = "清一色七小对";
        break;
    case CARD_TYPE_QUAN_QIU_REN:     // 全求人
        str = "全求人";
        break;
    case CARD_TYPE_QING_QUAN_QIU_REN: // 清一色、全求人
        str = "清一色,全求人";
        break;
    case CARD_TYPE_PENG_QUAN_QIU_REN: // 碰碰胡，全求人
        str = "碰碰胡,全求人";
        break;
    case CARD_TYPE_QING_PENG_QUAN_QIU_REN: // 清一色、全求人，碰碰胡
        str = "清一色,碰碰胡,全求人";
        break;
    case CARD_TYPE_JIANG_JIANG_HU:   // 将将胡
        str = "将将胡";
        break;
    default:
        break;
    }

    if (card_type != 0)
    {
        if (tian_hu_flag == 1)
        {
            str_special = "天胡, ";
        }
        else if (di_hu_flag == 1)
        {
            str_special = "地胡, ";
        }
        else if (hai_di_hu_flag == 1)
        {
            str_special = "海底胡, ";
        }
        else if (gang_shang_hua_flag == 1)
        {
            str_special = "杠上花, ";
        }
        else if (gang_shang_pao == 1)
        {
            str_special = "杠上炮, ";
        }
        else if (quan_qiu_ren_pao == 1)
        {
            str_special = "全求人炮, ";
        }
        else if (hai_di_pao == 1)
        {
            str_special = "海底炮, ";
        }
        if (hu_men_qing_flag == 1)
        {
            str_special = "门前清, ";
        }
    }
    
    desc = str_special + str;
    return desc;
}

//提前开始的申请处理
void Table::handler_start_game_req(Player* player)
{
	Json::Value &val = player->client->packet.tojson();

	Seat &seat = seats[player->seatid];
	int flag = val["flag"].asInt();

	if (state != ROOM_WAIT_GAME)
	{
		return;
	}

	if (static_cast<int>(players.size() ) == 1 || static_cast<int> (players.size()) == seat_max)
	{
		return;
	}

	seat.ahead_start = (flag == 0 ? 0 : 1);

	if (ahead_start_flag == 0 && flag == 1)
	{
		ahead_start_flag = 1;
		ahead_start_uid = player->uid;
		seat.ahead_start = flag;
		if (flag == 1)
		{
            ev_timer_again(zjh.loop, &ahead_start_timer);
			broadcast_ahead_start_status(player, 1);		
		}
	}
	else if (ahead_start_flag == 0 && flag == 0)
	{
		seat.ahead_start = -1;
	}
	else
	{
		if (flag == 0)
		{
			seat.ahead_start = 0;
			broadcast_ahead_start_status(player, 0);

			ahead_start_flag = 0;
			ahead_start_uid = -1;

			for (int i = 0; i < seat_max; i++)
			{
				seats[i].ahead_start = -1;
			}

			ev_timer_stop(zjh.loop, &ahead_start_timer);
		}
		else
		{
			int total = 0;
			int count = 0;
			for (int i = 0; i < seat_max; i++)
			{
				if (seats[i].player != NULL)
				{
					total++;
					if (seats[i].ahead_start == 1)
					{
						count++;
					}
				}
			}

			broadcast_ahead_start_status(player, 1);

			if (total == count)
			{
				ahead_start_flag = 0;
				ahead_start_uid = -1;

				for (int i = 0; i < seat_max; i++)
				{
					seats[i].ahead_start = -1;
				}

				ev_timer_stop(zjh.loop, &ahead_start_timer);
				max_ready_players = std::max(2, total);

				test_game_start();
			}
		}
	}
}

//0：不同意提前开始 1：谁申请开始，同意开始 
void Table::broadcast_ahead_start_status(Player* player, int flag)
{
	Jpacket packet;
	packet.val["cmd"] = SERVER_START_GAME_REQ_BC;

	if (player != NULL)
	{
		packet.val["name"] = player->name;
		packet.val["uid"] = player->uid;
		packet.val["seatid"] = player->seatid;
	}

	packet.val["ahead_start_flag"] = ahead_start_flag;
	packet.val["ahead_start_uid"] = ahead_start_uid;

	if (flag == 1)
	{
		packet.val["ahead_start_time"] = (int)ev_timer_remaining(zjh.loop, &ahead_start_timer);
	}
	else
	{
		packet.val["ahead_start_time"] = 0;
	}

	int i = 0;
	std::map<int, Player*>::iterator it;
	for (it = players.begin(); it != players.end(); it++) {
		Player *p = it->second;
		Seat &seat = seats[p->seatid];

		packet.val["players"][i]["uid"] = p->uid;
		packet.val["players"][i]["name"] = p->name;
		packet.val["players"][i]["seatid"] = p->seatid;
		packet.val["players"][i]["ahead_start"] = seat.ahead_start;

		i++;
	}

	packet.end();
	broadcast(NULL, packet.tostring());

}

void Table::ahead_start_timer_cb(struct ev_loop *loop, struct ev_timer *w, int revents)
{
	Table *table = (Table*)w->data;
	ev_timer_stop(zjh.loop, &table->ahead_start_timer);

	table->ahead_start_timeout();
}

//提前开始申请时间到了默认是不提前开始
int Table::ahead_start_timeout()
{
	ahead_start_flag = 0;
	ahead_start_uid = -1;

	for (int i = 0; i < seat_max; i++)
	{
		seats[i].ahead_start = -1;
	}

	broadcast_ahead_start_status(NULL, 0);
	return 0;
}

int Table::handler_transfer_owner_req(Player *player)
{
    Json::Value &val = player->client->packet.tojson();
    //Seat &seat = seats[player->seatid];

    int transfer_uid = val["transfer_uid"].asInt();
    if (players.find(transfer_uid) == players.end())
    {
        handler_transfer_owner_req_error(player, 1);
        return -1;
    }

	if(substitute == 1)
	{
		handler_transfer_owner_req_error(player, 2);
        return -1;
    }

    if (transfer_uid == player->uid || transfer_uid == owner_uid || player->uid != owner_uid)
    {
        handler_transfer_owner_req_error(player, 2);
        return -1;
    }
	
	//AA付费没没有转让房主
	if(cost_select_flag == 2)
	{
		handler_transfer_owner_req_error(player, 5);
		return -1;
	}

    if (round_count != 0)
    {
        handler_transfer_owner_req_error(player, 3);
        return -1;
    }


    if (!transfer_flag)
    {
       players[origin_owner_uid]->incr_rmb(0 - create_rmb);
       Player* player1 = players[origin_owner_uid];
       insert_flow_log((int)time(NULL), player1->uid, player1->remote_ip, 0, type, zid, ttid, type, 0, create_rmb, player1->rmb);
    }

    Jpacket packet;
    packet.val["cmd"] = SERVER_TRANSFER_OWNER_SUCC_BC;
    packet.val["old_owner_uid"] = owner_uid;
    packet.val["owner_uid"] = transfer_uid;
    packet.val["owner_name"] = players[transfer_uid]->name;
    packet.val["old_owner_name"] = players[owner_uid]->name;
    packet.end();
    broadcast(NULL, packet.tostring());

    zjh.game->table_owners.erase(owner_uid);
    zjh.game->table_owners[transfer_uid] = tid;
    owner_uid = transfer_uid;
    transfer_flag = true;

    return 0;
}

void Table::handler_transfer_owner_req_error(Player* player, int reason)
{
    mjlog.error("handler transfer owner error, reason is %d.\n", reason);
    Jpacket packet;
    packet.val["cmd"] = SERVER_TRANSFER_OWNER_ERR_UC;
    packet.val["reason"] = reason;
    packet.end();
    unicast(player, packet.tostring());
}

int Table::handler_need_card_req(Player *player)
{
    Json::Value &val = player->client->packet.tojson();
	Seat & seat = seats[player->seatid];
	int need_card = val["need_card"].asInt();

	if (set_card_flag == 0)
    {
		mjlog.info("handler need card req error[%d]\n", set_card_flag);
		return 0;
	}

	seat.need_card = need_card;

	return 0;
}

/*------------------------*/
void Table::accumulate_hu()
{
    for (int i = 0; i < seat_max; i++)
    {
        Seat &seat = seats[i];
        if (seat.ready == 0)
        {
            continue;
        }

        if (seat.gang_hu_flag == 1 && gang_hu_seat >= 0)
        {
            seat.total_jie_pao++;
        }
        else if (seat.pao_hu_flag == 1 && pao_hu_seat >= 0)
        {
            seat.total_jie_pao++;
        }
        else if (i == win_seatid)
        {
            seat.total_zimo++;
        }
    }

    if (gang_hu_seat >= 0)
    {
        seats[gang_hu_seat].total_fang_pao++;
    }
    else if (pao_hu_seat >= 0)
    {
        seats[pao_hu_seat].total_fang_pao++;
    }  
}

int Table::set_create_rmb(int rmb, int aarmb)
{
    create_rmb = rmb;
	create_aa_rmb = aarmb;
    return 0;
}

int Table::handler_cmd(int cmd, Player* player)
{
	switch (cmd)
	{
		case CLIENT_READY_REQ:
			handler_ready(player);
			break;
		case CLIENT_BET_REQ:
			handler_bet(player);
			break;
		case CLIENT_CHAT_REQ:
			handler_chat(player);
			break;
		case CLIENT_FACE_REQ:
			handler_face(player);
			break;
		case CLIENT_INTERFACE_REQ:
			handler_interFace(player);
			break;
		case CLIENT_LOGOUT_REQ:
			break;
		case CLIENT_SWITCH_TABLE_REQ:
			break;
		case CLIENT_TABLE_INFO_REQ:
			handler_table_info(player);
			break;
		case CLIENT_PLAYER_INFO_REQ:
			handler_player_info(player);
			break;
		case CLIENT_PROP_REQ:
			handler_prop(player);
			break;
		case CLIENT_SEND_GIFT_REQ:
			handler_send_gift_req(player);
			break;
		case CLIENT_DISMISS_TABLE_REQ:
			handler_dismiss_table(player);
			break;
		case CLIENT_GPS_POS_NOTICE:
			handler_gps_notice(player);
			break;
		case CLIENT_GPS_DIS_REQ:
			handler_gps_dist_req(player);
			break;
		case CLIENT_VOICE_REQ:
			handler_voice_req(player);
			break;
		case CLIENT_START_GAME_REQ:
			handler_start_game_req(player);
			break;
		case CLIENT_NEED_CARD_REQ:
			handler_need_card_req(player);
			break;
		case CLIENT_TRANSFER_OWNER_REQ:
			handler_transfer_owner_req(player);
			break;
		case CLIENT_GET_REDPACKET_REQ:
			handler_get_redpacket_req(player);
			break;
		case CLIENT_GET_INTERNET_REQ:
			handler_get_internet_req(player);
			break;
		default:
			mjlog.error("invalid command[%d]\n", cmd);
			return -1;
	}

	return 0;
}


void Table::subs_timer_cb(struct ev_loop *loop, struct ev_timer *w, int revents)
{
    Table *table = (Table*) w->data;
    ev_timer_stop(zjh.loop, &table->ahead_start_timer);

    table->clean_table();
}


int Table::handler_redpacket()
{
    // 需要获取活动时间来判断是否允许派发红包
    int ret = zjh.temp_rc->command("hgetall rac");
    if (ret < 0)
    {
        mjlog.debug("no redpacket task.\n");
        return -1;
    }

    if (zjh.temp_rc->is_array_return_ok() < 0)
    {
        mjlog.debug("no redpacket task 1.\n");
        return -1;
    }

    long btime = zjh.temp_rc->get_value_as_int("btime");
    long etime = zjh.temp_rc->get_value_as_int("etime");
	std::string citys = zjh.temp_rc->get_value_as_string("area");
	long now = time(NULL);

	mjlog.debug("handler_redpacket btime [%ld] etime[%ld] citys[%s] now[%ld]\n", 
			btime, etime, citys.c_str(), now);

	std::string all_city = "*";

	if (now < btime || now > etime)
	{
		mjlog.debug("no redpacket task 2.\n");
		return -1;
	}

	// 获取一个红包值
	ret = zjh.temp_rc->command("rpop red_list");

	if (ret >= 0 && max_ready_players == seat_max )
	{
		if (zjh.temp_rc->reply->str == NULL)//-----
		{
			mjlog.debug("cann't get a redpacket 3.\n");
			return 0;
			
		}
	
		std::vector<int> tmp;
		for (int i = 0; i < seat_max; i++)
		{
			if (seats[i].ready != 1 || seats[i].player == NULL)
			{
				continue;
			}
			mjlog.debug("handler_redpacket btime [%ld] etime[%ld] citys[%s] now[%ld] player->city[%s]\n", 
					btime, etime, citys.c_str(), now, seats[i].player->city.c_str());
			if (citys != all_city)
			{
				std::size_t found  = citys.find(seats[i].player->city);
				if (found != std::string::npos)
				{
					tmp.push_back(i);
					seats[i].city_red_falg = 1;
				}
			}
			else 
			{
				tmp.push_back(i);
				seats[i].city_red_falg = 1;
			}
		}
		if(tmp.size() > 0)
		{
			if (red_type == 0)
			{
				// 预先分配好红包
				random_shuffle(tmp.begin(), tmp.end());
				int len = tmp.size();
				int red_seatid = 0;
				if (len > 0)
				{
					int index = random(0, len - 1);	
					red_seatid = tmp[index];
				}
				int red_values[4] = {0, };
				red_values[red_seatid] = atoi(zjh.temp_rc->reply->str);	
				//random_shuffle(red_value, red_value + 4);
				redpackes.clear();
				for(int i = 0; i < 4; i++)
				{
					redpackes.push_back(red_values[i]);
				}
				//redpackes.assign(red_value, red_value + 4);
				mjlog.debug("red_seatid [%d] red_values[red_seatid] [%d] redpackes.size() [%d] \n", 
						red_seatid ,red_values[red_seatid], redpackes.size()); 
			}
			else if(red_type == 1) 
			{
				redpackes.clear();
				for(int i = 0; i < (seat_max -1 ); i++)
				{
					redpackes.push_back(0);
				}
				int red_values = atoi(zjh.temp_rc->reply->str);
				redpackes.push_back(red_values);
			}
			mjlog.debug("handler_redpacket redpackes.size() [%d]\n", redpackes.size());
			Jpacket packet;
			packet.val["cmd"] = SERVER_DISPATCH_REDPACKET_SUCC_BC;
			packet.end();      
			broadcast(NULL, packet.tostring());
		}
	}
	else
	{
		mjlog.debug("cann't get a redpacket.\n");
	}

	return 0;
}

int Table::record_redpacket(Player *player, int value)
{
	Jpacket packet;
	packet.val["tid"] = ttid;
	packet.val["uid"] = player->uid;
	packet.val["money"] = value;
	packet.val["time"] = (int)time(NULL);
	packet.end();

	string str = packet.val.toStyledString().c_str();

	int ret = zjh.temp_rc->command("LPUSH red_record_list %s", str.c_str());

	if (ret < 0)
	{
		mjlog.error("insert_flow_record %s", str.c_str());
		return - 1;
	}

	player->incr_total_red(value);
	return 0;
}

int Table::handler_get_redpacket_req(Player *player)
{
	if (redpackes.size() == 0)
	{
		Jpacket packet;
		packet.val["cmd"] = SERVER_GET_REDPACKET_ERR_UC;
		packet.val["err_str"] = "红包不存在。";
		packet.end();
		unicast(player, packet.tostring());
		return 0;
	}

	Seat & seat = seats[player->seatid];
	if(seat.already_get_red == 1)
	{
		Jpacket packet;
		packet.val["cmd"] = SERVER_GET_REDPACKET_ERR_UC;
		packet.val["err_str"] = "您的红包已经领取过了。";
		packet.end();
		unicast(player, packet.tostring());
		return 0;
	}

	if (seat.city_red_falg != 1)
	{
		seat.already_get_red = 1;
		Jpacket packet;
		packet.val["cmd"] = SERVER_GET_REDPACKET_ERR_UC;
		packet.val["err_str"] = "您不在活动所在区域，不能参与活动。";
		packet.end();
		unicast(player, packet.tostring());
		return 0;
	}

	//Json::Value &val = player->client->packet.tojson();
	int value = 0;
	if(red_type == 0)
	{
		value = redpackes[player->seatid];
	}
	else if (red_type == 1)
	{
		if(redpackes.size() > 0 && seat.city_red_falg == 1)
		{
			value = redpackes.back();
			redpackes.pop_back();
		}
	}
	seat.already_get_red = 1;

	Jpacket packet;
	packet.val["cmd"] = SERVER_GET_REDPACKET_SUCC_UC;	
	packet.val["value"] = value;
	packet.end();
	unicast(player, packet.tostring());

	if (value > 0)
	{
		Jpacket packet1;
		packet1.val["cmd"] = SERVER_GET_REDPACKET_SUCC_BC;
		packet1.val["value"] = value;
		packet1.val["uid"] = player->uid;
		packet1.val["name"] = player->name;
		packet1.end();
		broadcast(NULL, packet1.tostring());

		record_redpacket(player, value);
	}

	return 0;
}

int Table::handler_invite_advantage(Player *player)
{
	if(player->pre_uid < 1000)
	{
		mjlog.debug("handler_invite_advantage player total_board[%d] pre_uid[%d]\n", player->total_board,  player->pre_uid);
		return -1;
	}

	int ret = zjh.temp_rc->command("hgetall bac");
    if (ret < 0)
    {
        mjlog.debug("no invite advantage task.\n");
        return -1;
    }

    if (zjh.temp_rc->is_array_return_ok() < 0)
    {
        mjlog.debug("no invite advantage task 1.\n");
        return -1;
    }

    long btime = zjh.temp_rc->get_value_as_int("btime");
    long etime = zjh.temp_rc->get_value_as_int("etime");
	std::string citys = zjh.temp_rc->get_value_as_string("area");
	std::string all_city = "*";
	long now = time(NULL);

	mjlog.debug("handler_invite_advantage btime [%ld] etime[%ld] citys[%s] now[%ld] player->city[%s]\n", 
					btime, etime, citys.c_str(), now, player->city.c_str());

	if (now < btime || now > etime)
	{
		mjlog.debug("handler_redpacket not at right time now [%d] btime[%d] etime[%d].\n", now, btime, etime);
		return -1;
	}
	
	if(citys != all_city) 
	{
		std::size_t found  = citys.find(player->city);
		if (found == std::string::npos)
		{
			mjlog.debug("handler_redpacket not at activity city citys[%s] player->city[%s].\n", citys.c_str(), player->city.c_str());
			return -1;
		}
	}

	
	player->incr_ac_board(vid, 1);

	mjlog.debug("handler_invite_advantage player uid[%d] ac_board[%d] pre_uid[%d]\n", 
				player->uid, player->ac_board,  player->pre_uid);

	if(player->ac_board != 8)
	{	
		return -1;
	}
	
	ret = zjh.temp_rc->command("sadd tj_uid %d", player->uid);
	if(ret < 0)
	{
		mjlog.debug("handler_invite_advantage sadd tj_uid %d\n", player->uid);
		return -1;
	}
	return 0;
}

void Table::handler_substitute_req(Player* player)
{
    //int create_rmb = zjh.conf["tables"]["create_rmb"].asInt();
	Json::Value &val = player->client->packet.tojson();
	std::string playway_desc = val["playway_desc"].asString();//------
	int player_max = val["player_max"].asInt();



    player->tid = -1;

    Jpacket packet;
	packet.val["cmd"] = SERVER_SUBSTITUTE_SUCC_UC;
	packet.val["uid"] = player->uid;
    packet.val["ttid"] = ttid;
    packet.val["rmb"] = create_rmb ;
	packet.end();
	unicast(player, packet.tostring());
    owner_uid = player->uid;
    owner_name = player->name;

    player->incr_rmb(0 - create_rmb );//-------

    char buff[128] = {0, };

   	snprintf(buff, 128, "柳州麻将，%d局", max_play_board);
    
    int ret = zjh.temp_rc->command("hmset create:%d:%d uid %d, tid %d, type %d, size 0, status 0, ts %d, ruler %s player_max %d",
                                   player->uid, ttid, player->uid, ttid, type, (int)time(NULL), playway_desc.c_str(), player_max);

    if (ret < 0)
    {
        mjlog.error("insert substitute info error");
        return;
    }

    ret = zjh.temp_rc->command("lpush create:%d create:%d:%d", player->uid, player->uid, ttid);
    if (ret < 0)
    {
        mjlog.error("add substitute info error");
        return;
    }
}

void Table::modify_substitute_info(Player* player, int flag)
{
    int ret = zjh.temp_rc->command("hget create:%d:%d size", owner_uid, ttid);
    if (ret < 0)
    {
        mjlog.error("get substitute info error");
        return;
    }

    if (zjh.temp_rc->reply->str == NULL)
    {
        mjlog.error("get substitute str error");
        return;
    }
    int size = atoi(zjh.temp_rc->reply->str);


    if (flag == 1)
    {
        size += 1;

        ret = zjh.temp_rc->command("hmset create:%d:%d uid%d %d size %d", owner_uid, ttid, size, player->uid, size);
        if (ret < 0)
        {
            mjlog.error("modify substitute info error");
            return;
        }
    }
    else
    {
        if (size <= 0)
        {
            return;
        }

        vector<int> uids;
        for (int i = 0; i < seat_max; i++)
        {
            if (seats[i].player != NULL)
            {
                uids.push_back(seats[i].uid);
            }
        }

        size = uids.size();

        if (uids.size() == 4)
        {
            ret = zjh.temp_rc->command("hmset create:%d:%d uid1 %d, uid2 %d, uid3 %d, uid4 %d, size %d", owner_uid, ttid,
                                       uids[0], uids[1], uids[2], uids[3], size);
        }
        else if (uids.size() == 3)
        {
            ret = zjh.temp_rc->command("hmset create:%d:%d uid1 %d, uid2 %d, uid3 %d, size %d", owner_uid, ttid,
                                       uids[0], uids[1], uids[2], size);
        }
        else if (uids.size() == 2)
        {
            ret = zjh.temp_rc->command("hmset create:%d:%d uid1 %d, uid2 %d, size %d", owner_uid, ttid, uids[0], uids[1], size);
        }
        else if (uids.size() == 1)
        {
            ret = zjh.temp_rc->command("hmset create:%d:%d uid1 %d, size %d", owner_uid, ttid, uids[0], size);
        }
        else if (uids.size() == 0)
        {
            ret = zjh.temp_rc->command("hset create:%d:%d size %d", owner_uid, ttid, size);
        }

        if (ret < 0)
        {
            mjlog.error("set substitute info error");
        }    
    }
}

void Table::modify_substitute_info(int status)
{
    int ret = zjh.temp_rc->command("hset create:%d:%d status %d", owner_uid, ttid, status);
    if (ret < 0)
    {
        mjlog.error("modify substitute status error");
        return;
    }
}

void Table::clear_substitute_info()
{
    // int ret = zjh.temp_rc->command("del create:%d:%d", owner_uid, ttid);
    // if (ret < 0)
    // {
    //     mjlog.error("clear substitute info error");
    // }

    int ret = zjh.temp_rc->command("lrem create:%d 0 create:%d:%d", owner_uid, owner_uid, ttid);
    if (ret < 0)
    {
        mjlog.error("clear substitute info1 error");
    }
}

void Table::create_table_cost()			//创建房间扣费函数
{
    int base_play_board = zjh.conf["tables"]["base_board"].asInt();
    base_play_board = base_play_board <= 0 ? 8 : base_play_board;   
    int ratio = max_play_board / base_play_board;
    ratio = std::max(1, ratio);

	if(cost_select_flag == 1)				//房主扣费
	{
		mjlog.debug("create_table_cost cost_select_flag [%d] uid[%d] create_rmb[%d]\n", 
				cost_select_flag, owner_uid, create_rmb);
		players[owner_uid]->incr_rmb(0 - create_rmb);
		Player* player = players[owner_uid];
		insert_flow_log((int)time(NULL), player->uid, player->remote_ip, 0, type, zid, ttid, type, 0, create_rmb, player->rmb);
	}
	else if (cost_select_flag == 2)		//AA扣费
	{
		for (int i = 0; i < seat_max; i++)
		{
			if (seats[i].player != NULL)
			{
				mjlog.debug("create_table_cost cost_select_flag [%d] uid[%d] create_rmb[%d]\n", 
						cost_select_flag, seats[i].player->uid, create_rmb);
				seats[i].player->incr_rmb(0 - create_rmb);
				insert_flow_log((int) time(NULL), seats[i].player->uid, seats[i].player->remote_ip, 0, type, zid, ttid, type, 0, create_rmb, seats[i].player->rmb);
			}

		}

	}
}

int Table::random_dealer()
{
	std::vector<int> tmp;
	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].ready == 1)
		{
			tmp.push_back(i);
		}
	}

	int len = tmp.size();
	if (len > 0)
	{
		int index = random(0, len - 1);
		int i = tmp[index];
		mjlog.debug("len[%d] index[%d] i[%d]\n", len, index, i);
		return i;
	}

	return -1;
}

int Table::handler_owner_dismiss_table()
{
	if(substitute == 1)
	{
		Jpacket packet;
		packet.val["cmd"] = SERVER_DISMISS_TABLE_SUCC_BC;
		packet.val["uid"] = owner_uid;
		packet.val["name"] = owner_name;
		packet.val["flag"] = 0;
		packet.end();
		broadcast(NULL, packet.tostring());
	}
	return 0;
}

int Table::handler_get_internet_req(Player * player)
{  
   Json::Value &val = player->client->packet.tojson();
   Jpacket packet;
   packet.val["cmd"] = SERVER_GET_INTERNET_UC;
   packet.val["uid"] = player->uid;
   packet.val["massage"] = val["massage"];
   packet.end();
   unicast(player, packet.tostring());
   return 0;
}
