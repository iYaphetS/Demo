#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <errno.h>
#include <algorithm>
#include <assert.h>
#include <sstream>
#include "math.h"
#include "zjh.h"
#include "game.h"
#include "log.h"
#include "table.h"
#include "client.h"
#include "player.h"
#include "proto.h"
#include "card.h"

extern ZJH zjh;
extern Log mjlog;


#define PREREADY_TIME_OUT 6
#define SINGLE_READY_TIME_OUNT 8
#define READY_TIME_OUT 6
#define START_TIME_OUT 1
#define BET_TIME_OUT 10
#define COMPARE_TIME_OUT 7
#define READY_OUT_TIME_OUT 60
#define DISMISS_TIME_OUT  30

#define SUBS_TIME_OUT 108000

Table::Table() :
preready_timer_stamp(PREREADY_TIME_OUT),
ready_timer_stamp(READY_TIME_OUT),
start_timer_stamp(START_TIME_OUT),
bet_timer_stamp(BET_TIME_OUT),
compare_timer_stamp(COMPARE_TIME_OUT),
dismiss_timer_stamp(DISMISS_TIME_OUT),     
subs_timer_stamp(SUBS_TIME_OUT)
{
	preready_timer.data = this;
	ev_timer_init(&preready_timer, Table::preready_timer_cb,
			preready_timer_stamp, preready_timer_stamp);

	ready_timer.data = this;
	ev_timer_init(&ready_timer, Table::ready_timer_cb, ready_timer_stamp,
			ready_timer_stamp);

	start_timer.data = this;
	ev_timer_init(&start_timer, Table::start_timer_cb, start_timer_stamp, start_timer_stamp);

	bet_timer.data = this;
	ev_timer_init(&bet_timer, Table::bet_timer_cb, bet_timer_stamp, bet_timer_stamp);

	compare_timer.data = this;
	ev_timer_init(&compare_timer, Table::compare_timer_cb, compare_timer_stamp, compare_timer_stamp);
	//single_ready_timer.data = this;
	//ev_timer_init(&single_ready_timer, Table::single_ready_timer_cb, single_ready_timer_stamp, single_ready_timer_stamp);

	dismiss_timer_stamp = zjh.conf["tables"]["dismiss_time"].asInt();
	dismiss_timer.data = this;
	ev_timer_init(&dismiss_timer, Table::dismiss_timer_cb, dismiss_timer_stamp, dismiss_timer_stamp);

	ahead_start_timer_stamp = zjh.conf["tables"]["begin_time"].asInt();
	ahead_start_timer.data = this;
	ev_timer_init(&ahead_start_timer, Table::ahead_start_timer_cb, ahead_start_timer_stamp, ahead_start_timer_stamp);

    subs_timer.data = this;
    ev_timer_init(&subs_timer, Table::subs_timer_cb, subs_timer_stamp, subs_timer_stamp);

	cur_flow_mode = FLOW_END;

	owner_uid = -1;
	owner_name = "";
	owner_remote_ip = "";
	origin_owner_uid = -1;
    game_end_flag = 0;
}

Table::~Table()
{
	ev_timer_stop(zjh.loop, &preready_timer);
	ev_timer_stop(zjh.loop, &ready_timer);
	ev_timer_stop(zjh.loop, &start_timer);
	ev_timer_stop(zjh.loop, &bet_timer);
	ev_timer_stop(zjh.loop, &compare_timer);

	ev_timer_stop(zjh.loop, &dismiss_timer);
	ev_timer_stop(zjh.loop, &ahead_start_timer);
	ev_timer_stop(zjh.loop, &subs_timer);
}

int Table::init(TableConf *conf)
{
	// mjlog.debug("begin to init table [%d]\n", table_id);
	tid = conf->tid;
	ttid = conf->tid;
	vid = conf->vid;
	zid = conf->zid;
	type = conf->type;
	fee = conf->fee;
	min_money = conf->min_money;
	max_money = conf->max_money;
	base_money = conf->base_money;
	base_ratio = conf->base_ratio;
	min_round = conf->min_round;
	max_round = conf->max_round;
	seat_max = 4;

	peng_gang_fen = conf->peng_gang_fen;
	fang_gang_fen = conf->fang_gang_fen;
	an_gang_fen = conf->an_gang_fen;
	ming_gang_fen = conf->ming_gang_fen;
	set_card_flag = conf->set_card_flag;

	max_ready_players = seat_max;
	max_play_board = 8;
	round_count = 0;
	cur_players = 0;
	players.clear();
	ready_players = 0;
	for (int i = 0; i < seat_max; i++)
	{
		seats[i].clear();
		seats[i].seatid = i;
	}

	reset();
	dismiss_flag = 0;
	dismiss_uid = 0;
	hu_seat = -1;
	get_card_seat = -1;
	gang_hu_seat = -1;
	pao_hu_seat = -1;
	pao_hu_count = 0;
	gang_hu_count = 0;

	follow_dealer = 0;
	has_pair_add = 0;
	no_ghost_add = 0;
	has_rob_gang_hu = 0;
	has_rob_gang_al = 0;
	has_rob_ming_gang = 0;
	has_bar_burst_al = 0;
	has_steadily_high = 0;
	horse_follow_end = 0;
    transfer_flag = false;
	create_rmb = 0;
	create_aa_rmb = 0;
	ghost_cards.set_value(0);
	trun_card.set_value(0);

	state = ROOM_WAIT_GAME;
	redpackes.clear();
	red_type = 0;
	ts = time(NULL);


	return 0;
}

void Table::init_table_type(TableCustomConf *conf)
{
	max_play_board = conf->max_play_board;
	has_rob_gang_hu = conf->has_rob_gang_hu;
	has_rob_ming_gang = conf->has_rob_ming_gang;
	has_rob_gang_al = conf->has_rob_gang_al;
	has_bar_burst_al = conf->has_bar_burst_al;
	hu_pair = conf->hu_pair;
	has_pair_add = conf->has_pair_add;
	no_ghost_add = conf->no_ghost_add;
	has_feng = conf->has_feng;
	follow_dealer = conf->follow_dealer;
	has_steadily_high = conf->has_steadily_high;
	has_ghost = conf->has_ghost; 
	horse_num = conf->horse_num;
	horse_follow_end = conf->horse_follow_end;
	horse_with_gang = conf->horse_with_gang;
	no_wan_card = conf->no_wan_card;
	four_ghose_hu = conf->four_ghose_hu;
	four_ghose_hu_two = conf->four_ghose_hu_two;
	bumper_two = conf->bumper_two;
	seven_pairs_four = conf->seven_pairs_four;
	all_in_one_four = conf->all_in_one_four;
	unitary_nine_six = conf->unitary_nine_six;
	mixed_one_color_eight = conf->mixed_one_color_eight;
	thirteen_unitary_eight = conf->thirteen_unitary_eight;
	has_yao_jiu = conf->has_yao_jiu;
	fang_pao = conf->ping_hu_fang_pao;
	hu_seat = -1;
	dealer = -1;
	substitute = conf->substitute;
	cost_select_flag = conf->cost_select_flag;
	redpackes.clear();

	mjlog.debug("tables table_type[%d],max_play_board[%d],has_rob_gang_hu[%d],"
			"has_rob_ming_gang[%d],has_rob_gang_al[%d],has_bar_burst_al[%d],hu_pair[%d],"
			"has_pair_add[%d],no_ghost_add[%d],has_feng[%d],follow_dealer[%d],has_steadily_high[%d],"
			"has_ghost[%d],horse_num[%d],horse_follow_end[%d],horse_with_gang[%d],no_wan_card[%d],"
			"four_ghose_hu[%d],four_ghose_hu_two[%d],bumper_two[%d],seven_pairs_four[%d],"
			"all_in_one_four[%d],unitary_nine_six[%d],mixed_one_color_eight[%d],"
			"thirteen_unitary_eight[%d],ping_hu_fang_pao[%d],\n",
			type, conf->max_play_board, conf->has_rob_gang_hu, conf->has_rob_ming_gang,
			conf->has_rob_gang_al, conf->has_bar_burst_al, conf->hu_pair,
			conf->has_pair_add, conf->no_ghost_add, conf->has_feng, conf->follow_dealer,
			conf->has_steadily_high, conf->has_ghost, conf->horse_num,
			conf->horse_follow_end, conf->horse_with_gang, conf->no_wan_card,
			conf->four_ghose_hu, conf->four_ghose_hu_two, conf->bumper_two,
			conf->seven_pairs_four, conf->all_in_one_four, conf->unitary_nine_six,
			conf->mixed_one_color_eight, conf->thirteen_unitary_eight,
			conf->ping_hu_fang_pao);
    
	
	ts = time(NULL);
	//推到胡不能缺少万字牌和 没有牌型的加倍
	if (type == 1){
		no_wan_card = 0;
		bumper_two = 0;
		four_ghose_hu = 0;
		seven_pairs_four = 0;
		all_in_one_four = 0;
		unitary_nine_six = 0;
		four_ghose_hu_two = 0;
		mixed_one_color_eight = 0;
		thirteen_unitary_eight = 0;
	}
	else if (type == 9)
	{//做牌推倒胡默认可以胡7对但是没有7对加倍而是7对4倍
		hu_pair = 1;//左派推到胡默认能胡7对不用勾选
		has_pair_add = 0;//做牌推倒胡没有7对加番
		has_steadily_high = 0;//做牌推到胡没有节节高(即连庄)
		no_wan_card = 0;//做牌推到胡不能没有万字牌

	}

	if (has_ghost == 0)
	{
		no_ghost_add = 0;
	}

	if (horse_num == 0)
	{
		horse_follow_end = 0;
		horse_with_gang = 0;
	}

	if (has_rob_gang_hu == 0)
	{
		has_rob_gang_al = 0;
		has_rob_ming_gang = 0;
	}
	if (hu_pair == 0)
	{
		has_pair_add = 0;
	}
	//白板做鬼
	if (has_ghost == 1)
	{
		deck.init(has_feng, 1, horse_num, hu_pair,Card::BaiV);
		ghost_cards.set_value(Card::BaiV);
		trun_card.set_value(0);
	}
	else if (has_ghost == 2)
	{
		deck.init(has_feng, 1, horse_num, hu_pair,0);
	}
	else 
	{
		deck.init(has_feng, 0, horse_num, hu_pair,0);
		ghost_cards.set_value(0);
		trun_card.set_value(0);
	}
	//deck.init(has_feng, has_ghost, horse_num, hu_pair);
}

int Table::get_card_type(int salt)
{
	int tmp = random(0, 99, salt);
	mjlog.debug("get_card_type[%d] salt[%d].\n", tmp, salt);
	return 0;
}

int Table::broadcast(Player *p, const std::string &packet)
{
	Player *player;
	std::map<int, Player*>::iterator it;
	for (it = players.begin(); it != players.end(); it++)
	{
		player = it->second;
		if (player == p || player->client == NULL)
		{
			continue;
		}
		player->client->send(packet);
	}

	return 0;
}

int Table::unicast(Player *p, const std::string &packet)
{
	if (p->client)
	{
		return p->client->send(packet);
	}
	return -1;
}

int Table::random(int start, int end)
{
	srand((unsigned) time(NULL));
	return start + rand() % (end - start + 1);
}

int Table::random(int start, int end, int seed)
{
	srand((unsigned) time(NULL) + seed);
	return start + rand() % (end - start + 1);
}

void Table::reset()
{
	state = READY;
	ready_players = 0;
	start_seat = 0;
	cur_seat = 0;
	cur_action = 0;
	cur_bet = 0;
	total_bet = 0;
	last_action = 0;
	last_card.set_value(0);
	win_seatid = -1;
	gang_hu_seat = -1;
	pao_hu_seat = -1;
	pao_hu_count = 0;
	gang_hu_count = 0;
	last_action_seatid = -1;
	fang_gang_hu_seat = -1;
	fang_gang_seat = -1;
	for (int i = 0; i < seat_max; i++){
		if (i != dealer){
			seats[i].always_dealer_count = 0;
		}
	}
	follow_dealer_count = 0;
	dealer_card.set_value(0);
	count_card = 0;
	if(has_ghost == 2)
	{
		ghost_cards.set_value(0);
		trun_card.set_value(0);
	}
	last_gang_card.set_value(0);
	forbid_hu_record.clear();
	fang_count.clear();
	gang_fang_count.clear();
	last_gang_flag = -1;

	tian_hu_flag = 0; //天胡
	di_hu_flag = 0; //地胡
	hai_di_hu_flag = 0;//海底胡
	gang_shang_hua_flag = 0; //杠上花
	gang_shang_pao = 0; //杠上炮
	hai_di_pao = 0;

	gang_shang_hua_seat = -1;
	wait_handle_action = -1;
	wait_handler_seat = -1;
	ahead_start_flag = 0;
	ahead_start_uid = -1;

	chi_count = 0;
	peng_count = 0;
	gang_count = 0;
}

void Table::vector_to_json_array(std::vector<Card> &cards, Jpacket &packet, string key)
{
	for (unsigned int i = 0; i < cards.size(); i++)
	{
		packet.val[key].append(cards[i].value);
	}

	if (cards.size() == 0)
	{
		packet.val[key].append(0);
	}
}

void Table::vector_to_json_array(std::list<Card> &cards, Jpacket &packet, string key)
{
	std::list<Card>::iterator it = cards.begin();
	for (; it != cards.end(); it++)
	{
		packet.val[key].append(it->value);
	}
}

void Table::vector_to_json_array(std::vector<int> &values, Json::Value &val, string key)
{
	for (unsigned int i = 0; i < values.size(); i++)
	{
		val[key].append(values[i]);
	}
}

void Table::vector_to_json_array(std::vector<Card> &cards, Json::Value &val, string key)
{
	for (unsigned int i = 0; i < cards.size(); i++)
	{
		val[key].append(cards[i].value);
	}
}

void Table::map_to_json_array(std::map<int, Card> &cards, Jpacket &packet,
		string key)
{
	std::map<int, Card>::iterator it;
	for (it = cards.begin(); it != cards.end(); it++)
	{
		Card &card = it->second;
		packet.val[key].append(card.value);
	}
}

void Table::json_array_to_vector(std::vector<Card> &cards, Jpacket &packet,
		string key)
{
	Json::Value &val = packet.tojson();

	for (unsigned int i = 0; i < val[key].size(); i++)
	{
		Card card(val[key][i].asInt());

		cards.push_back(card);
	}
}

int Table::handler_login(Player *player)
{  
	Json::Value &val = player->client->packet.tojson();
    bool is_create = (val["cmd"].asInt() == CLIENT_CREATE_TABLE_REQ);

    if (substitute == 1 && is_create)
    {
        handler_substitute_req(player);
		ev_timer_again(zjh.loop, &subs_timer);
        return 0;
    }

	if (players.find(player->uid) == players.end())
	{
		players[player->uid] = player;
		player->tid = tid;
		// todo check.
		player->seatid = sit_down(player);
		Seat &seat = seats[player->seatid];
		// seat.ready = 0;
		seat.uid = player->uid;
		if (player->seatid < 0)
		{
			return -1;
		}
		cur_players++;

		handler_login_succ_uc(player);
		handler_login_succ_bc(player);

		if (is_create)
		{
			owner_uid = player->uid;
			owner_name = player->name;
			owner_remote_ip = player->remote_ip;
			origin_owner_uid = owner_uid;
			state = ROOM_WAIT_GAME;
		}

		handler_table_info(player);

		if (player->uid < 1000 && player->uid > 100)
		{
			handler_ready(player);
		}

        if (substitute == 1)
        {
            modify_substitute_info(player, 1);
        }

		mjlog.info("handler login succ uid[%d] money[%d] cur_players[%d] tid[%d].\n", player->uid, player->money, cur_players, tid);

		return 0;
	}

	return -1;
}

int Table::sit_down(Player *player)
{
	std::vector<int> tmp;
	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].occupied == 0)
		{
			tmp.push_back(i);
		}
	}

	int len = tmp.size();
	if (len > 0)
	{
		int index = random(0, len - 1);
		int i = tmp[index];
		mjlog.debug("len[%d] index[%d] i[%d]\n", len, index, i);
		// seats[i].reset(); 
		seats[i].occupied = 1;
		seats[i].player = player;
		return i;
	}

	return -1;
}

void Table::stand_up(Player *player)
{
	seats[player->seatid].clear();
}

int Table::del_player(Player *player)
{
	if (players.find(player->uid) == players.end())
	{
		mjlog.debug("player uid[%d] talbe del_player is error.", player->uid);
		return -1;
	}
	Seat &seat = seats[player->seatid];
	if (seat.ready == 1)
	{
		ready_players--;
	}
	player->stop_offline_timer();
	players.erase(player->uid);
	stand_up(player);
	cur_players--;

    modify_substitute_info(player, 0);

	// if (player->uid == owner_uid)
	// {
	// 	owner_uid = -1;
	// 	zjh.game->table_owners.erase(player->uid);
	// }

	return 0;
}

int Table::handler_login_succ_uc(Player *player)
{
	Jpacket packet;
	packet.val["cmd"] = SERVER_LOGIN_SUCC_UC;
	packet.val["vid"] = player->vid;
	packet.val["zid"] = player->zid;
	packet.val["tid"] = player->tid;
	packet.end();
	unicast(player, packet.tostring());

	return 0;
}

// SERVER_LOGIN_SUCC_BC
int Table::handler_login_succ_bc(Player *player)
{
	Seat &seat = seats[player->seatid];

	Jpacket packet;
	packet.val["cmd"] = SERVER_LOGIN_SUCC_BC;
	// packet.val["vid"] = player->vid;
	// packet.val["zid"] = player->zid;
	// packet.val["tid"] = player->tid;
	packet.val["seatid"] = player->seatid;
	packet.val["ready"] = seat.ready;
	packet.val["betting"] = seat.betting;
	packet.val["role"] = seat.role;
	packet.val["status"] = seat.status;
	packet.val["bet"] = seat.bet;

	packet.val["uid"] = player->uid;
	packet.val["name"] = player->name;
	packet.val["sex"] = player->sex;
	packet.val["avatar"] = player->avatar;
	packet.val["zone"] = player->zone;

	packet.val["rmb"] = player->rmb;
	packet.val["money"] = player->money;
	packet.val["total_board"] = player->total_board;
	packet.val["pay_total"] = player->pay_total;

	packet.val["ip"] = player->remote_ip;
	packet.end();

	broadcast(player, packet.tostring());
	return 0;
}

int Table::handler_table_info(Player *player)
{
	Jpacket packet;
	packet.val["cmd"] = SERVER_TABLE_INFO_UC;
	packet.val["vid"] = player->vid;
	packet.val["zid"] = player->zid;
	packet.val["tid"] = player->tid;
	packet.val["ttid"] = ttid;
	packet.val["seatid"] = player->seatid;

	if (round_count == 0)
	{
		state = ROOM_WAIT_GAME;
	}
	packet.val["state"] = state;
	packet.val["dealer"] = dealer;
	packet.val["cur_seat"] = cur_seat;
	packet.val["cur_bet"] = cur_bet;
	packet.val["total_bet"] = total_bet;
	packet.val["base_money"] = base_money;
	packet.val["remain_cards"] = deck.size();
	packet.val["robot_flag"] = seats[player->seatid].robot_flag;
	packet.val["owner_uid"] = owner_uid;
	packet.val["cur_round"] = round_count;
	packet.val["total_round"] = max_play_board;
	packet.val["dismiss"] = dismiss_flag;
	packet.val["ahead_start_flag"] = ahead_start_flag;

	packet.val["table_type"] = type;//桌子类型
	packet.val["max_play_count"] = max_play_board;//一局多少牌局
	packet.val["has_rob_gang_hu"] = has_rob_gang_hu;//是否可以抢杠胡
	packet.val["has_rob_ming_gang"] = has_rob_ming_gang;//明杠可抢
	packet.val["has_rob_gang_al"] = has_rob_gang_al;//抢杠全包
	packet.val["has_bar_burst_al"] = has_bar_burst_al;//杠爆 全包
	packet.val["no_ghost_add"] = no_ghost_add;//没有鬼牌 是否加倍
	packet.val["has_feng"] = has_feng;// 是否有风牌
	packet.val["follow_dealer"] = follow_dealer;//是否跟庄
	packet.val["has_ghost"] = has_ghost;// 是否有鬼牌
	packet.val["horse_num"] = horse_num;// 买马数量
	packet.val["horse_follow_end"] = horse_follow_end;//马跟底分
	packet.val["horse_with_gang"] = horse_with_gang;//马跟杠
	if (type == 1)
    {
		packet.val["hu_pair"] = hu_pair;// 可否胡对子
		packet.val["has_pair_add"] = has_pair_add;//对子胡 是否加番
		packet.val["has_steadily_high"] = has_steadily_high;//是否可以节节高
	}
	/*else if (type == 9)
    {
		packet.val["hu_pair"] = hu_pair;// 可否胡对子
		packet.val["has_pair_add"] = has_pair_add;//对子胡 是否加番
		packet.val["has_steadily_high"] = has_steadily_high;//是否可以节节高
		packet.val["no_wan_card"] = no_wan_card;//不带万字牌
	}*/
	else if (type == 9)
    {
		packet.val["four_ghose_hu"] = four_ghose_hu;//四鬼胡牌
		packet.val["four_ghose_hu_two"] = four_ghose_hu_two;//四鬼胡牌2倍
		packet.val["bumper_two"] = bumper_two;//碰碰胡2倍
		packet.val["seven_pairs_four"] = seven_pairs_four;//七对胡4倍
		packet.val["all_in_one_four"] = all_in_one_four;//清一色4倍
		packet.val["unitary_nine_six"] = unitary_nine_six;//幺九6倍
		packet.val["has_yao_jiu"] = has_yao_jiu;//含幺九即可
		packet.val["mixed_one_color_eight"] = mixed_one_color_eight;//混一色8倍
		packet.val["thirteen_unitary_eight"] = thirteen_unitary_eight;//十三幺8倍
	}
    packet.val["substitute"] = substitute;
    packet.val["cost_select_flag"] = cost_select_flag;
	mjlog.debug("handler_table_info redpackes.size() [%d] seats[%d].already_get_red [%d]\n", 
			redpackes.size(), player->seatid, seats[player->seatid].already_get_red);
	if(redpackes.size() > 0 && seats[player->seatid].already_get_red == 0)
	{
		packet.val["get_red"] = 1;
	}
	else 
	{
		packet.val["get_red"] = 0;
	}

	packet.val["chu_seat"] = chu_seat;
	packet.val["chu_card"] = last_card.value;
	packet.val["has_ghost"] = has_ghost;//0:没有鬼牌 、1:固定鬼牌 、2:翻鬼牌
	packet.val["ghost_card"] = ghost_cards.value;//鬼牌的值
	packet.val["trun_card"] = trun_card.value;//翻开牌的值

	if (dismiss_flag)
	{
		packet.val["dismiss_time"] = (int)ev_timer_remaining(zjh.loop, &dismiss_timer);
		packet.val["dismiss_uid"] = dismiss_uid;
	}
	else
	{
		packet.val["dismiss_time"] = 0;
		packet.val["dismiss_uid"] = 0;
	}

	if (ahead_start_flag)
	{
		packet.val["ahead_start_time"] = (int)ev_timer_remaining(zjh.loop, &ahead_start_timer);
		packet.val["ahead_start_uid"] = ahead_start_uid;
	}
	else
	{
		packet.val["ahead_start_time"] = 0;
		packet.val["ahead_start_uid"] = 0;
	}

	if (state == BETTING)
	{
		packet.val["remain_time"] = ev_timer_remaining(zjh.loop, &bet_timer);
	}

	std::map<int, Player*>::iterator it;
	int i = 0;
	for (it = players.begin(); it != players.end(); it++)
	{
		Player *p = it->second;
		Seat &seat = seats[p->seatid];

		packet.val["players"][i]["uid"] = p->uid;
		packet.val["players"][i]["seatid"] = p->seatid;
		packet.val["players"][i]["ready"] = seat.ready;
		packet.val["players"][i]["betting"] = seat.betting;
		packet.val["players"][i]["role"] = seat.role;
		packet.val["players"][i]["status"] = seat.status;
		packet.val["players"][i]["bet"] = seat.bet;
		packet.val["players"][i]["robot_flag"] =  seat.robot_flag;
		packet.val["players"][i]["dismiss"] = seat.dismiss;
		packet.val["players"][i]["ahead_start"] = seat.ahead_start;
		packet.val["players"][i]["net_status"] = (p->client == NULL) ? 0 : 1;
		for (unsigned int c = 0; c < seat.play_procedure.size(); c++)
		{
			packet.val["players"][i]["procedure"].append(seat.play_procedure[c].c_str());
		}

		for (unsigned int j = 0; j < seat.obsorb_seats.size(); j++)
		{
			packet.val["players"][i]["obsorb_seats"].append(seat.obsorb_seats[j]);
		}

		if (player == p)
		{
			if (state == BETTING)
			{
				std::vector<Card>::iterator vit;

				if (seat.hole_cards.cards.size() % 3 == 1)
				{
					vit = seat.hole_cards.cards.begin();
					for (; vit != seat.hole_cards.cards.end(); vit++)
					{
						packet.val["players"][i]["holes"].append(vit->value);
					}
				}
				else
				{
					vit = seat.hole_cards.oldcards.begin();
					for (; vit != seat.hole_cards.oldcards.end(); vit++)
					{
						packet.val["players"][i]["holes"].append(vit->value);
					}
				}             

				int osize = seat.hole_cards.obsorb_cards.size();
				for (int j = 0; j < osize; j++)
				{
					vit = seat.hole_cards.obsorb_cards[j].begin();
					for (; vit != seat.hole_cards.obsorb_cards[j].end(); vit++)
					{
						packet.val["players"][i]["obsorb_holes"][j].append(vit->value);
					}
				}

				std::list<Card>::iterator lit = seat.hole_cards.discard_cards.begin();

				for (; lit != seat.hole_cards.discard_cards.end(); lit++)
				{
					packet.val["players"][i]["discard_holes"].append(lit->value);
				}

				packet.val["players"][i]["ting_flag"] = seat.ting;

				osize = seat.hole_cards.hu_cards.size();
				for (int j = 0; j < osize; j++)
				{
					packet.val["players"][i]["hu_cards"].append(seat.hole_cards.hu_cards[j].value);
				}

				if (cur_seat == seat.seatid)
				{
					for (int j = 0; j < NOTICE_SIZE; j++)
					{
						packet.val["players"][i]["action"].append(actions[j]);
					}

					if (actions[NOTICE_GANG] == 1)
					{
						packet.val["gang_flag"] = seat.hole_cards.gang_flags.back();
						vector_to_json_array(seat.hole_cards.gang_cards, packet, "gang_cards");
						for (unsigned int j = 0; j < seat.hole_cards.gang_flags.size(); j++)
						{
							packet.val["gang_flags"].append(seat.hole_cards.gang_flags[j]);
						}
					}

					if (actions[NOTICE_TING] == 1)
					{       
						int index = 0;
						std::map<int, vector<Card> >::iterator it = seat.hole_cards.ting_cards.begin();
						for (; it != seat.hole_cards.ting_cards.end(); it++)
						{
							packet.val["ting_cards"].append(it->first);
							int size = it->second.size();
							for (int j = 0; j < size; j++)
							{
								packet.val["ting_pattern"][index].append(it->second[j].value);
							}
							index++;
						}  
					}

					if (actions[NOTICE_CHI] == 1)
					{
						vector_to_json_array(seat.hole_cards.eat_cards, packet, "chi_cards");
						packet.val["card"] = 0;
						packet.val["chi_card"] = last_card.value;
					}

					if (actions[NOTICE_PENG] == 1)
					{
						packet.val["card"] = 0;
						packet.val["peng_card"] = last_card.value;
					}

					if (actions[NOTICE_HU] == 1)
					{
						if (seat.hole_cards.size() % 3 == 1)
						{
							packet.val["card"] = 0;
							packet.val["hu_card"] = hu_card;
							packet.val["players"][i]["pao_hu_card"] = hu_card;
						}
						else
						{
							packet.val["card"] = seat.hole_cards.last_card.value;
							packet.val["hu_card"] = seat.hole_cards.last_card.value;
						}
					}
				}
			}
		}
		else
		{
			if (state == BETTING)
			{
				std::vector<Card>::iterator it = seat.hole_cards.cards.begin();
				for (; it != seat.hole_cards.cards.end(); it++)
				{
					packet.val["players"][i]["holes"].append(0);
				}

				int osize = seat.hole_cards.obsorb_cards.size();
				for (int j = 0; j < osize; j++)
				{
					it = seat.hole_cards.obsorb_cards[j].begin();

					if (seat.hole_cards.obsorb_cards[j].size() == 4 && it->value == 0)
					{
						packet.val["players"][i]["obsorb_holes"][j].append(0);
						packet.val["players"][i]["obsorb_holes"][j].append(0);
						packet.val["players"][i]["obsorb_holes"][j].append(0);
						packet.val["players"][i]["obsorb_holes"][j].append(0);
						continue;
					}

					for (; it != seat.hole_cards.obsorb_cards[j].end(); it++)
					{
						packet.val["players"][i]["obsorb_holes"][j].append(it->value);
					}
				}

				std::list<Card>::iterator lit = seat.hole_cards.discard_cards.begin();

				for (; lit != seat.hole_cards.discard_cards.end(); lit++)
				{
					packet.val["players"][i]["discard_holes"].append(lit->value);
				}

				packet.val["players"][i]["ting_flag"] = seat.ting;
			}
		}

		packet.val["players"][i]["name"] = p->name;
		packet.val["players"][i]["sex"] = p->sex;
		packet.val["players"][i]["avatar"] = p->avatar;
		packet.val["players"][i]["rmb"] = p->rmb;
		packet.val["players"][i]["money"] = p->money;
		packet.val["players"][i]["ip"] = p->remote_ip;

		i++;
	}

	packet.end();
	unicast(player, packet.tostring());

	check_ip_conflict();

	zjh.game->set_in_game_flag(player, 1);
	return 0;
}


int Table::handler_ready(Player *player)
{
	if (state != READY  && state != ROOM_WAIT_GAME)
	{
		mjlog.error("handler_ready state[%d]\n", state);
		return -1;
	}

	if (seats[player->seatid].ready == 1)
	{
		mjlog.error("player[%d] have been seted for game ready\n", player->uid);
		return -1;
	}

	player->stop_offline_timer();

	ready_players++;
	seats[player->seatid].ready = 1;
	seats[player->seatid].betting = 1;

	Jpacket packet;
	packet.val["cmd"] = SERVER_READY_SUCC_BC;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = player->seatid;
	packet.end();
	broadcast(NULL, packet.tostring());
	
	mjlog.debug("handler_ready cur_players[%d], ready_players[%d]\n", cur_players, ready_players);

	if (ready_players == cur_players)
	{
		if (ready_players >= max_ready_players)
		{
			return test_game_start();
		}
	}


	return 0;
}

int Table::handler_preready()
{
	if (game_end_flag == 1)
    {
        clean_table();
        game_end_flag = 0;
        return 0;
    }

	std::map<int, Player*>::iterator it;
	for (it = players.begin(); it != players.end(); it++)
	{
		Player *player = it->second;		
		player->reset();
	}

	Jpacket packet;
	packet.val["cmd"] = SERVER_GAME_PREREADY_BC;
	for (it = players.begin(); it != players.end(); it++)
	{
		Player *player = it->second;
		packet.val["seatids"].append(player->seatid);
	}
	packet.end();
	broadcast(NULL, packet.tostring());

	ev_timer_again(zjh.loop, &ready_timer);

	return 0;
}

void Table::preready_timer_cb(struct ev_loop *loop, struct ev_timer *w,
		int revents)
{
	Table *table = (Table*) w->data;
	ev_timer_stop(zjh.loop, &table->preready_timer);
	table->handler_preready();
}

void Table::ready_timer_cb(struct ev_loop *loop, struct ev_timer *w,
		int revents)
{
	Table *table = (Table*) w->data;
	ev_timer_stop(zjh.loop, &table->ready_timer);

	table->ready_timeout();
}


int Table::ready_timeout()
{
	test_game_start();

	// if (ret != 0)
	// {
	//     ev_timer_again(zjh.loop, &ready_timer);
	// }

	return 0;  
}

void Table::start_timer_cb(struct ev_loop *loop, struct ev_timer *w, int revents)
{
	Table *table = (Table*) w->data;
	ev_timer_stop(zjh.loop, &table->start_timer);

	table->start_next_bet(0);
}

int Table::test_game_start()
{
	if (ready_players < max_ready_players)
	{
		ev_timer_stop(zjh.loop, &ready_timer);
		mjlog.debug("current ready players less than 2\n");
		return 1;
	}

	if (state != READY && state != ROOM_WAIT_GAME)
	{
		mjlog.debug("game state isn't Ready\n");
		return 2;
	}

	ev_timer_stop(zjh.loop, &ready_timer);
	/* here to start the first board */
	game_start();

	return 0;
}

int Table::game_start()
{
	ev_timer_stop(zjh.loop, &subs_timer);
	ts = time(NULL);
	state = BETTING;
	mjlog.debug("game start.\n");
	cur_flow_mode = zjh.game->flow_mode;
	mjlog.info("current flow mode is %d, tid %d.\n", cur_flow_mode, tid);

	cur_bet = base_money;
	total_bet = 0;

	deck.fill();
	deck.shuffle(tid);
	//deck.debug();

	if (round_count == 0)
    {
		round_ts = time(NULL);
        if (substitute == 1)
        {
            modify_substitute_info(1);
			zjh.game->del_subs_table(owner_uid);
        }
    }
	init_dealer();
	int ret = replay.init(ts, ttid);
    mjlog.debug("replay.init(%d, %d): %d", ts, ttid, ret);

	round_count++;

	if(round_count == 2 && max_ready_players == seat_max)
	{
		handler_redpacket();
	}

	int current_betting_seats = count_betting_seats();
	int next = next_betting_seat(dealer);

	start_seat = cur_seat = dealer;
	if (has_ghost == 2)
    {
		ghost_cards.set_value(0);
		trun_card.set_value(0);
		int ghost_time = zjh.conf["tables"]["ghost_time"].asInt();
		deck.turn_ghost(trun_card, ghost_cards, 0);
		ev_timer_set(&start_timer, START_TIME_OUT + ghost_time, START_TIME_OUT + ghost_time);
	}
	else
	{
		ev_timer_set(&start_timer, START_TIME_OUT, START_TIME_OUT);
	}
    
	for (int c = 0; c < current_betting_seats; c++)
	{
		Seat &seat = seats[next];
		Player *player = seat.player;
		if(type == 9)//做牌推到胡设置 13幺 和 四鬼胡牌
		{
			seat.hole_cards.set_shi_san_yao(thirteen_unitary_eight);
			seat.hole_cards.set_si_ghost(four_ghose_hu);
		}
		if (player == NULL)
		{
			mjlog.warn("game start player is NULL seatid[%d] tid[%d].\n", next, tid);
			continue;
		}

		//在测试环境中从redis中读取发牌时指定的牌值
		if(set_card_flag == 1)
		{
			get_set_hole_cards(player);
		}

		Jpacket packet;
		packet.val["cmd"] = SERVER_GAME_START_BC;
		packet.val["uid"] = player->uid;
		packet.val["seatid"] = player->seatid;
		packet.val["dealer"] = dealer;
		packet.val["base_money"] = base_money;
		packet.val["remain_cards"] = int(deck.cards.size());
		packet.val["cur_round"] = round_count;
		packet.val["total_round"] = max_play_board;

		//测试环境中给出测试发牌时所制定的牌值
		if(seat.set_hole_cards.size() > 0 && set_card_flag == 1)
		{
			for (unsigned int i = 0; i < seat.set_hole_cards.size(); i++)
			{
				seat.hole_cards.add_card(seat.set_hole_cards[i]);
			}

			dump_hole_cards(seat.hole_cards.cards, next, 0);
			//delet_deck_cards(seat.set_hole_cards);
		}
		else
		{
			deck.get_hole_cards(seat.hole_cards);
			dump_hole_cards(seat.hole_cards.cards, next, 0);
		}
		for (int i = 0; i < seat_max; i++)
		{
			if (seats[i].ready != 1)
			{
				continue;
			}
			packet.val["cur_seats"].append(i);
		}

		vector_to_json_array(seat.hole_cards.cards, packet, "holes");
		packet.end();
		unicast(player, packet.tostring());
		next = next_betting_seat(next);
	}

    replay.start_record.tid = ttid;
    replay.start_record.type = type;
    replay.start_record.owner_uid = owner_uid;
    replay.start_record.dealer = MBYTE(dealer);
    for (int i = 0; i < seat_max; i++)
    {
        Seat &seat = seats[i];
		if (seats[i].ready != 1){
			continue;
		}
        replay.start_record.uids[i] = seat.uid;
		snprintf(replay.start_record.name[i], sizeof(replay.start_record.name[i]), "%s", seat.player->name.c_str());
        for (int j = 0; j < seat.hole_cards.size(); j++)
        {
            replay.start_record.holes[i][j] = MBYTE(seat.hole_cards.cards[j].value);
        }
    }

    Config config;
    config.horse_num = MBYTE(horse_num);
    config.max_play_count = MBYTE(max_play_board);
    config.ping_hu_fang_pao = MBYTE(fang_pao);
    //config.one_ma_qz_flag = MBYTE(one_ma_qz_flag);
    //config.forbid_same_ip = MBYTE(forbid_same_ip);
    //config.forbid_same_place = MBYTE(forbid_same_place);
    memcpy((void*)&(replay.start_record.config), &config, sizeof(config));


	//广播高数所有玩家鬼牌是哪一张 翻得牌是哪一张

	Jpacket packet1;
	packet1.val["cmd"] = SERVER_TURN_GHOST_BC;//广播告诉房间所有玩家 鬼牌的 命令
	packet1.val["has_ghost"] = has_ghost;//0:没有鬼牌 、1:固定鬼牌 、2:翻鬼牌
	packet1.val["ghost_card"] = ghost_cards.value;//鬼牌的值
	packet1.val["trun_card"] = trun_card.value;//翻开牌的值
	packet1.val["is_throw"] = 0;
	packet1.end();
	broadcast(NULL, packet1.tostring());
  //  modify_substitute_info(1);
    ev_timer_again(zjh.loop, &start_timer);
	
	return 0;
}

int Table::count_next_bet()
{
	int _seat = next_player_seat();
	if (_seat == -1)
	{
		mjlog.error("count next bet no active player.\n");
		handler_preready();
		return -1;
	}

	cur_seat = _seat;
	start_next_bet(0);

	return 0;
}

int Table::start_next_bet(int flag)
{ 
	Seat &seat = seats[cur_seat];
	Player *player = seat.player;
	int handler = 0;
	int fetch_flag = 0;

	Jpacket packet;
	packet.val["cmd"] = SERVER_NEXT_BET_BC;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = seat.seatid;
	packet.val["money"] = player->money;
	packet.val["card"] = 0;
	packet.val["remain_cards"] = deck.size();
	packet.val["remain_time"] = BET_TIME_OUT;
	packet.val["robot_flag"] = seat.robot_flag;
	packet.val["fetch_flag"] = 0;

	reset_actions();

	// 处理托管
	if (seat.robot_flag == 1)
	{
		if (deck.permit_get() == 0)
		{
			// 结束游戏
			mjlog.debug("deck no card, liuju\n");
			game_end();
			return 0;
		}

		deck.get_next_card(seat.hole_cards);
		get_card_seat = cur_seat;
		packet.val["card"] = seat.hole_cards.last_card.value;
		packet.val["remain_cards"] = deck.size();
		packet.val["fetch_flag"] = 1;
		fetch_flag = 1;
		handler = 1;    
	}

	if (gang_hu_count > 1 || pao_hu_count > 1)
	{
		mjlog.debug("gang_hu_count %d, pao_hu_count %d\n", gang_hu_count, pao_hu_count);

		for (int i = 0; i < seat_max; i++)
		{
			Seat &tseat = seats[i];
			if (tseat.pao_hu_flag == 1)
			{
				handler_recored_hu(hu_card, i, pao_hu_seat);
			}

			if (tseat.gang_hu_flag == 1)
			{
				handler_recored_hu(hu_card, i, gang_hu_seat);
			}
		}
		game_end();
		return 0;
	}

	// 处理抢杠胡
	if (last_action == PLAYER_GANG && gang_hu_seat >= 0 && handler == 0 && gang_hu_seat != cur_seat)
	{
		if (seat.hole_cards.permit_hu(last_gang_card.value))
		{
			actions[NOTICE_HU] = 1;
			actions[NOTICE_GUO] = 1;

			//hu_card = last_gang_card.value;
			packet.val["hu_card"] = last_gang_card.value;
			handler = 1;
		}
	}

	if ((last_action == PLAYER_CHU || last_action == PLAYER_GUO) && handler == 0 && seat.handler_flag == 0)
	{
		mjlog.debug("start_next_bet last_action is player_chu\n");

		if (seat.ting != 1)
		{
			mjlog.debug("start_next_bet last_action is player_chu, not hu card\n");

			// 没牌摸了，不允许杠
			if (seat.hole_cards.permit_gang(last_card.value) && deck.permit_get() == 1) 
			{
				mjlog.debug("start_next_bet last_action permit gang\n");
				actions[NOTICE_GANG] = 1;
				actions[NOTICE_GUO] = 1;
				packet.val["gang_card"] = last_card.value;
				handler = 1;
			}

			if (seat.hole_cards.permit_peng(last_card.value))
			{
				actions[NOTICE_PENG] = 1;
				packet.val["peng_card"] = last_card.value;
				actions[NOTICE_GUO] = 1;
				mjlog.debug("start_next_bet last_action permit peng\n");
				handler = 1;
			}
		}
	}

	if (handler == 0)
	{
		

		// 吃和碰的时候不需要抓牌
		if (seat.hole_cards.size() % 3 == 1)
		{
			if (deck.permit_get() == 0)
			{
				// 结束游戏
				mjlog.debug("deck no card, liuju\n");
				game_end();
				return 0;
			}

			if (set_card_flag == 1 && seat.need_card > 0)
			{
				deck.get_next_card(seat.hole_cards, seat.need_card);
				seat.need_card = 0;
			}
			else
			{
				deck.get_next_card(seat.hole_cards);
			}

			handler_recored_mo(seat.hole_cards.last_card.value, seat.seatid, -1);
			seat.guo_hu_cards.clear();
			dump_hole_cards(seat.hole_cards.cards, cur_seat, 4);

			get_card_seat = cur_seat;
			packet.val["card"] = seat.hole_cards.last_card.value;
			packet.val["remain_cards"] = deck.size();
			packet.val["fetch_flag"] = 1;
			fetch_flag = 1;
		}
		else
		{
			seat.hole_cards.last_card.set_value(0);
		}

		seat.hole_cards.analysis();

		mjlog.debug("start_next_bet last_action get next card[%d]\n", seat.hole_cards.last_card.value);

		if (seat.hole_cards.permit_hu() && last_action != PLAYER_PENG)
		{
			actions[NOTICE_HU] = 1;
			actions[NOTICE_GUO] = 1;
			packet.val["hu_card"] = seat.hole_cards.last_card.value;
			seat.hu = 1;
		}

		if (seat.hole_cards.permit_gang() && handler == 0 && last_action != PLAYER_PENG)	
		{
			actions[NOTICE_GANG] = 1;
			actions[NOTICE_GUO] = 1;
		}
	}

	for (int i = 0; i < NOTICE_SIZE; i++)
	{
		packet.val["action"].append(actions[i]);
	}

	if (actions[NOTICE_GANG] == 1)
	{
		packet.val["gang_flag"] = seat.hole_cards.gang_flags.back();
		vector_to_json_array(seat.hole_cards.gang_cards, packet, "gang_cards");
		for (unsigned int i = 0; i < seat.hole_cards.gang_flags.size(); i++)
		{
			packet.val["gang_flags"].append(seat.hole_cards.gang_flags[i]);
		}
	}

	if (actions[NOTICE_TING] == 1)
	{       
		int index = 0;
		std::map<int, vector<Card> >::iterator it = seat.hole_cards.ting_cards.begin();
		for (; it != seat.hole_cards.ting_cards.end(); it++)
		{
			packet.val["ting_cards"].append(it->first);
			int size = it->second.size();
			for (int i = 0; i < size; i++)
			{
				packet.val["ting_pattern"][index].append(it->second[i].value);
			}
			index++;
		}  
	}

	packet.end();
	unicast(seat.player, packet.tostring());

	Jpacket packet1;
	packet1.val["cmd"] = SERVER_NEXT_BET_BC;
	packet1.val["uid"] = player->uid;
	packet1.val["seatid"] = seat.seatid;
	packet1.val["remain_time"] = BET_TIME_OUT;
	packet1.val["remain_cards"] = deck.size();
	packet1.val["fetch_flag"] = fetch_flag;
	packet1.val["robot_flag"] = seat.robot_flag;
	if (actions[NOTICE_GANG] == 1)
	{
		packet1.val["gang_flag"] = seat.hole_cards.gang_flag;
	}   
	packet1.end();
	broadcast(seat.player, packet1.tostring());

    if (actions[NOTICE_CHI] == 1 || actions[NOTICE_PENG] == 1 || actions[NOTICE_GANG] == 1 || 
            actions[NOTICE_HU] == 1 || actions[NOTICE_GUO] ==1 )
    {
        handler_record_notice(cur_seat);
    }

	if (seat.robot_flag == 1 || (seat.ting == 1 && actions[NOTICE_HU] != 1))
	{
		ev_timer_set(&bet_timer, 2, 2);
		ev_timer_again(zjh.loop, &bet_timer);
	}
	else
	{
		ev_timer_set(&bet_timer, BET_TIME_OUT, BET_TIME_OUT);
		ev_timer_again(zjh.loop, &bet_timer);
	}

	return 0;
}

void Table::bet_timer_cb(struct ev_loop *loop, struct ev_timer *w, int revents)
{
	Table *table = (Table*) w->data;
	ev_timer_stop(zjh.loop, &table->bet_timer);
	mjlog.debug("bet_timer_cb\n");
	table->bet_timeout();
}

void Table::compare_timer_cb(struct ev_loop *loop, struct ev_timer *w,
		int revents)
{
	Table *table = (Table*) w->data;
	ev_timer_stop(zjh.loop, &table->compare_timer);
	mjlog.debug("compare_timer_cb\n");
	table->compare_timeout();
}

int Table::handler_bet(Player *player)
{
	int ret;
	Json::Value &val = player->client->packet.tojson();
	int action = val["action"].asInt();

	if (state != BETTING)
	{
		mjlog.error("handler_bet state is not betting[%d]\n", state);
		handler_bet_error(player, action);
		return -1;
	}

	Seat &seat = seats[player->seatid];
	if (seat.player != player)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_bet player is no match with seat.player\n");
		return -1;
	}

	//player->noplay_count = 0;

	if (cur_seat != player->seatid && (action != PLAYER_TUOGUAN) && (action != PLAYER_CANCEL_TUOGUAN))
	{
		mjlog.error("handler_bet player->seatid[%d] cur_seat[%d]\n",
				player->seatid, cur_seat);
		return -1;
	}

	if (action == PLAYER_GUO)
	{
		ret = handler_guo(player);
		if (ret < 0)
		{
			return -1;
		}
		return 0;
	}

	/*if (action == PLAYER_CHI){
	  ret = handler_chi(player);
	  if (ret < 0){
	  return -1;
	  }
	  start_next_bet(0);
	  return 0;
	  }*/

	if (action == PLAYER_CHU)
	{
		ret = handler_chu(player);
		if (ret < 0)
		{
			return -1;
		}
		ev_timer_stop(zjh.loop, &bet_timer);
		count_next_bet();
		return 0;
	}
	else if (action == PLAYER_PENG)
	{
		ret = handler_peng(player);
		if (ret < 0)
		{
			return -1;
		}

		start_next_bet(0);
		return 0;
	}
	else if (action == PLAYER_GANG)
	{
		ret = handler_gang(player);
		if (ret < 0)
		{
			return -1;
		}

		ev_timer_stop(zjh.loop, &bet_timer);
		ev_timer_again(zjh.loop, &bet_timer);
		count_next_bet();

		return 0;
	}
	else if (action == PLAYER_HU)
	{
		ret = handler_hu(player);
		if (ret < 0)
		{
			return -1;
		}
		ev_timer_stop(zjh.loop, &bet_timer);
		mjlog.debug("player[%d] req hu card\n", player->uid);
		game_end();

		return 0;
	}
	else if (action == PLAYER_TING)
	{
		ret = handler_ting(player);
		if (ret < 0)
		{
			return -1;
		}
		ev_timer_stop(zjh.loop, &bet_timer);
		count_next_bet();
		return 0;
	}
	else if (action == PLAYER_CANCEL)
	{
		ret = handler_cancel(player);
		if (ret < 0)
		{
			return -1;
		}
		ev_timer_stop(zjh.loop, &bet_timer);
		return 0;
	}
	else if (action == PLAYER_JIABEI)
	{
		ret = handler_jiabei(player);
		if (ret < 0)
		{
			return -1;
		}

		if (seat.hole_cards.size() % 3 != 2)
		{
			ev_timer_stop(zjh.loop, &bet_timer);
			start_next_bet(0);
		}
		else
		{
			//start_next_bet(0);
		}
		return 0;
	}

	return 0;
}

void Table::bet_timeout()
{

}

void Table::compare_timeout()
{
	if (state != BETTING)
	{
		mjlog.error("compare timeout state[%d] is not BETTING.\n", state);
		return;
	}
	int ret = test_game_end();
	if (ret < 0)
	{
		count_next_bet();
	}
}

void Table::lose_update(Player *player)
{
	Seat &seat = seats[player->seatid];

	player->incr_money(1, seat.bet);
	player->incr_total_board(vid, 1);
	mjlog.debug("lose_update total_board [%d] pre_uid[%d] \n",player->total_board ,player->pre_uid);
	if ( player->pre_uid > 1000)
	{
		handler_invite_advantage(player);
	}
}

void Table::win_update(Player *player)
{
	Seat &seat = seats[player->seatid];

	player->incr_money(0, seat.bet);
	player->incr_total_board(vid, 1);
	mjlog.debug("win_update total_board [%d] pre_uid[%d] \n",player->total_board ,player->pre_uid);
	if (player->pre_uid > 1000)
	{
		handler_invite_advantage(player);
	}
}

void Table::update_money(Player *player, int value)
{
	if (cur_flow_mode != FLOW_IMMEDIATE)
	{
		return;
	}
	player->incr_money(1, value);
}

int Table::test_game_end()
{
	int betting_players = count_betting_seats();
	if (betting_players == 1)
	{
		for (int i = 0; i < seat_max; i++)
		{
			if (seats[i].betting == 1)
			{
				win_seatid = i;
				break;
			}
		}

		mjlog.debug("bet player only one, game end\n");
		game_end();
		return 0;
	}

	return -1;
}

int Table::game_end(int flag)
{
	mjlog.debug("game_end[%d]\n", start_seat);
	ev_timer_stop(zjh.loop, &bet_timer);
	ev_timer_stop(zjh.loop, &start_timer);
	ev_timer_stop(zjh.loop, &compare_timer);

	state = END_GAME;
	
	if (players.size() == 0)
	{
		mjlog.debug("game_end player size 0\n");
		return 0;
    }	

    accumulate_hu();

	//replay.save();

	Jpacket packet;
	packet.val["cmd"] = SERVER_GAME_END_BC;
	packet.val["win_seatid"] = win_seatid;
	packet.val["total_bet"] = total_bet;
	packet.val["cur_round"] = round_count;

	if (pao_hu_seat >= 0)
	{
		packet.val["fang_pao_seat"] = pao_hu_seat;
	}
	else if (gang_hu_seat >= 0)
	{
		packet.val["fang_pao_seat"] = gang_hu_seat;
	}
	else
	{
		packet.val["fang_pao_seat"] = -1;
	}
	//多人抢杠胡 直接结束 牌局
	if (gang_hu_seat > -1)
    {
		seats[gang_hu_seat].gang_count[last_gang_flag] -= 1;

		if (last_gang_flag == 0)
        {
			seats[chu_seat].fang_gang_count -= 1;
		}
	}
	vector_to_json_array(deck.horse_cards, packet, "horse_cards");

	if (win_seatid < 0 && gang_hu_count < 2 && pao_hu_count < 2)
	{
		win_bet = 0;
		packet.val["is_liuju"] = 1;

		int size = deck.horse_cards.size();
		for (int i = 0; i < size; i++)
		{
			packet.val["zhong_horse"].append(0);
		}

		update_account_bet();

		for (int i = 0; i < seat_max; i++)
		{
			if (seats[i].occupied == 0)
			{
				continue;
			}
			mjlog.debug("seatid [%d] bet[%d]\n",i, seats[i].bet);
			if (seats[i].bet > 0)
			{
				win_update(seats[i].player);
			}
			else
			{
				lose_update(seats[i].player);
			}
		}
		// 记录结果
		insert_flow_record();
	}
	else
	{
		packet.val["is_liuju"] = 0; 
		update_account_bet();

		// 记录结果
		insert_flow_record();

		int size = zhong_horse.size();
		for (int i = 0; i < size; i++)
		{
			packet.val["zhong_horse"].append(zhong_horse[i]);
		}

		for (int i = 0; i < seat_max; i++)
		{
			if(seats[i].ready != 1){
				continue;
			}

			if (seats[i].bet > 0)
			{
				win_update(seats[i].player);
			}
			else
			{
				lose_update(seats[i].player);
			}
		}
	}

    packet.val["tian_hu_flag"] = tian_hu_flag; //天胡
    packet.val["di_hu_flag"] = di_hu_flag; //地胡
    packet.val["hai_di_hu_flag"] = hai_di_hu_flag; //海底胡
    packet.val["gang_shang_hua_flag"] = gang_shang_hua_flag; //杠上花
    packet.val["gang_shang_pao"] = gang_shang_pao; //杠上炮

	int j = 0;
	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].occupied == 1)
		{
			Player *player = seats[i].player;
			if (player)
			{
				packet.val["players"][j]["seatid"] = player->seatid;
				packet.val["players"][j]["uid"] = player->uid;
				packet.val["players"][j]["name"] = player->name;
				packet.val["players"][j]["rmb"] = player->rmb;
				packet.val["players"][j]["money"] = player->money;
				packet.val["players"][j]["total_board"] = player->total_board;
				packet.val["players"][j]["pay_total"] = player->pay_total;
				packet.val["players"][j]["gang_hu_flag"] = seats[i].gang_hu_flag;
				packet.val["players"][j]["horse_count"] = seats[i].horse_count;
				packet.val["players"][j]["pao_hu_flag"] = seats[i].pao_hu_flag;
				packet.val["players"][j]["forbid_hu"] = seats[i].forbid_hu;
				packet.val["players"][j]["fang_gang_count"] = seats[i].fang_gang_count;
				for (int k = 0; k < 4; k++)
				{
					packet.val["players"][j]["gang_count"].append(seats[i].gang_count[k]);
				}

                if (seats[i].horse_cards.size() > 0)
                {
                    handler_record_horse(i);
                    vector_to_json_array(seats[i].horse_cards, packet.val["players"][j], "horse_cards");
                    vector_to_json_array(seats[i].zhong_horse, packet.val["players"][j], "zhong_horse");
                    packet.val["players"][j]["display_horse"] = 1;
                }
                else
                {
                    vector_to_json_array(deck.horse_cards, packet.val["players"][j], "horse_cards");
                    for (unsigned int z = 0; z < deck.horse_cards.size(); z++)
                    {
                        packet.val["players"][j]["zhong_horse"].append(0);
                    }
                    packet.val["players"][j]["display_horse"] = 0;
                }            

                for (unsigned int z = 0; z < seats[i].obsorb_seats.size(); z++)
                {
                    packet.val["players"][j]["obsorb_seats"].append(seats[i].obsorb_seats[z]);
                }

				if (seats[i].seatid == win_seatid)
				{
					packet.val["players"][j]["card_type"] = seats[i].card_type;
					packet.val["players"][j]["gang_hu_flag"] = seats[i].gang_hu_flag;
					packet.val["players"][j]["pao_hu_flag"] = seats[i].pao_hu_flag;
					packet.val["players"][j]["win"] = 1;
					std::ostringstream oss;
                    string desc = format_card_desc(seats[i].card_type);
					if (has_steadily_high > 0 && seats[i].always_dealer_count > 1)
					{
						oss<<"节节高"<<seats[i].always_dealer_count -1<<"次，";
					}
					if (follow_dealer == 1  && follow_dealer_count > 0)
					{
						oss<<"跟庄，";
					}
					oss << desc;
                    packet.val["players"][j]["card_desc"] = oss.str().c_str();
					
					for (unsigned int k = 0; k < seats[i].hole_cards.oldcards.size(); k++)
					{
						packet.val["players"][j]["holes"].append(seats[i].hole_cards.oldcards[k].value);
					}

					if (seats[i].hole_cards.cards.size() % 3 != 2)
					{
						packet.val["players"][j]["holes"].append(hu_card);
					}

					std::vector<Card>::iterator vit;
					int osize = seats[i].hole_cards.obsorb_cards.size();
					for (int z = 0; z < osize; z++)
					{
						vit = seats[i].hole_cards.obsorb_cards[z].begin();
						for (; vit != seats[i].hole_cards.obsorb_cards[z].end(); vit++)
						{
							packet.val["players"][j]["obsorb_holes"][z].append(vit->value);
						}
					}
					packet.val["players"][j]["bet"] = seats[i].bet;
				}
				else
				{
					
					if ((seats[i].gang_hu_flag == 1 && gang_hu_count > 1) || (seats[i].pao_hu_flag == 1 && pao_hu_count > 1))
					{
						packet.val["players"][j]["card_type"] = seats[i].card_type;
						std::ostringstream oss;
						string desc = format_card_desc(seats[i].card_type);
						if (has_steadily_high > 0 && seats[i].always_dealer_count > 1)
						{
							oss<<"节节高"<<seats[i].always_dealer_count -1<<"次，";
						}
						if (follow_dealer == 1  && follow_dealer_count > 0)
						{
							oss<<"跟庄，";
						}
						oss << desc;
						packet.val["players"][j]["card_desc"] = oss.str().c_str();
						packet.val["players"][j]["win"] = 1;
						packet.val["players"][j]["gang_hu_flag"] = seats[i].gang_hu_flag;
						packet.val["players"][j]["pao_hu_flag"] = seats[i].pao_hu_flag;
					}
					else
					{
						packet.val["players"][j]["card_type"] = 0;
						packet.val["players"][j]["card_desc"] = "";
						packet.val["players"][j]["win"] = 0;
						packet.val["players"][j]["gang_hu_flag"] = 0;
						packet.val["players"][j]["pao_hu_flag"] = 0;
					}

					for (unsigned int k = 0; k < seats[i].hole_cards.oldcards.size(); k++)
					{
						packet.val["players"][j]["holes"].append(seats[i].hole_cards.oldcards[k].value);
					}

					if ((seats[i].gang_hu_flag == 1 && gang_hu_count > 1) || (seats[i].pao_hu_flag == 1 && pao_hu_count > 1))
					{
						packet.val["players"][j]["holes"].append(hu_card);
					}

					std::vector<Card>::iterator vit;
					int osize = seats[i].hole_cards.obsorb_cards.size();
					for (int z = 0; z < osize; z++)
					{
						vit = seats[i].hole_cards.obsorb_cards[z].begin();
						for (; vit != seats[i].hole_cards.obsorb_cards[z].end(); vit++)
						{
							packet.val["players"][j]["obsorb_holes"][z].append(vit->value);
						}
					}
					packet.val["players"][j]["bet"] = seats[i].bet;
				}
				j++;
			}
		}
	}

	int init_money = zjh.conf["tables"]["init_money"].asInt();
	packet.val["flag"] = 0;
	packet.val["owner_uid"] = owner_uid;

	if (flag == 1 || round_count >= max_play_board || zjh.game->terminal_flag == 1)
	{
		packet.val["flag"] = 1;
		j = 0;
		for (int i = 0; i < seat_max; i++) {
			if (seats[i].occupied == 1) {
				Player *player = seats[i].player;
                Seat &seat = seats[i];
				if (player) {
					packet.val["players1"][j]["seatid"] = player->seatid;
					packet.val["players1"][j]["uid"] = player->uid;
					packet.val["players1"][j]["name"] = player->name;
					packet.val["players1"][j]["rmb"] = player->rmb;
					packet.val["players1"][j]["money"] = player->money;
					packet.val["players1"][j]["bet"] = player->money - init_money;
					packet.val["players1"][j]["avatar"] = player->avatar;
					packet.val["players1"][j]["ip"] = player->remote_ip;

                    const char* record_desc[] = {"自摸次数", "接炮次数", "点炮次数", "暗杠次数", "明杠次数"};
                    for (int z = 0; z < 5; z++)
                    {
                        packet.val["players1"][j]["total_record_desc"].append(record_desc[z]);
                    }

                    packet.val["players1"][j]["total_record"].append(seat.total_zimo);
                    packet.val["players1"][j]["total_record"].append(seat.total_jie_pao);
                    packet.val["players1"][j]["total_record"].append(seat.total_fang_pao);
                    packet.val["players1"][j]["total_record"].append(seat.total_an_gang);
                    packet.val["players1"][j]["total_record"].append(seat.total_ming_gang);
					j++;
				}
			}
		}
        insert_flow_round_record();
        game_end_flag = 1;
	}
	packet.end();
	broadcast(NULL, packet.tostring());
	replay.record_write();
	replay.save(ts,ttid);

    for (int i = 0; i < seat_max; i++)
	{
		seats[i].reset();
    }

    reset();

	ev_timer_again(zjh.loop, &preready_timer);

	return 0;
}

int Table::handler_fold(Player *player)
{
	Seat &seat = seats[player->seatid];

	if (seat.betting == 0)
	{
		mjlog.error("handler_fold seat betting[0] uid[%d] tid[%d].\n",
				player->uid, tid);
		return -1;
	}

	//lose_update(seat.player);
	seat.betting = 0;

	return 0;
}

int Table::handler_logout(Player *player)
{
	Jpacket packet;
	packet.val["cmd"] = SERVER_LOGOUT_SUCC_BC;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = player->seatid;
	packet.val["type"] = player->logout_type;
	packet.end();
	broadcast(NULL, packet.tostring());

	return 0;
}

int Table::handler_chat(Player *player)
{
	Json::Value &val = player->client->packet.tojson();

	Jpacket packet;
	packet.val["cmd"] = SERVER_CHAT_BC;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = player->seatid;
	packet.val["text"] = val["text"];
	packet.val["chatid"] = val["chatid"];
	packet.val["sex"] = player->sex;
	packet.end();
	broadcast(NULL, packet.tostring());

	//player->noplay_count = 0;
	return 0;
}

int Table::handler_face(Player *player)
{
	Json::Value &val = player->client->packet.tojson();

	Jpacket packet;
	packet.val["cmd"] = SERVER_FACE_BC;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = player->seatid;
	packet.val["faceid"] = val["faceid"];
	packet.end();
	broadcast(NULL, packet.tostring());

	//player->noplay_count = 0;

	return 0;
}

int Table::handler_interFace(Player *player)
{
	Json::Value &val = player->client->packet.tojson();

	Jpacket packet;
	packet.val["cmd"] = SERVER_INTERFACE_BC;
	packet.val["uid"] = player->uid;
	packet.val["fromid"] = player->seatid;
	packet.val["toid"] = val["toid"];
	packet.val["faceid"] = val["faceid"];
	packet.end();
	broadcast(NULL, packet.tostring());

	//player->noplay_count = 0;
	return 0;
}

int Table::handler_player_info(Player *player)
{
	int ret = 0;
	//player->noplay_count = 0;
	ret = player->update_info();
	if (ret < 0)
	{
		mjlog.error("handler_player_info update_info error.\n");
		return -1;
	}

	if (state == BETTING)
	{
		Seat &seat = seats[player->seatid];
		if (seat.betting == 1)
		{
			player->money -= seat.bet;
			mjlog.info("handler_player_info o uid[%d] money[%d] bet[%d].\n",
					player->uid, player->money, seat.bet);
		}
	}

	Jpacket packet;
	packet.val["cmd"] = SERVER_PLAYER_INFO_BC;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = player->seatid;
	packet.val["money"] = player->money;
	packet.val["rmb"] = player->rmb;
	packet.val["total_board"] = player->total_board;

	packet.end();
	broadcast(NULL, packet.tostring());

	mjlog.info("handler_player_info uid[%d] seatid[%d] money[%d] tid[%d].\n",
			player->uid, player->seatid, player->money, tid);

	return 0;
}

int Table::handler_prop(Player *player)
{
	Json::Value &val = player->client->packet.tojson();
	int action = val["action"].asInt();

	if (type != 0)
	{
		mjlog.error("handler_prop error uid[%d] money[%d] is not in prop\n",
				player->uid, player->money);
		return 0;
	}

	if (state != BETTING)
	{
		mjlog.error("handler_prop state[%d] is not betting tid[%d]\n", state,
				tid);
		return -1;
	}

	Seat &seat = seats[player->seatid];
	if (seat.player != player)
	{
		mjlog.error("handler_prop player is no match with seat.player\n");
		return -1;
	}

	mjlog.info("handler_prop succ. uid[%d] seatid[%d] action[%d] tid[%d].\n",
			player->uid, player->seatid, action, tid);
	return 0;
}

void Table::handler_prop_error(Player *player, int action)
{
	Jpacket packet;
	packet.val["cmd"] = SERVER_PROP_ERR_UC;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
	packet.end();
	unicast(player, packet.tostring());
}

void Table::handler_bet_error(Player *player, int action)
{
	Jpacket packet;
	packet.val["cmd"] = SERVER_BET_ERR_UC;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
	packet.val["chu_seat"] = chu_seat;

    Seat &seat = seats[player->seatid];

    vector_to_json_array(seat.hole_cards.cards, packet, "holes");

    std::list<Card>::iterator lit = seat.hole_cards.discard_cards.begin();
    for (; lit != seat.hole_cards.discard_cards.end(); lit++)
    {
        packet.val["discard_holes"].append(lit->value);
    }      

	packet.end();
	unicast(player, packet.tostring());
}

int Table::next_betting_seat(int pos)
{
	int cur = pos;

	for (int i = 0; i < seat_max; i++)
	{
		cur++;
		if (cur >= seat_max)
			cur = 0;

		if (seats[cur].betting == 1)
		{
			mjlog.debug("cur is betting seat[%d]\n", cur);
			return cur;
		}
	}

	mjlog.error("error active player\n");

	return -1;
}

int Table::next_player_seat()
{
	int first_hu_seat = -1;
	pao_hu_count = 0;
	gang_hu_count = 0;

	if (last_action == PLAYER_CHU)
    { 
        for (int i = 1; i < seat_max; i++)
        {
            int next = (cur_seat + i) % seat_max;
            if (seats[next].ready != 1)
            {
                continue;
            }

            if (seats[next].hole_cards.permit_peng(last_card.value)
                || seats[next].hole_cards.permit_gang(last_card.value))
            {
                mjlog.debug("cur_seat[%d], next peng gang seat[%d]\n", cur_seat, next);
                return next;
            }
        }
    }

	//检测玩家其他玩家是否可以抢杠胡
	if (last_action == PLAYER_GANG)
	{
		if ((seats[cur_seat].hole_cards.gang_flag == 0 && has_rob_ming_gang == 1)
            || (seats[cur_seat].hole_cards.gang_flag == 1 && has_rob_gang_hu == 1))
		{
			for (int i = 1; i < seat_max; i++)
			{
				int next = (cur_seat + i) % seat_max;
                if (seats[next].ready != 1)
                {
                    continue;
                }

                if (seats[next].hole_cards.permit_hu(last_gang_card.value))
                {
                    // 抢杠胡
                    mjlog.debug("cur_seat[%d], next hu seat[%d]\n", cur_seat, next);
                    
                    if (first_hu_seat == -1)
                    {
                        first_hu_seat = next;
                    }

                    hu_card = last_gang_card.value;
                    seats[next].gang_hu_flag = 1;
                    gang_hu_count++;
                }
			}
		}

        if (first_hu_seat >= 0)
        {
            gang_hu_seat = cur_seat;
            return first_hu_seat;
        }
        else
        {
            return cur_seat;
        }
	}

	if (last_action == PLAYER_GUO)
	{
		if (wait_handle_action == PLAYER_CHU)
        {
            for (int i = 1; i < seat_max; i++)
            {
                int next = (cur_seat + i) % seat_max;

                if (seats[next].ready != 1)
                {
                    continue;
                }
				
                if (seats[next].handler_flag == 1 || next == wait_handler_seat)
                {
                    continue;
                }

                if (seats[next].hole_cards.permit_peng(last_card.value)
                    || seats[next].hole_cards.permit_gang(last_card.value))
                {
                    mjlog.debug("cur_seat[%d], next peng gang seat[%d]\n", cur_seat, next);
                    return next;
                }
            }

            int seatid = next_betting_seat(wait_handler_seat);
            if (seatid >= 0)
            {
                mjlog.debug("guo pai, cur_seat[%d], next play seat[%d]\n", cur_seat, seatid);
                return seatid;
            }
            else
            {
                mjlog.error("guo pai error next player\n");
                return -1;
            }
        }
        else if (wait_handle_action == PLAYER_GANG)
        {
            return wait_handler_seat;
        }
	}

	int seatid = next_betting_seat(cur_seat);
	if (seatid >= 0)
	{
		mjlog.debug("cur_seat[%d], next play seat[%d]\n", cur_seat, seatid);
		return seatid;
	}
	else
	{
		mjlog.error("error next player\n");
		return -1;
	}
}

int Table::prev_betting_seat(int pos)
{
	int cur = pos;

	for (int i = 0; i < seat_max; i++)
	{
		cur--;
		if (cur < 0)
			cur = seat_max - 1;

		if (seats[cur].betting == 1)
		{
			mjlog.debug("cur is betting seat[%d]\n", cur);
			return cur;
		}
	}

	mjlog.error("error active player\n");

	return -1;
}

int Table::count_betting_seats()
{
	int count = 0;

	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].betting == 1)
		{
			count++;
		}
	}

	return count;
}

int Table::get_last_betting()
{
	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].betting == 1)
		{
			return i;
		}
	}

	return -1;
}

/*  type: 1、钻石 2、金币 3、踢人卡 4、换牌 5、禁比卡 6、四倍卡 7、八倍卡 8、座驾 9、兑换券
flag: 1、加 0、减
pos: 51、转转乐 52、摇摇乐
60、充值-购买钻石  61、钻石兑换金币 62、钻石兑换道具 63、钻石购买座驾 65、奖券兑换奖品
70、注册 71、登录领奖 72、破产领取 73、参拜财神 74、充值抽奖 75、领取邮件礼物 76、发送邮件礼物
77、玩N局奖励  78、领取任务奖励
*/
int Table::insert_flow_log(int ts, int uid, string ip, int pos, int vid, int zid, int tid, int type, int flag, int num, int anum)
{
	Jpacket packet;
    packet.val["roomid"] = ttid;
    packet.val["masterid"] = owner_uid;

    int index = 0;
    for (int i = 0; i < seat_max; i++)
    {
        Player* player = seats[i].player;

        int occ = 1;
        if (player == NULL)
        {
            occ = 0;
        }
        else if (player->uid == owner_uid)
        {
            continue;
        }

        switch (index)
        {
        case 0:
            packet.val["player1"] = occ == 1 ? player->uid : 0;
            break;
        case 1:
            packet.val["player2"] = occ == 1 ? player->uid : 0;
            break;
        case 2:
            packet.val["player3"] = occ == 1 ? player->uid : 0;
            break;
        default:
            break;
        }

        index++;
    }

    packet.val["rmb"] = num;
    packet.val["vid"] = type;
    packet.val["ts"] = (int)time(NULL);

    string str = packet.val.toStyledString().c_str();
    int ret = zjh.temp_rc->command("LPUSH rmb_flow_list %s", str.c_str());

    if (ret < 0)
    {
        mjlog.error("insert rmb_flow_record %s", str.c_str());
        return - 1;
    }
	return 0;
}


int Table::handler_send_gift_req(Player *player)
{ 
	return 0;
}

void Table::send_result_to_robot()
{

}

void Table::init_dealer()
{
	// 第一轮庄家做主
	if (round_count == 0)
	{
		int owner_flag = 0;
		for (int i = 0; i < seat_max; i++)
		{
			if(seats[i].ready == 0)
			{
				continue;
			}
			if (seats[i].uid == owner_uid)
			{
				owner_flag = 1;
				dealer = i;
				return;
			}
		}
		if (substitute == 1 && owner_flag == 0)
		{
			std::vector<int> tmp;
			for (int i = 0; i < seat_max; i++)
			{
				if (seats[i].occupied == 1)
				{
					tmp.push_back(i);
				}
			}

			int len = tmp.size();
			if (len > 0)
			{
				int index = random(0, len - 1);
				dealer = tmp[index];
				
				return ;
			}
		}
	}
	//抢杠胡多人胡了
	if(gang_hu_seat > -1 && gang_hu_count > 1)
	{
		dealer = gang_hu_seat;
		return;
	}

	if(pao_hu_seat > -1 && pao_hu_count > 1)
	{
		dealer = pao_hu_seat;
		return ;
	}

 // 后续谁胡谁做庄
    if (hu_seat >= 0)
    {
        dealer = hu_seat;
        hu_seat = -1;
        return;
    }

	// 荒庄摸最后一张的玩家做庄
	if (get_card_seat >= 0)
	{

		return;
	}
}

int Table::handler_chi(Player* player)
{
	Json::Value &val = player->client->packet.tojson();
	Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();
	int card = val["card"].asInt();
	int pattern[3] = {0, };
	int size = val["pattern"].size();

	for (int index = 0; index < size; index++)
	{
		pattern[index] = val["pattern"][index].asInt();
	}

	if (seat.betting == 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_chi error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (last_action != PLAYER_CHU && last_action != PLAYER_GUO)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_chi action  error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (last_card.value != card)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_chi value  error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (actions[NOTICE_CHI] != 1)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_chi notice error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	last_action = PLAYER_CHI;
	last_action_seatid = player->seatid;

	seat.hole_cards.handler_chi(card, pattern, 0);
	seats[chu_seat].hole_cards.handler_chi(card, pattern, 1);

	handler_recored_chi(card, pattern, seat.seatid, chu_seat);

	dump_hole_cards(seat.hole_cards.cards, cur_seat, 1);

    chi_count++;
    seat.last_actions[1] = seat.last_actions[0];
	seat.last_actions[0] = action;
	seat.obsorb_seats.push_back(chu_seat);

	Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
	packet.val["card"] = card;
	packet.val["pattern"] = val["pattern"];
	packet.val["chu_seat"] = chu_seat;
	vector_to_json_array(seat.hole_cards.cards, packet, "holes");
	packet.end();
	unicast(player, packet.tostring());

	Jpacket packet1;
	packet1.val["cmd"] = SERVER_BET_SUCC_BC;
	packet1.val["seatid"] = player->seatid;
	packet1.val["uid"] = player->uid;
	packet1.val["action"] = action;
	packet1.val["card"] = card;
	packet1.val["pattern"] = val["pattern"];
	packet1.val["chu_seat"] = chu_seat;
	size = seat.hole_cards.cards.size();
	for (int i = 0; i < size; i++)
	{
		packet1.val["holes"].append(0);
	}
	packet1.end();
	broadcast(player, packet1.tostring());

	if (seats[chu_seat].player){
		handler_play_procedure(cur_seat, chu_seat, card, 1);
	}
	return 0;
}

int Table::handler_chu(Player* player)
{
	Json::Value &val = player->client->packet.tojson();
	Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();
	int card  = val["card"].asInt();

	if (seat.betting == 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_chu error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (!seat.hole_cards.has_card(card))
	{
		handler_bet_error(player, action);
		mjlog.error("handler_chu card error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (seat.ting == 1 &&  card != seat.hole_cards.last_card.value)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_chu card error, because has ting. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (seat.robot_flag == 1)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_chu card error, because has robot flag. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (cur_seat != player->seatid)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_chu seat error, because has robot flag. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (seat.hole_cards.cards.size() % 3 != 2)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_chu card size error, because has robot flag. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if( player->seatid ==  dealer)
	{
		dealer_card.set_value(card);
		count_card = 1;
	}
	else
	{
		if (player->seatid == (dealer + count_card) % seat_max && dealer_card.value == card) 
		{
			count_card++;
		}
		else
		{
			count_card = 0;
			dealer_card.set_value(0);
		}
	}
	if(count_card == seat_max)
	{
		follow_dealer_count++;
		count_card = 0;
	}
	last_action = PLAYER_CHU;
	last_action_seatid = player->seatid;
	last_card.set_value(card);
	chu_seat = seat.seatid;

	seat.hole_cards.handler_chu(card);
	seat.timeout_count = 0;

	handler_record_chu(card, seat.seatid);
	dump_hole_cards(seat.hole_cards.cards, cur_seat, 5);
	// 测试可否胡牌
	// seat.hole_cards.analysis();
    seat.last_actions[1] = seat.last_actions[0];
    seat.last_actions[0] = action;

	int pg_flag = 0;
	for (int i = 0; i < seat_max; i++)
	{
		if (i == player->seatid)
		{
			continue;
		}

		if (seats[i].hole_cards.permit_peng(card)
		  || seats[i].hole_cards.permit_gang(card))
		{
			pg_flag = 1;
			mjlog.debug("next peng gang seat is seat[%d]\n", i);
			break;
		}
	}

	for (int i = 0; i < seat_max; i++)
	{
		seats[i].handler_flag = 0;
	}

    wait_handle_action = action;
    wait_handler_seat = player->seatid;

	Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
	packet.val["card"] = card;
	packet.val["time_out"] = 0;
	packet.val["pg_flag"] = pg_flag;
	vector_to_json_array(seat.hole_cards.cards, packet, "holes");
	packet.val["chu_seat"] = -1;
	seat.hole_cards.handler_ting(card);
	if (seat.hole_cards.hu_cards.size() > 0)
	{
		vector_to_json_array(seat.hole_cards.hu_cards, packet, "hu_cards");
	}
	packet.end();
	unicast(player, packet.tostring());

	Jpacket packet1;
	packet1.val["cmd"] = SERVER_BET_SUCC_BC;
	packet1.val["seatid"] = player->seatid;
	packet1.val["uid"] = player->uid;
	packet1.val["action"] = action;
	packet1.val["card"] = card;
	packet1.val["time_out"] = 0;
	packet1.val["pg_flag"] = pg_flag;
	packet1.val["chu_seat"] = -1;
	int size = seat.hole_cards.cards.size();
	for (int i = 0; i < size; i++)
	{
		packet1.val["holes"].append(0);
	}
	packet1.end();
	broadcast(player, packet1.tostring());
	return 0;

}

int Table::handler_peng(Player* player)
{
	Json::Value &val = player->client->packet.tojson();
	Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();
	int card = val["card"].asInt();

	if (seat.betting == 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_peng error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (last_action != PLAYER_CHU && last_action != PLAYER_GUO)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_peng action  error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (last_card.value != card || actions[NOTICE_PENG] != 1)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_peng value  error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	last_action = PLAYER_PENG;
	last_action_seatid = player->seatid;
	seat.hole_cards.handler_peng(card, 0);
	seat.guo_hu_cards.clear();
	seats[chu_seat].hole_cards.handler_peng(card, 1);
	handler_recored_peng(card, seat.seatid, chu_seat);
	dump_hole_cards(seat.hole_cards.cards, cur_seat, 2);

	if (seat.peng_record.find(chu_seat) == seat.peng_record.end())
	{
		seat.peng_record[chu_seat] = 1;      
	}
	else
	{
		seat.peng_record[chu_seat] += 1;
	}
	seat.peng_card_record[card] = chu_seat;
	seat.obsorb_seats.push_back(chu_seat);

    seat.last_actions[1] = seat.last_actions[0];
    seat.last_actions[0] = action;
    if (seat.gang_hu_flag == 1)
    {
        seat.gang_hu_flag = 0;
        gang_hu_seat = -1;
    }

    peng_count++;

	Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
	packet.val["card"] = card;
	packet.val["chu_seat"] = chu_seat;
	vector_to_json_array(seat.hole_cards.cards, packet, "holes");
	packet.end();
	unicast(player, packet.tostring());

	Jpacket packet1;
	packet1.val["cmd"] = SERVER_BET_SUCC_BC;
	packet1.val["seatid"] = player->seatid;
	packet1.val["uid"] = player->uid;
	packet1.val["action"] = action;
	packet1.val["card"] = card;
	packet1.val["chu_seat"] = chu_seat;
	int size = seat.hole_cards.cards.size();
	for (int i = 0; i < size; i++)
	{
		packet1.val["holes"].append(0);
	}
	packet1.end();
	broadcast(player, packet1.tostring());

	if (seats[chu_seat].player)
    {
		handler_play_procedure(cur_seat, chu_seat, card, 2);
	}
	return 0;
}

int Table::handler_gang(Player* player)
{
	Json::Value &val = player->client->packet.tojson();
	Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();
	int card = val["card"].asInt();
	int gang_flag = val["gang_flag"].asInt();//0 是吃杠，1是碰杠，2是3+1，3是手上四个形成暗杠

	if (seat.betting == 0)
	{
		handler_prop_error(player, action);
		mjlog.error("handler_gang error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (actions[NOTICE_GANG] != 1)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_gang notice error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

    vector<Card>::iterator bit = seat.hole_cards.gang_cards.begin();
    vector<Card>::iterator eit = seat.hole_cards.gang_cards.end();

    if (find(bit, eit, card) == eit)
    {
        handler_bet_error(player, action);
		mjlog.error("handler_gang flag error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
    }

    int i = 0;
    for (; bit != eit; bit++)
    {
        if (seat.hole_cards.gang_cards[i].value == card)
        {
            gang_flag = seat.hole_cards.gang_flags[i];
            break;
        }
        i++;
    }

	last_action = PLAYER_GANG;
	last_action_seatid = player->seatid;
	last_gang_flag = gang_flag;
	seat.hole_cards.handler_gang(card, gang_flag, 0);
	seat.guo_hu_cards.clear();

	dump_hole_cards(seat.hole_cards.cards, cur_seat, 3);

    last_gang_card.set_value(card);
    wait_handle_action = action;
    wait_handler_seat = player->seatid;

    seat.last_actions[1] = seat.last_actions[0];
    seat.last_actions[0] = action;

	// 只有是杠别的玩家的牌的时候才需要下面的处理
    if (gang_flag == 0)
    {
        seat.gang_seats.push_back(chu_seat);
		seat.obsorb_seats.push_back(chu_seat);
		seats[chu_seat].hole_cards.handler_gang(card, gang_flag, 1);
		handler_recored_gang(card, seat.seatid, chu_seat, gang_flag);
	}
	else if( gang_flag == 1)
	{
		fang_gang_seat = -1;
		seat.gang_seats.push_back(-1);
		handler_recored_gang(card, seat.seatid, -1, gang_flag);
	}
    else
    {
		fang_gang_seat = -1;
        seat.gang_seats.push_back(-1);
		seat.obsorb_seats.push_back(-1);
		handler_recored_gang(card, seat.seatid, -1, gang_flag);
    }

    if (seat.gang_hu_flag == 1)
    {
        seat.gang_hu_flag = 0;
        gang_hu_seat = -1;
    }

    gang_count++;

	Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
	packet.val["card"] = card;
	packet.val["gang_flag"] = gang_flag;
    if (gang_flag == 0)
    {
        packet.val["chu_seat"] = chu_seat;
    }
    else if (gang_flag == 1)
    {
        packet.val["chu_seat"] = seat.peng_card_record[card];
    }
    else
    {
        packet.val["chu_seat"] = -1;
    } 
	vector_to_json_array(seat.hole_cards.cards, packet, "holes");
	//vector_to_json_array(seat.hole_cards.obsorb_cards, packet, "obsorb_holes");
	packet.end();
	unicast(player, packet.tostring());

	Jpacket packet1;
	packet1.val["cmd"] = SERVER_BET_SUCC_BC;
	packet1.val["seatid"] = player->seatid;
	packet1.val["uid"] = player->uid;
	packet1.val["action"] = action;
	packet1.val["card"] = card;
	packet1.val["gang_flag"] = gang_flag;
    if (gang_flag == 0)
    {
        packet1.val["chu_seat"] = chu_seat;
    }
    else if (gang_flag == 1)
    {
        packet1.val["chu_seat"] = seat.peng_card_record[card];
    }
    else
    {
        packet1.val["chu_seat"] = -1;
    }

	int size = seat.hole_cards.cards.size();
	for (int i = 0; i < size; i++)
	{
		packet1.val["holes"].append(0);
	}
	packet1.end();
	broadcast(player, packet1.tostring());

	//记录玩牌过程中的杠 0 吃杠 1 碰杠 2 3都是暗杠
	if (gang_flag == 0)
	{
		handler_play_procedure(cur_seat, chu_seat, card, 3);
        seat.total_ming_gang++;
	}
	else if (gang_flag == 1)
	{
		handler_play_procedure(cur_seat, chu_seat, card, 4);
        seat.total_ming_gang++;
	}
	else 
	{
		handler_play_procedure(cur_seat, chu_seat, card, 5);
        seat.total_an_gang++;
	}

	seat.gang_count[gang_flag]++;

	if (gang_flag == 0)
	{
		seats[chu_seat].fang_gang_count++;

		if (gang_fang_count.find(player->seatid) != gang_fang_count.end())
        {
			if (gang_fang_count[player->seatid].find(chu_seat) != gang_fang_count[player->seatid].end())
            {
				gang_fang_count[player->seatid][chu_seat] += 1;
			}
			else
            {
				gang_fang_count[player->seatid][chu_seat] = 1;
			}

			gang_fang_count[player->seatid][chu_seat] = 1;
		}
	}
    mjlog.debug("gang_flag [%d] gang_fang_count size [%d]\n",gang_flag,gang_fang_count.size());
	return 0;
}

int Table::handler_hu(Player* player)
{
	Json::Value &val = player->client->packet.tojson();
	Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();
	int card = val["card"].asInt();
	int hu_flag = 0;

	if (seat.betting == 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_hu error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (seat.hole_cards.cards.size() % 3 == 1)
	{
		if (last_action == PLAYER_GANG)
        {
			if (card != last_gang_card.value)
            {
				handler_bet_error(player, action);
				mjlog.error("handler_hu error. betting[1] uid[%d] seatid[%d] tid[%d].\n",
						player->uid, player->seatid, tid);
				return -1;
			}
		}
		else
		{
			if (card != last_card.value)
			{
				handler_bet_error(player, action);
				mjlog.error("handler_hu error. betting[1] uid[%d] seatid[%d] tid[%d].\n",
						player->uid, player->seatid, tid);
				return -1;
			}
		}
	}

	if (seat.hole_cards.size() % 3 == 1)
	{
		if (seat.hole_cards.permit_hu(card))
		{
			win_seatid = player->seatid;
			hu_flag = 0;
		}
	}
	else if (seat.hole_cards.permit_hu())
	{
		win_seatid = player->seatid;
		hu_flag = 1;      
	}

	if (win_seatid < 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_hu error. betting[2] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	last_action = PLAYER_HU;
	vector<Card> cards = seat.hole_cards.cards;
	if (cards.size() % 3 == 2)
	{
		vector<Card>::iterator it = find(cards.begin(), cards.end(), card);
		if (it != cards.end())
		{
			cards.erase(it);
		}
	}

	hu_seat = player->seatid;
	hu_card = card;

    seat.last_actions[1] = seat.last_actions[0];
    seat.last_actions[0] = action;

	if (hu_flag == 0)
	{
		handler_recored_hu(card, seat.seatid, chu_seat);
	}
	else
	{
		handler_recored_hu(0, seat.seatid, -1);
	}

	Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
	packet.val["card"] = card;
	packet.val["hu_flag"] = hu_flag;
	vector_to_json_array(cards, packet, "holes");
	if (hu_flag == 0 && gang_hu_seat == -1)
    {
		packet.val["chu_seat"] = chu_seat;
	}
    else if (gang_hu_seat >= 0)
    {
		packet.val["chu_seat"] = gang_hu_seat;
	}
    else
    {
		packet.val["chu_seat"] = gang_hu_seat;
	}
	packet.end();
	unicast(player, packet.tostring());

	Jpacket packet1;
	packet1.val["cmd"] = SERVER_BET_SUCC_BC;
	packet1.val["seatid"] = player->seatid;
	packet1.val["uid"] = player->uid;
	packet1.val["action"] = action;
	packet1.val["card"] = card;
	packet1.val["hu_flag"] = hu_flag;
	vector_to_json_array(cards, packet1, "holes");
	if (hu_flag == 0 && gang_hu_seat == -1)
    {
		packet1.val["chu_seat"] = chu_seat;
	}
    else if (gang_hu_seat >= 0)
    {
		packet1.val["chu_seat"] = gang_hu_seat;
	}
    else
    {
		packet1.val["chu_seat"] = gang_hu_seat;
	}
	packet1.end();
	broadcast(player, packet1.tostring());

	return 0;
}

int Table::handler_guo(Player* player)
{
	Json::Value &val = player->client->packet.tojson();
	Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();

	if (seat.betting == 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_chi error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	//推倒胡没有 过胡不胡
	/*if (actions[NOTICE_HU] == 1 && seat.hole_cards.size() % 3 != 2)
	{
		seat.guo_hu_cards.push_back(last_card.value);
	}*/

	last_action = PLAYER_GUO;
	last_action_seatid = player->seatid;

	handler_recored_guo(0, seat.seatid, chu_seat);

	Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_UC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
	packet.end();
	unicast(player, packet.tostring());

	if (seat.pao_hu_flag == 1)
	{
		seat.pao_hu_flag = 0;
		pao_hu_seat = -1;
	}

	if (seat.gang_hu_flag == 1)
	{
		seat.gang_hu_flag = 0;
		/* gang_hu_seat = -1;*/
	}

	if (seat.hu == 1)
    {
		seat.hu = 0;
	}

	seat.handler_flag = 1;

	if (fang_gang_hu_seat > 0)
    {
		fang_gang_seat = -1;
		fang_gang_hu_seat = -1;
	}

	if (seat.hole_cards.size() % 3 == 2)
	{

	}
	else
	{
		count_next_bet();    
	}

	return 0;
}

int Table::handler_ting(Player* player)
{
	Json::Value &val = player->client->packet.tojson();
	Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();
	int card = val["card"].asInt();

	if (seat.betting == 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_ting error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	int ret = seat.hole_cards.handler_ting(card);
	if (ret < 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_ting error. card[%d] uid[%d] seatid[%d] tid[%d].\n",
				card, player->uid, player->seatid, tid);
		return -1;
	}

	last_action = PLAYER_TING;
	seat.ting = 1;

	Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
	packet.val["card"] = card;
	packet.val["chu_seat"] = -1;
	vector_to_json_array(seat.hole_cards.cards, packet, "holes");
	packet.end();
	unicast(player, packet.tostring());

	Jpacket packet1;
	packet1.val["cmd"] = SERVER_BET_SUCC_BC;
	packet1.val["seatid"] = player->seatid;
	packet1.val["uid"] = player->uid;
	packet1.val["action"] = action;
	packet1.val["card"] = card;
	packet1.val["chu_seat"] = -1;
	packet1.end();
	broadcast(player, packet1.tostring());

	return 0;
}

int Table::handler_cancel(Player *player)
{
	Json::Value &val = player->client->packet.tojson();
	Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();

	if (seat.betting == 0)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_cancel error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	last_action = PLAYER_CANCEL;
	seat.ting = 0;

	Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;
	packet.val["chu_seat"] = -1;
	packet.end();
	unicast(player, packet.tostring());

	return 0;
}

int Table::handler_jiabei(Player *player)
{
	Json::Value &val = player->client->packet.tojson();
	Seat &seat = seats[player->seatid];
	int action = val["action"].asInt();

	if (actions[NOTICE_JIABEI] != 1)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_jiabei error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	if (seat.jiabei >= MAX_JIABEI)
	{
		handler_bet_error(player, action);
		mjlog.error("handler_jiabei limit error. betting[0] uid[%d] seatid[%d] tid[%d].\n",
				player->uid, player->seatid, tid);
		return -1;
	}

	seat.hu = 0;
	seat.jiabei *= 2;
	actions[NOTICE_JIABEI] = 0;
	last_action = PLAYER_JIABEI;

	Jpacket packet;
	packet.val["cmd"] = SERVER_BET_SUCC_BC;
	packet.val["seatid"] = player->seatid;
	packet.val["uid"] = player->uid;
	packet.val["action"] = action;	
	packet.end();
	unicast(player, packet.tostring());

	return 0;
}

void Table::reset_actions()
{
	for (int i = 0; i < NOTICE_SIZE; i++)
	{
		actions[i] = 0;
	}
}

int Table::handler_dismiss_table(Player *player)
{
	Json::Value &val = player->client->packet.tojson();
	int agree = val["flag"].asInt();

	if (round_count == 0)
	{
		if (player->uid == owner_uid)
		{
			Jpacket packet;
			packet.val["cmd"] = SERVER_DISMISS_TABLE_SUCC_BC;
			packet.val["uid"] = player->uid;
			packet.val["name"] = player->name;
			packet.val["seatid"] = player->seatid;
			packet.val["agree"] = agree;
			packet.val["flag"] = 0;
			packet.end();
			broadcast(NULL, packet.tostring());

            if (transfer_flag)
            {
                if (players.find(origin_owner_uid) != players.end())
                {
                    players[origin_owner_uid]->incr_rmb(create_rmb);
                    Player* player1 = players[origin_owner_uid];
                    insert_flow_log((int)time(NULL), player1->uid, player1->remote_ip, 0, type, zid, ttid, type, 1, create_rmb, player1->rmb);
                }          
            }

			clean_table();
			reset();       
		}
		else
		{
			zjh.game->del_player(player);
		}

		return 0;
	}

	// 有一个人拒绝就取消解散房间
	if (agree == 0)
	{
		seats[player->seatid].dismiss = 2;		
		ev_timer_stop(zjh.loop, &dismiss_timer);
        broadcast_dismiss_status(4);
		dismiss.clear();
		dismiss_flag = 0;
		dismiss_uid = 0;

		for (int i = 0; i < seat_max; i++)
		{
			seats[i].dismiss = 0;
		}
		return 0;
	}

	// 第一个人申请解散
	if (dismiss.size() == 0)
	{
		dismiss_uid = player->uid;
		dismiss_flag = 1;
		seats[player->seatid].dismiss = 1;     
		dismiss.insert(player->uid);

        ev_timer_again(zjh.loop, &dismiss_timer);
		broadcast_dismiss_status(1);	
	}
	else if (dismiss.find(player->uid) == dismiss.end())
	{
		seats[player->seatid].dismiss = 1;
		dismiss.insert(player->uid);

		if (dismiss.size() >= (max_ready_players - 1))   // 满足解散请求同意人数
		{
            ev_timer_stop(zjh.loop, &dismiss_timer);
			broadcast_dismiss_status(3);
			
			for (int i = 0; i < seat_max; i++)
			{
				seats[i].bet = 0;
			}

			state = END_GAME;
			game_end(1);

			dismiss.clear();
			reset();
		}
		else                                                           
		{            
			broadcast_dismiss_status(2);
		}     
	}

	return 0;
}

void Table::broadcast_dismiss_status(int flag)
{
	Jpacket packet;
	packet.val["cmd"] = SERVER_DISMISS_TABLE_SUCC_BC;
	packet.val["flag"] = flag;

	packet.val["dismiss"] = dismiss_flag;
	if (dismiss_flag)
	{
		packet.val["dismiss_time"] = (int)ev_timer_remaining(zjh.loop, &dismiss_timer);
		packet.val["dismiss_uid"] = dismiss_uid;
	}
	else
	{
		packet.val["dismiss_time"] = 0;
		packet.val["dismiss_uid"] = 0;
	}

	int i = 0;
	std::map<int, Player*>::iterator it;
	for (it = players.begin(); it != players.end(); it++) {
		Player *p = it->second;
		Seat &seat = seats[p->seatid];

		packet.val["players"][i]["uid"] = p->uid;
		packet.val["players"][i]["name"] = p->name;
		packet.val["players"][i]["seatid"] = p->seatid;	
		packet.val["players"][i]["dismiss"] = seat.dismiss;
		i++;
	}

	packet.end();
	broadcast(NULL, packet.tostring());
}

void Table::clean_table()
{
	std::map<int, Player*>::iterator it = players.begin();
	std::map<int, Player*>::iterator nit = players.begin();

	state = ROOM_WAIT_GAME;



	if (round_count == 0 && substitute == 1)
	{
		Player::incr_rmb(owner_uid, create_rmb);
		zjh.game->del_subs_table(owner_uid);
	}

	if (round_count > 0)
	{
		if (!transfer_flag && substitute != 1)
        {
			/*
            players[owner_uid]->incr_rmb(0 - create_rmb * ratio);
            Player* player = players[owner_uid];
            insert_flow_log((int)time(NULL), player->uid, player->remote_ip, 0, type, zid, ttid, type, 0, 1 * ratio, player->rmb);
            */
			create_table_cost();
        }

		for (int i = 0; i < seat_max; i++)
		{
			if (seats[i].player != NULL)
			{
				if (seats[i].player->uid == owner_uid)
				{                   
					seats[i].player->incr_total_create(1);
				}
				seats[i].player->incr_total_play(1);
			}
		}
	}

	for (int i = 0; i < seat_max; i++)
	{
		seats[i].dismiss = 0;
	}

	for (; it != players.end(); it = nit)
	{
		++nit;
		if (it->second != NULL)
		{
			for (int i = 0; i < seat_max; i++)
			{
				if (it->second == seats[i].player)
				{
					mjlog.debug("clean table");
					zjh.game->del_player(it->second);
					break;
				}
			}
		}
	}

	ready_players = 0;
	cur_players = 0;
	round_count = 0;
	dismiss_flag = 0;
	dismiss_uid = 0;
	if (substitute == 1)
	{
		substitute = 0;
		zjh.game->substitute_tables.erase(tid);
		clear_substitute_info();
		modify_substitute_info(2);
	}  
    dismiss.clear();
	zjh.temp_rc->command("LPUSH tids_list %d", ttid);
	zjh.game->table_ttid.erase(ttid);
	zjh.game->set_table_flag(ttid, 0);
	zjh.game->table_owners.erase(owner_uid);

	owner_uid = -1;
	owner_name = "";
	owner_remote_ip = "";
	ttid = -1;
    origin_owner_uid = -1;
    transfer_flag = false;
    max_ready_players = seat_max;
	hu_seat = -1;
	ghost_cards.set_value(0);
	trun_card.set_value(0);
	dismiss.clear();
	redpackes.clear();

	for (int i = 0; i < seat_max; i++)
	{
		seats[i].clear();
	}

	reset();

	ev_timer_stop(zjh.loop, &preready_timer);
	ev_timer_stop(zjh.loop, &ready_timer);
	ev_timer_stop(zjh.loop, &dismiss_timer);
	ev_timer_stop(zjh.loop, &subs_timer);
	//ev_timer_stop(zjh.loop, &single_ready_timer);
}

void Table::dismiss_timer_cb(struct ev_loop *loop, struct ev_timer *w, int revents)
{
	Table *table = (Table*) w->data;
	ev_timer_stop(zjh.loop, &table->dismiss_timer);

	table->dismiss_timeout();
}

int Table::dismiss_timeout()
{
	//broadcast_dismiss_status(5);

	for (int i = 0; i < seat_max; i++)
	{
		seats[i].bet = 0;
	}

	state = END_GAME;
	game_end(1);

	dismiss.clear();
	reset();
	return 0;
}

void Table::vector_to_json_string(std::vector<Card> &cards, Jpacket &packet, string key)
{
	char buff[256] = {0, };
	int len = 0;
    if (cards.size() > 0)
    {
        for (unsigned int i = 0; i < cards.size() - 1; i++) 
        {
		    len = strlen(buff);
		    snprintf(buff + len, sizeof(buff) - len, "%d_", cards[i].value); 
	    }

	    len = strlen(buff);
	    snprintf(buff + len, sizeof(buff) - len, "%d", cards[cards.size() - 1].value);
	    len = strlen(buff);
	    buff[len] = '\0';
    }
    packet.val[key] = buff;
}

int Table::insert_flow_record()
{
	Jpacket packet;
	char rid[32] = {0, };
	char replayid[64] = {0, };
    char replay_key[32] = {0, };


	snprintf(rid, 32, "%d_%d", round_ts, ttid);
    snprintf(replay_key, 32, "%d_%d", ts, ttid);
	packet.val["roundid"] = rid;
    packet.val["replay_key"] = replay_key;
	packet.val["tid"] = ttid;
	packet.val["create_time"] = (int)time(NULL);

	packet.val["did"] = seats[dealer].player->uid;
	packet.val["dname"] = seats[dealer].player->name;
	packet.val["dbet"] = seats[dealer].bet;
	packet.val["dip"] = seats[dealer].player->remote_ip;

	const char* prefix = zjh.conf["replay_prefix"].asCString();
	snprintf(replayid, sizeof(replayid), "%s/%d_%d", prefix, ts, ttid);
	packet.val["replay_url"] = replayid;
	snprintf(replayid, sizeof(replayid), "%d%d", ttid, ts % 300000);
	packet.val["replayid"] = replayid;
	packet.val["owner_uid"] = owner_uid;
    packet.val["owner_name"] = owner_name;
    packet.val["substitute"] = substitute;

	vector_to_json_string(seats[dealer].hole_cards.cards, packet, "dcards");

	// std::vecotr<vecotr<Card> >::iterator it = seats[dealer].hole_cards.obsorb_cards.begin();
	// for (; it != seats[dealer].hole_cards.obsorb_cards.end(); it++)
	// {
	//     vector_to_json_array(*it, packet, "docards");
	// }

	int index = 1;
	for (int i = 0; i < seat_max; i++)
	{
		if (i == dealer || seats[i].occupied == 0)
		{
			mjlog.info("insert_flow_record seatid %d don't dealed\n", i);
			continue;
		}

		Player* player = seats[i].player;

		switch (index)
		{
			case 1:
				packet.val["x1id"] = player->uid;
				packet.val["x1name"] = player->name;
				packet.val["x1bet"] = seats[i].bet; 
				//packet.val["x1ratio"] = seats[i].bet_ratio;
				packet.val["x1ip"] = player->remote_ip;
				vector_to_json_string(seats[i].hole_cards.cards, packet, "x1cards");
				//vector_to_json_array(seats[i].hole_cards.obsorb_cards, packet, "x1ocards");
				break;

			case 2:
				packet.val["x2id"] = player->uid;
				packet.val["x2name"] = player->name;
				packet.val["x2bet"] = seats[i].bet;
				packet.val["x2ip"] = player->remote_ip;
				//packet.val["x2ratio"] = seats[i].bet_ratio;
				vector_to_json_string(seats[i].hole_cards.cards, packet, "x2cards");
				//vector_to_json_array(seats[i].hole_cards.obsorb_cards, packet, "x2ocards");
				break;

			case 3:
				packet.val["x3id"] = player->uid;
				packet.val["x3name"] = player->name;
				packet.val["x3bet"] = seats[i].bet;
				packet.val["x3ip"] = player->remote_ip;
				//packet.val["x3ratio"] = seats[i].bet_ratio;
				vector_to_json_string(seats[i].hole_cards.cards, packet, "x3cards");
				//vector_to_json_array(seats[i].hole_cards.obsorb_cards, packet, "x3ocards");
				break;

			default:
				break;
		}
		index++;
	}

	string str = packet.val.toStyledString().c_str();

	int ret = zjh.temp_rc->command("LPUSH flow_list %s", str.c_str());

	if (ret < 0)
	{
		mjlog.error("insert_flow_record %s", str.c_str());
		return - 1;
	}

	return 0;
}

int Table::insert_flow_round_record()
{
	Jpacket packet;
	char rid[32] = {0, };

	int init_money = zjh.conf["tables"]["init_money"].asInt();

	snprintf(rid, 32, "%d_%d", round_ts, ttid);
	packet.val["roundid"] = rid;
	packet.val["tid"] = ttid;
	packet.val["create_time"] = (int)time(NULL);
	packet.val["table_owner"] = owner_uid;
    packet.val["owner_name"] = owner_name;
    packet.val["substitute"] = substitute;
	packet.val["type"] = zjh.conf["tables"]["type"].asInt();

	int index = 1;
	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].occupied == 0)
		{
			continue;
		}

		Player* player = seats[i].player;

		switch (index)
		{
			case 1:
				packet.val["p1id"] = player->uid;
				packet.val["p1name"] = player->name;
				packet.val["p1bet"] = player->money - init_money;
				packet.val["p1ip"] = player->remote_ip;
				break;
			case 2:
				packet.val["p2id"] = player->uid;
				packet.val["p2name"] = player->name;
				packet.val["p2bet"] = player->money - init_money;
				packet.val["p2ip"] = player->remote_ip;
				break;
			case 3:
				packet.val["p3id"] = player->uid;
				packet.val["p3name"] = player->name;
				packet.val["p3bet"] = player->money - init_money;
				packet.val["p3ip"] = player->remote_ip;
				break;
			case 4:
				packet.val["p4id"] = player->uid;
				packet.val["p4name"] = player->name;
				packet.val["p4bet"] = player->money - init_money;
				packet.val["p4ip"] = player->remote_ip;
			default:
				break;
		}
		index++;
	}


	int owner_flag = 0;
	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].occupied == 0)
		{
			mjlog.error("insert_flow_round_record seatid %d don't dealed\n", i);
			continue;
		}

		Player* player = seats[i].player;
		packet.val["uid"] = player->uid;
		packet.val["uname"] = player->name;
		packet.val["uip"] = player->remote_ip;

		if (player->uid == owner_uid)
		{
			owner_flag = 1;
		}

		string str = packet.val.toStyledString().c_str();
		int ret = zjh.temp_rc->command("LPUSH flow_round_list %s", str.c_str());

		if (ret < 0)
		{
			mjlog.error("insert_flow_round_record %s", str.c_str());
		}
	}

	if(owner_flag == 0 && substitute == 1)
	{	
		packet.val["uid"] = owner_uid;
		packet.val["uname"] = owner_name;
		packet.val["uip"] = owner_remote_ip;
		string str = packet.val.toStyledString().c_str();
		int ret = zjh.temp_rc->command("LPUSH flow_round_list %s", str.c_str());

		if (ret < 0)
		{
			mjlog.error("insert_flow_round_record %s", str.c_str());
		}
	}

	return 0;
}

void Table::handler_net_status(Player* player, int status)
{
	Jpacket packet;
	packet.val["cmd"] = SERVER_NET_STATUS_BC;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = player->seatid;
	packet.val["name"] = player->name;
	packet.val["money"] = player->money;
	packet.val["rmb"] = player->rmb;
	packet.val["total_board"] = player->total_board;
	packet.val["status"] = status;

	packet.end();
	broadcast(player, packet.tostring());
}

int Table::calculate_base_score(int sid, int pao)
{
	Seat &seat = seats[sid];
	int score = 2;
	if (pao_hu_seat >= 0)
	{
		seat.hole_cards.analysis_card_type(last_card.value);
	}
    else if (gang_hu_seat >= 0)
    {
        seat.hole_cards.analysis_card_type(last_gang_card.value);
    }
	else
	{
		seat.hole_cards.analysis_card_type();
	}

    seat.card_type = seat.hole_cards.card_type;

	if(sid == dealer )
    {
		seat.always_dealer_count ++;
	}
	else
	{
		seat.always_dealer_count = 0;
	}	
 mjlog.debug("calculate base score seatid[%d] pao[%d] card_type [%d] score[%d] pao_hu_seat [%d] gang_hu_seat[%d] \n", sid, pao, seat.card_type, score,pao_hu_seat,gang_hu_seat);

	switch (seat.card_type)
	{
	case CARD_TYPE_PENG_HU://碰碰胡2倍
		if (bumper_two == 1 && type == 9)
        {
			score *= 2;
		}
		else
        {
			score = 2;
		}
		break;
	case CARD_TYPE_QI_XIAO_DUI://七对4倍
		if (seven_pairs_four == 1 && type == 9)
        {
			score *= 4;
		}
		else
        {
			score = 2;
		}
		break;
	case CARD_TYPE_QING_YI_SE://清一色4倍
		if (all_in_one_four == 1 && type == 9)
        {
			score *= 4;
		}
		else
        {
			score = 2;
		}
		break;
	case CARD_TYPE_QING_PENG://清一色4倍
		if (all_in_one_four == 1 && type == 9)
        {
			score *= 4;
		}
		else if(bumper_two == 1 && type == 9)
		{
			score *= 2;
			seat.card_type = CARD_TYPE_PENG_HU;
		}
		else
        {
			score = 2;
		}
		break;
	case CARD_TYPE_HUN_YAO_JIU://幺九6倍
    case CARD_TYPE_QING_YAO_JIU:
		  if (unitary_nine_six == 1 && type == 9)
          {
              score *= 6;
		  }
		  else if(bumper_two == 1 && type == 9)
		  {
			  	score *= 2;
				seat.card_type = CARD_TYPE_PENG_HU;
		  }
		  else
          {
              score = 2;
		  }
		  break;
    case CARD_TYPE_ZI_YI_SE://全风（字一色）8倍
		  if (mixed_one_color_eight == 1 && type == 9)
          {
              score *= 8;
		  }
		  else if(bumper_two == 1 && type == 9)
		  {
			  	score *= 2;
				seat.card_type = CARD_TYPE_PENG_HU;
		  }
		  else
          {
              score = 2;
		  }
		  break;
    case CARD_TYPE_SHI_SAN_YAO://十三幺8倍
		  if (thirteen_unitary_eight == 1 && type == 9)
          {
              score *= 8;
		  }
		  else
          {
              score = 2;
		  }
		  break;
	default:
		score = 2;
        break;
	}
    mjlog.debug("calculate base score seatid[%d] pao[%d] card_type [%d] score[%d]\n", sid, pao, seat.card_type, score);
	// 额外番
    // 天胡
    if (deck.get_count == 1 && sid == dealer)
    {
        tian_hu_flag = 1;
		//score *= 2;
		mjlog.debug("calculate base score seatid[%d] pao[%d] card_type [%d] score[%d] tian_hu_flag [%d] \n",
				sid, pao, seat.card_type, score,tian_hu_flag);
	}

	//地胡
	if (deck.get_count == 1 && sid != dealer)
	{
		di_hu_flag = 1;
		//score *= 2;
		mjlog.debug("calculate base score seatid[%d] pao[%d] card_type [%d] score[%d] di_hu_flag [%d] \n",
				sid, pao, seat.card_type, score,di_hu_flag);
	}
	else if (deck.get_count == 2 && sid != dealer)
	{
		if (chi_count == 0 && peng_count == 0 && gang_count == 0)
		{
			di_hu_flag = 1;
			//score *= 2;
			mjlog.debug("calculate base score seatid[%d] pao[%d] card_type [%d] score[%d] di_hu_flag [%d] \n",
					sid, pao, seat.card_type, score,di_hu_flag);
		}
	}

	//明杠 杠上花
	if (seat.last_actions[0] == PLAYER_HU && seat.last_actions[1] == PLAYER_GANG)
	{
		gang_shang_hua_flag = 1;
		//score *= 2;
		int size = seat.gang_seats.size();
		if (size > 0)
		{
			gang_shang_hua_seat = seat.gang_seats[size - 1];
		}
		mjlog.debug("calculate base score seatid[%d] pao[%d] card_type [%d] score[%d] gang_shang_hua_flag [%d] gang_shang_hua_seat[%d]\n",
				sid, pao, seat.card_type, score,gang_shang_hua_flag, gang_shang_hua_seat);
	}

	//推到胡没有海底胡
	/*
	   if (deck.permit_get() == 0 && pao == 0)
	   {
	   hai_di_hu_flag = 1;
	   score *= 2;
	   }*/

	//推倒胡 四鬼加倍
	if (four_ghose_hu_two == 1 && seat.hole_cards.has_four_ghost ==1 && type == 9)
	{
		score *= 2;
		mjlog.debug("calculate base score seatid[%d] pao[%d] card_type [%d] score[%d] four_ghose_hu_two [%d ] has_four_ghost[%d] \n",
				sid, pao, seat.card_type, score,four_ghose_hu_two,seat.hole_cards.has_four_ghost );
	}

	//判断7对胡是否加番
	if (has_pair_add == 1)
	{
		if (seat.card_type == CARD_TYPE_QI_XIAO_DUI
				|| seat.card_type == CARD_TYPE_HAO_HUA_QI_DA_DUI
				|| seat.card_type == CARD_TYPE_SHUANG_HAO_HUA_QI_DA_DUI
				|| seat.card_type == CARD_TYPE_SAN_HAO_HUA_QI_DA_DUI)
		{
			score *= 2;
			mjlog.debug("calculate base score seatid[%d] pao[%d] card_type [%d] score[%d] [%d] [%d ] [%d][%d] \n",
					sid, pao, seat.card_type, score,CARD_TYPE_QI_XIAO_DUI,CARD_TYPE_HAO_HUA_QI_DA_DUI,
					CARD_TYPE_SHUANG_HAO_HUA_QI_DA_DUI,CARD_TYPE_SAN_HAO_HUA_QI_DA_DUI );
		}
	}

	//无鬼是否加倍
	if (no_ghost_add == 1 && (seat.hole_cards.has_card(ghost_cards.value,1) == 0))
	{
		score *= 2;
		mjlog.debug("calculate base score seatid[%d] pao[%d] card_type [%d] score[%d] no_ghost_add [%d] has_ghost[%d]\n",
				sid, pao, seat.card_type, score, no_ghost_add, seat.hole_cards.has_card(ghost_cards.value,1));
	}
	

	//连庄胡牌 每次多加2分
	if (has_steadily_high == 1 && seat.always_dealer_count > 1)
	{
		score += 2 * (seat.always_dealer_count - 1);
		mjlog.debug("calculate base score seatid[%d] pao[%d] card_type [%d] score[%d] has_steadily_high [%d] always_dealer_count[%d]\n",
				sid, pao, seat.card_type, score,has_steadily_high,seat.always_dealer_count);
	}

	mjlog.debug("calculate base score seatid[%d] pao[%d] card_type [%d] score[%d]"
			"tian_hu_flag [%d] di_hu_flag[%d] gang_shang_hua_flag[%d] gang_shang_hua_seat[%d]"
			" has_pair_add[%d] no_ghost_add[%d] has_ghost[%d] has_steadily_high[%d] always_dealer_count[%d]\n",
			sid, pao, seat.card_type, score,tian_hu_flag, di_hu_flag, gang_shang_hua_flag, gang_shang_hua_seat, 
			has_pair_add, no_ghost_add, seat.hole_cards.has_card(ghost_cards.value,1), has_steadily_high, seat.always_dealer_count);
	return score;
}

void Table::update_account_bet()
{
	// 处理杠 0 是吃杠，1是碰杠，2是3+1，3是手上四个形成暗杠
	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].ready != 1)
		{
			continue;
		}

		seats[i].bet -= fang_gang_fen *(max_ready_players -1) * seats[i].fang_gang_count;
		if (seats[i].gang_count[0] > 0)
		{
			seats[i].bet += ming_gang_fen *(max_ready_players -1)* seats[i].gang_count[0];
		}

		if (seats[i].gang_count[1] > 0)
		{
			seats[i].bet += ming_gang_fen * (max_ready_players - 1) * seats[i].gang_count[1];
			for (int j = 1; j < seat_max; j++)
			{
				int index = (i + j) % seat_max;
				if (seats[index].ready != 1)
				{
					continue;
				}
				seats[index].bet -= peng_gang_fen * seats[i].gang_count[1];
			}
		}

		if (seats[i].gang_count[2] > 0)
		{
			seats[i].bet += (max_ready_players - 1) * an_gang_fen * seats[i].gang_count[2];

			for (int j = 1; j < seat_max; j++)
			{
				int index = (i + j) % seat_max;
				if (seats[index].ready != 1){
					continue;
				}
				seats[index].bet -= an_gang_fen * seats[i].gang_count[2];
			}
		}

		if (seats[i].gang_count[3] > 0)
		{
			seats[i].bet += (max_ready_players - 1) * an_gang_fen * seats[i].gang_count[3];

			for (int j = 1; j < seat_max; j++)
			{
				int index = (i + j) % seat_max;
				if (seats[index].ready != 1)
				{
					continue;
				}
				seats[index].bet -= an_gang_fen * seats[i].gang_count[3];
			}
		}
	}
	for(int i = 0;i< seat_max;i++){
		mjlog.debug("gang pai seatid [%d] fang_gang_count[%d] gang_count[%d][%d][%d][%d] bet[%d] \n",
				i, seats[i].fang_gang_count, seats[i].gang_count[0], seats[i].gang_count[1], 
				seats[i].gang_count[2], seats[i].gang_count[3],seats[i].bet);
	}

	//跟庄算分
	if (follow_dealer == 1  && follow_dealer_count > 0)
	{
		seats[dealer].bet -= 1 * (max_ready_players - 1)  ;
		for(int i = 0; i < seat_max ; i++)
		{
			if (seats[i].ready == 0)
			{
				continue;
			}

			if(i != dealer )
			{
				seats[i].bet += 1 ;
			}
			mjlog.debug("follow_dealer_count[%d] seatid [%d] bet[%d]\n", follow_dealer_count,i,seats[i].bet);
		}

	}

	if (win_seatid < 0 && pao_hu_count < 2 && gang_hu_count < 2)
	{
		return;
	}

	if (gang_hu_seat >= 0) //抢杠胡
	{
		for (int i = 0; i < seat_max; i++)
		{
			if (seats[i].ready != 1)
			{
				continue;
			}

			if (i == win_seatid || seats[i].gang_hu_flag == 1)
			{
				int score = calculate_base_score(i, 1);
				seats[i].bet += (max_ready_players -1) * score;
				seats[gang_hu_seat].bet -= (max_ready_players -1) * score;
				if (horse_follow_end == 1)
				{
					seats[i].horse_score = score;
				}
				mjlog.debug("gang_hu_seat[%d] score [%d] seatid[%d] bet[%d] gang_hu_seat.bet[%d]\n", 
						gang_hu_seat, score, i, seats[i].bet, seats[gang_hu_seat].bet);
			}
		}

	}
	else //自摸
	{
		int score = calculate_base_score(win_seatid, 0);
		if (horse_follow_end == 1)
		{
			seats[win_seatid].horse_score = score;
		}
		// 自摸平湖牌型基本算法
		for (int i = 0; i < seat_max; i++)
		{
			if (seats[i].ready != 1)
			{
				continue;
			}

			if (i == win_seatid)
			{
				seats[i].bet += (max_ready_players - 1) * score;
			}
			else
			{
				if (gang_shang_hua_seat >= 0 && has_bar_burst_al == 1)
				{
					seats[gang_shang_hua_seat].bet -= score;
				}
				else
				{
					seats[i].bet -= score;
				}
			}
			mjlog.debug("gang_shang_hua_seat[%d] win seatid [%d] seatid[%d] bet[%d]\n", 
					gang_shang_hua_seat, win_seatid, i, seats[i].bet);
		}
	}

	zhong_horse.clear();

	// 处理买马
	if (horse_num == 0)
	{
		return;
	}

	int horse_count = 0;

	int deck_horse_size = deck.horse_cards.size();
	
	mjlog.debug("deck.horse_cards.size() [%d] horse_num[%d] \n", deck.horse_cards.size(), horse_num);


	for (int i = 0; i < deck_horse_size; i++)
	{
		zhong_horse.push_back(0);
	}

	//胡牌算马
	for (int j = 0; j < seat_max; j++)
	{
		if (j != win_seatid && seats[j].gang_hu_flag != 1)
		{
			continue;
		}
	
		int diff_seat = (j - dealer + seat_max) % seat_max;
			
		for (int i = 0; i < deck_horse_size; i++)
		{
			seats[j].horse_cards.push_back(deck.horse_cards[i]);
			if ((deck.horse_cards[i].face - 1) % seat_max == diff_seat)
			{
				horse_count++;
				seats[j].horse_count++;
				zhong_horse[i] = 1;
				seats[j].zhong_horse.push_back(1);
			}
			else
			{
				seats[j].zhong_horse.push_back(0);
			}
		}
	}

	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].ready != 1)
		{
			continue;
		}

		if (seats[i].horse_count > 0)
		{
			seats[i].bet += (max_ready_players - 1) * seats[i].horse_score * seats[i].horse_count;

			for (int j = 1; j < seat_max; j++)
			{
				int index = (i + j) % seat_max;
				if (seats[index].ready != 1)
				{
					continue;
				}

				if (gang_hu_seat >= 0 && has_rob_gang_al == 1)//抢杠全包
				{
					seats[gang_hu_seat].bet -= seats[i].horse_score * seats[i].horse_count;
				}
				else if(gang_shang_hua_seat >= 0 && has_bar_burst_al == 1)//杠上花全包

				{
					seats[gang_shang_hua_seat].bet -= seats[i].horse_score * seats[i].horse_count;
				}
				else
				{
					seats[index].bet -= seats[i].horse_score * seats[i].horse_count;
				}	
			}
		}
		mjlog.debug("seatid[%d] horse_count[%d] horse_score[%d] max_ready_players[%d] bet[%d]\n", 
				i, seats[i].horse_count, seats[i].horse_score,max_ready_players, seats[i].bet );
	}
	for (int i = 0; i < seat_max; i++)
	{
		mjlog.debug("seatid[%d] horse_count[%d] horse_score[%d] max_ready_players[%d] bet[%d]\n",
				i, seats[i].horse_count, seats[i].horse_score,max_ready_players, seats[i].bet );
	}
	mjlog.info("horse_with_gang [%d] \n",horse_with_gang);
	if (horse_with_gang == 1)
	{
		handle_horse_with_gang();
	}

	for (int i = 0; i < seat_max; i++)
	{
		Player* player = seats[i].player;
		if (player == NULL)
		{
			continue;
		}
		mjlog.debug("update acount, uid[%d], money[%d], bet[%d]\n", player->uid, player->money, seats[i].bet);
	}    
}

// action: 0 为发牌状态，1为吃牌，2为碰牌，3为杠牌，4为摸牌
void Table::dump_hole_cards(std::vector<Card>& cards, int seatid, int action)
{
	char buff[256] = {0, };
	const char* action_desc[] = {"发牌", "吃", "碰", "杠", "摸牌", "出牌"};

	std::vector<Card>::iterator it = cards.begin();
	for (; it != cards.end(); it++)
	{
		int len = strlen(buff);
		snprintf(buff + len, 256 - len, "%s ", it->get_card().c_str());
	}

	mjlog.debug("dumpcards table[%d] uid[%d] seat[%d] action[%s]\n", tid,
			seats[seatid].player->uid, seatid, action_desc[action]);
	mjlog.debug("dumpcards: %s\n", buff);
}

void Table::check_ip_conflict()
{
	if (players.size() == seat_max && round_count == 0)
	{
		std::map<string, int> ip_count;
		for (int i = 0; i < seat_max; i++)
		{
			string ip = seats[i].player->remote_ip;
			if (ip_count.find(ip) == ip_count.end())
			{
				ip_count[ip] = 1;
			}
			else
			{
				ip_count[ip] += 1;
			}
		}

		if (ip_count.size() != seat_max)
		{
			Jpacket packet;
			packet.val["cmd"] = SERVER_IP_CONFLICT;
			std::map<string, int>::iterator it;
			int j = 0;
			for (it = ip_count.begin(); it != ip_count.end(); it++)
			{
				if (it->second >= 2)
				{
					for (int i = 0; i < seat_max; i++)
					{
						string ip = seats[i].player->remote_ip;
						if (ip == it->first)
						{
							packet.val["sam_ip"][j].append(seats[i].player->name);
						}
					}
					j++;
				}
			}

			packet.end();
			broadcast(NULL, packet.tostring());
		}
	}
}

void Table::broadcast_forbid_hu(Player* player, int num)
{
	Jpacket packet;
	packet.val["cmd"] = SERVER_FORBID_HU_BC;
	packet.val["name"] = player->name;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = player->seatid;
	packet.val["count"] = num;
	packet.end();

	broadcast(NULL, packet.tostring());
}

void Table::handler_gps_notice(Player* player)
{
	Json::Value &val = player->client->packet.tojson();
	float jingdu = val["jingdu"].asFloat();
	float weidu = val["weidu"].asFloat();

	Seat &seat = seats[player->seatid];
	seat.jingdu = jingdu;
	seat.weidu = weidu;

	Jpacket packet;
	packet.val["cmd"] = SERVER_GPS_POS_NOTICE_SUCC_UC;
	packet.val["name"] = player->name;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = player->seatid;
	packet.end();

	unicast(player, packet.tostring());
}

void Table::handler_gps_dist_req(Player* player)
{
	Json::Value &val = player->client->packet.tojson();
	int seatid = val["seatid"].asInt();
	std::set<int> seatids;

	Jpacket packet;
	packet.val["cmd"] = SERVER_GPS_DIS_SUCC_UC;
	packet.val["seatid"] = seatid;

	for (int i = 0; i < seat_max; i++)
	{
		int next = (seatid + i) % seat_max;
		if (seats[next].jingdu < 1.0f || seats[next].weidu < 1.0f)
		{
			packet.val["ndseatid"].append(next);
			seatids.insert(next);
		}
	}

	for (int i = 1; i < seat_max; i++)
	{
		int next = (seatid + i) % seat_max;
		if (seatids.find(next) == seatids.end() && seatids.find(seatid) == seatids.end())
		{
			double distance = GetDistance(seats[seatid].jingdu, seats[seatid].weidu, seats[next].jingdu, seats[next].weidu);
			int idis = (int)distance;
			packet.val["distances"].append(idis);
		}
		else
		{
			packet.val["distances"].append(-1);
		}
	}
	packet.end();

	broadcast(NULL, packet.tostring());
}

double Table::GetDistance(double dLongitude1, double dLatitude1, double dLongitude2, double dLatitude2)
{
	double lat1 = (M_PI / 180) * dLatitude1;
	double lat2 = (M_PI / 180) * dLatitude2;

	double lon1 = (M_PI / 180) * dLongitude1;
	double lon2 = (M_PI / 180) * dLongitude2;

	//地球半径
	double R = 6378.137;

	//两点间距离 km，如果想要米的话，结果*1000就可以了
	double d =  acos(sin(lat1) * sin(lat2) + cos(lat1) * cos(lat2) * cos(lon2-lon1)) * R;

	return d * 1000;
}

void Table::handler_voice_req(Player* player)
{
	Json::Value &val = player->client->packet.tojson();
	string url = val["url"].asString();
	int record_time = val["record_time"].asInt();

	Jpacket packet;
	packet.val["cmd"] = SERVER_VOICE_SUCC_BC;
	packet.val["name"] = player->name;
	packet.val["uid"] = player->uid;
	packet.val["seatid"] = player->seatid;
	packet.val["url"] = url;
	packet.val["record_time"] = record_time;
	packet.end();

	broadcast(NULL, packet.tostring());
}


void Table::handler_recored_mo(int value, int seat, int other)
{
    PlayRecord record;
    memset(&record, 0, sizeof(record));
    record.seats[0] = MBYTE(seat);
    record.seats[1] = MBYTE(other);
    record.action = RECORD_MO;
    record.holes[0] = MBYTE(value);
	replay.play_record.push_back(record);
    mjlog.debug("------------------record mo-------------------\n");
}

void Table::handler_recored_chi(int value, int pattern[3], int seat, int other)
{
    PlayRecord record;
    memset(&record, 0, sizeof(record));
    record.seats[0] = MBYTE(seat);
    record.seats[1] = MBYTE(other);
    record.action = RECORD_CHI;

    for (int i = 0; i < 3; i++)
    {
		record.holes[i] = MBYTE(pattern[i]);
    }

	replay.play_record.push_back(record);
    mjlog.debug("------------------record chi-------------------\n");
}

void Table::handler_recored_peng(int value, int seat, int other)
{
    PlayRecord record;
    memset(&record, 0, sizeof(record));
    record.seats[0] = MBYTE(seat);
    record.seats[1] = MBYTE(other);
    record.action = RECORD_PENG;
    record.holes[0] = MBYTE(value);
    
	replay.play_record.push_back(record);
    mjlog.debug("------------------record peng-------------------\n");
}

void Table::handler_recored_gang(int value, int seat, int other, int gang_flag)
{
    PlayRecord record;
    memset(&record, 0, sizeof(record));
    record.seats[0] = MBYTE(seat);
    record.seats[1] = MBYTE(other);
    record.action = RECORD_GANG;
    record.flag = MBYTE(gang_flag);
	record.holes[0] = MBYTE(value);

	replay.play_record.push_back(record);
    mjlog.debug("------------------record gang-------------------\n");
}

void Table::handler_recored_guo(int value, int seat, int other)
{
    PlayRecord record;
    memset(&record, 0, sizeof(record));
    record.seats[0] = MBYTE(seat);
    record.seats[1] = MBYTE(other);
    record.action = RECORD_GUO;
	replay.play_record.push_back(record);
    mjlog.debug("------------------record guo-------------------\n");
}

void Table::handler_recored_hu(int value, int seat, int other)
{
    PlayRecord record;
    memset(&record, 0, sizeof(record));
    record.seats[0] = MBYTE(seat);
    record.seats[1] = MBYTE(other);
    record.action = RECORD_HU;
	if (other > -1)
	{
		record.flag = MBYTE(1);
	}
	else
	{
		record.flag = MBYTE(0);
	}

    record.holes[0] = MBYTE(value);
	replay.play_record.push_back(record);
    mjlog.debug("------------------record hu-------------------\n");
}

void Table::handler_record_chu(int value, int seat)
{
    PlayRecord record;
    memset(&record, 0, sizeof(record));
    record.seats[0] = MBYTE(seat);
    record.seats[1] = MBYTE(0xFF);
    record.action = RECORD_CHU;
    record.holes[0] = MBYTE(value);
	replay.play_record.push_back(record);
    mjlog.debug("------------------record chu-------------------\n");
}

void Table::handler_record_horse(int seatid)
{
	Seat &seat = seats[seatid];
	HorseRecord record;
	memset(&record, 0, sizeof(record));
	record.seatid = MBYTE(seatid);
	record.horse_number = MBYTE(seat.horse_cards.size());
	for (unsigned int i = 0; i < seat.horse_cards.size(); i++)
	{
		record.horse[i] = MBYTE(seat.horse_cards[i].value);
	}
	for (unsigned int i = 0; i < seat.zhong_horse.size(); i++)
	{
		record.zhong[i] = MBYTE(seat.zhong_horse[i]);
	}
	replay.horse_record.push_back(record);
}

void Table::handler_record_notice(int seatid)
{
	PlayRecord record;
    memset(&record, 0, sizeof(record));
    record.seats[0] = MBYTE(seatid);
    record.action = RECORD_NOTICE;
	if (actions[NOTICE_CHI])
	{
		record.flag |= RECORD_NOTICE_CHI;
	}
	if (actions[NOTICE_PENG])
	{
		record.flag |= RECORD_NOTICE_PENG;
	}
	if (actions[NOTICE_GANG])
	{
		record.flag |= RECORD_NOTICE_GANG;
	}
	if (actions[NOTICE_HU])
	{
		record.flag |= RECORD_NOTICE_HU;
	}
	if (actions[NOTICE_GUO])
	{
		record.flag |= RECORD_NOTICE_GUO;
	}
	replay.play_record.push_back(record);
}


int Table::handler_cmd(int cmd, Player* player)
{
	switch (cmd)
	{
		case CLIENT_READY_REQ:
			handler_ready(player);
			break;
		case CLIENT_BET_REQ:
			handler_bet(player);
			break;
		case CLIENT_CHAT_REQ:
			handler_chat(player);
			break;
		case CLIENT_FACE_REQ:
			handler_face(player);
			break;
		case CLIENT_INTERFACE_REQ:
			handler_interFace(player);
			break;
		case CLIENT_LOGOUT_REQ:
			break;
		case CLIENT_SWITCH_TABLE_REQ:
			break;
		case CLIENT_TABLE_INFO_REQ:
			handler_table_info(player);
			break;
		case CLIENT_PLAYER_INFO_REQ:
			handler_player_info(player);
			break;
		case CLIENT_PROP_REQ:
			handler_prop(player);
			break;
		case CLIENT_SEND_GIFT_REQ:
			handler_send_gift_req(player);
			break;
		case CLIENT_DISMISS_TABLE_REQ:
			handler_dismiss_table(player);
			break;
		case CLIENT_GPS_POS_NOTICE:
			handler_gps_notice(player);
			break;
		case CLIENT_GPS_DIS_REQ:
			handler_gps_dist_req(player);
			break;
		case CLIENT_VOICE_REQ:
			handler_voice_req(player);
			break;
		case CLIENT_START_GAME_REQ:
			handler_start_game_req(player);
			break;
		case CLIENT_NEED_CARD_REQ:
			handler_need_card_req(player);
			break;
		case CLIENT_TRANSFER_OWNER_REQ:
			handler_transfer_owner_req(player);
			break;
		case CLIENT_GET_REDPACKET_REQ:
			handler_get_redpacket_req(player);
			break;
		case CLIENT_GET_INTERNET_REQ:
			handler_get_internet_req(player);
			break;
		default:
			mjlog.error("invalid command[%d]\n", cmd);
			return -1;
	}

	return 0;
}

//提前开始的申请处理
void Table::handler_start_game_req(Player* player)
{
	Json::Value &val = player->client->packet.tojson();

	Seat &seat = seats[player->seatid];
	int flag = val["flag"].asInt();

	if (state != ROOM_WAIT_GAME)
	{
		return;
	}

	if (players.size() == 1 || players.size() == seat_max)
	{
		return;
	}

	seat.ahead_start = (flag == 0 ? 0 : 1);

	if (ahead_start_flag == 0 && flag == 1)
	{
		ahead_start_flag = 1;
		ahead_start_uid = player->uid;
		seat.ahead_start = flag;
		if (flag == 1)
		{
            ev_timer_again(zjh.loop, &ahead_start_timer);
			broadcast_ahead_start_status(player, 1);			
		}
	}
	else if (ahead_start_flag == 0 && flag == 0)
	{
		seat.ahead_start = -1;
	}
	else
	{
		if (flag == 0)
		{
			seat.ahead_start = 0;
            ev_timer_stop(zjh.loop, &ahead_start_timer);
			broadcast_ahead_start_status(player, 0);

			ahead_start_flag = 0;
			ahead_start_uid = -1;

			for (int i = 0; i < seat_max; i++)
			{
				seats[i].ahead_start = -1;
			}	
		}
		else
		{
			int total = 0;
			int count = 0;
			for (int i = 0; i < seat_max; i++)
			{
				if (seats[i].player != NULL)
				{
					total++;
					if (seats[i].ahead_start == 1)
					{
						count++;
					}
				}
			}

			broadcast_ahead_start_status(player, 1);

			if (total == count)
			{
				ahead_start_flag = 0;
				ahead_start_uid = -1;

				for (int i = 0; i < seat_max; i++)
				{
					seats[i].ahead_start = -1;
					if(seats[i].player != NULL && seats[i].ready != 1)
					{
						handler_ready(seats[i].player);
					}
				}

				ev_timer_stop(zjh.loop, &ahead_start_timer);
				max_ready_players = std::max(2, total);

				test_game_start();
			}
		}
	}
}

//0：不同意提前开始 1：谁申请开始，同意开始 
void Table::broadcast_ahead_start_status(Player* player, int flag)
{
	Jpacket packet;
	packet.val["cmd"] = SERVER_START_GAME_REQ_BC;

	if (player != NULL)
	{
		packet.val["name"] = player->name;
		packet.val["uid"] = player->uid;
		packet.val["seatid"] = player->seatid;
	}

	packet.val["ahead_start_flag"] = ahead_start_flag;
	packet.val["ahead_start_uid"] = ahead_start_uid;

	if (flag == 1)
	{
		packet.val["ahead_start_time"] = (int)ev_timer_remaining(zjh.loop, &ahead_start_timer);
	}
	else
	{
		packet.val["ahead_start_time"] = 0;
	}

	int i = 0;
	std::map<int, Player*>::iterator it;
	for (it = players.begin(); it != players.end(); it++) {
		Player *p = it->second;
		Seat &seat = seats[p->seatid];

		packet.val["players"][i]["uid"] = p->uid;
		packet.val["players"][i]["name"] = p->name;
		packet.val["players"][i]["seatid"] = p->seatid;
		packet.val["players"][i]["ahead_start"] = seat.ahead_start;

		i++;
	}

	packet.end();
	broadcast(NULL, packet.tostring());

}

void Table::ahead_start_timer_cb(struct ev_loop *loop, struct ev_timer *w, int revents)
{
	Table *table = (Table*)w->data;
	ev_timer_stop(zjh.loop, &table->ahead_start_timer);

	table->ahead_start_timeout();
}

void Table::subs_timer_cb(struct ev_loop *loop, struct ev_timer *w, int revents)
{
    Table *table = (Table*) w->data;
    ev_timer_stop(zjh.loop, &table->ahead_start_timer);

    table->clean_table();
}

//提前开始申请时间到了默认是不提前开始
int Table::ahead_start_timeout()
{
	ahead_start_flag = 0;
	ahead_start_uid = -1;

	for (int i = 0; i < seat_max; i++)
	{
		seats[i].ahead_start = -1;
	}

	broadcast_ahead_start_status(NULL, 0);
	return 0;
}

//马跟杠
void Table::handle_horse_with_gang()
{
	for (int j = 0; j < seat_max; j++)
	{
		if (seats[j].ready != 1){
			continue;
		}

		if (seats[j].gang_count[0] == 0
				&& seats[j].gang_count[1] == 0
				&& seats[j].gang_count[2] == 0
				&& seats[j].gang_count[3] == 0)
		{
			continue;
		}

		int diff_seat = (j - dealer + seat_max) % seat_max;

		for (int i = 0; i < horse_num; i++)
		{
			if ((deck.horse_cards[i].face - 1) % seat_max == diff_seat)
			{
				seats[j].horse_gang_count++;
			}
		}
		mjlog.debug("seatid [%d] .horse_gang_count[%d] \n",j,seats[j].horse_gang_count);
	}

	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].ready != 1)
		{
			continue;
		}

		if (seats[i].horse_gang_count > 0)
		{

			if (seats[i].gang_count[0] > 0)
			{
				seats[i].bet += ming_gang_fen * (max_ready_players - 1) * seats[i].gang_count[0] * seats[i].horse_gang_count;
                mjlog.debug(" seats[i].gang_seats.size() [%d]\n", seats[i].gang_seats.size());
                for (unsigned int j = 0; j < seats[i].gang_seats.size(); j++)
                {
                    int index = seats[i].gang_seats[j];
                    mjlog.debug("index [%d]\n",index);
                    if(index >= 0)
                    {
                        if (gang_shang_hua_seat >= 0 && has_bar_burst_al == 1)//刚上那个花全包
                        {
                            seats[gang_shang_hua_seat].bet -= ming_gang_fen  * (max_ready_players - 1)  * seats[i].horse_gang_count;
							mjlog.info("seats[%d].gang_count[0] = [%d] gang_shang_hua_seat[%d] seats[%d].bet [%d]\n," ,
									i, seats[i].gang_count[0], gang_shang_hua_seat ,gang_shang_hua_seat, seats[gang_shang_hua_seat].bet);
                        }
                        else if (gang_hu_seat >= 0 && has_rob_gang_al)//抢杠胡全包
                        {
                            seats[gang_hu_seat].bet -= ming_gang_fen  * (max_ready_players - 1) * seats[i].horse_gang_count;
								mjlog.info("seats[%d].gang_count[0] = [%d] gang_hu_seat[%d] seats[%d].bet [%d] \n," ,
										i, seats[i].gang_count[0],gang_hu_seat ,gang_hu_seat, seats[gang_hu_seat].bet);
                        }
                        else
                        {
                            seats[index].bet -= ming_gang_fen  * (max_ready_players - 1) * seats[i].horse_gang_count;
								mjlog.info("seats[%d].gang_count[0] = [%d] index[%d] seats[%d].bet [%d] \n," ,
										i, seats[i].gang_count[0], index ,index, seats[index].bet);
                        }
                    }
                }
			}

			if (seats[i].gang_count[1] > 0)
			{
				seats[i].bet += peng_gang_fen* (max_ready_players -1) * seats[i].gang_count[1] * seats[i].horse_gang_count;
				for (int j = 1; j < seat_max; j++)
				{
					int index = (i + j) % seat_max;
					if (seats[index].ready != 1){
						continue;
					}
					if (gang_shang_hua_seat >= 0 && has_bar_burst_al == 1)//刚上那个花全包
					{
						seats[gang_shang_hua_seat].bet -= peng_gang_fen * seats[i].gang_count[1] * seats[i].horse_gang_count;
						mjlog.info("seats[%d].gang_count[1] = [%d] gang_shang_hua_seat[%d] seats[%d].bet [%d] \n" ,
								i, seats[i].gang_count[1], gang_shang_hua_seat ,gang_shang_hua_seat, seats[gang_shang_hua_seat].bet);
					}
					else if (gang_hu_seat >= 0 && has_rob_gang_al)//抢杠胡全包
					{
						seats[gang_hu_seat].bet -= peng_gang_fen *  seats[i].gang_count[1]* seats[i].horse_gang_count;
						mjlog.info("seats[%d].gang_count[1] = [%d] gang_hu_seat[%d] seats[%d].bet [%d] \n" ,
								i, seats[i].gang_count[1], gang_hu_seat ,gang_hu_seat, seats[gang_hu_seat].bet);
					}
					else
					{
						seats[index].bet -= peng_gang_fen * seats[i].gang_count[1] * seats[i].horse_gang_count;
						mjlog.info("seats[%d].gang_count[1] = [%d] index[%d] seats[%d].bet [%d] \n" ,
								i, seats[i].gang_count[1], index ,index, seats[index].bet);
					}
				}
			}

			if (seats[i].gang_count[2] > 0)
			{
				seats[i].bet += (max_ready_players - 1) * an_gang_fen * seats[i].gang_count[2] * seats[i].horse_gang_count;
				for (int j = 1; j < seat_max; j++)
				{
					int index = (i + j) % seat_max;
					if (seats[index].ready != 1)
					{
						continue;
					}
					if (gang_shang_hua_seat >= 0 && has_bar_burst_al == 1)//杠上花全包
					{
						seats[gang_shang_hua_seat].bet -= an_gang_fen * seats[i].gang_count[2] * seats[i].horse_gang_count;
						mjlog.info("seats[%d].gang_count[2] = [%d] gang_shang_hua_seat[%d] seats[%d].bet [%d] \n" ,
								i, seats[i].gang_count[2], gang_shang_hua_seat ,gang_shang_hua_seat, seats[gang_shang_hua_seat].bet);
					}
					else if (gang_hu_seat >= 0 && has_rob_gang_al)//抢杠胡全包
					{
						seats[gang_hu_seat].bet -= an_gang_fen * seats[i].gang_count[2] * seats[i].horse_gang_count;
						mjlog.info("seats[%d].gang_count[2] = [%d] gang_hu_seat[%d] seats[%d].bet [%d] \n" ,
								i, seats[i].gang_count[2], gang_hu_seat ,gang_hu_seat, seats[gang_hu_seat].bet);
					}
					else
					{
						seats[index].bet -= an_gang_fen * seats[i].gang_count[2] * seats[i].horse_gang_count;
						mjlog.info("seats[%d].gang_count[2] = [%d] index[%d] seats[%d].bet [%d] \n" ,
								i, seats[i].gang_count[2], index ,index, seats[index].bet);
					}
				}
			}

			if (seats[i].gang_count[3] > 0)
			{
				seats[i].bet += (max_ready_players - 1) * an_gang_fen * seats[i].gang_count[3] * seats[i].horse_gang_count;
				for (int j = 1; j < seat_max; j++)
				{
					int index = (i + j) % seat_max;
					if (seats[index].ready != 1)
					{
						continue;
					}
					if (gang_shang_hua_seat >= 0 && has_bar_burst_al == 1)//杠上花全包
					{
						seats[gang_shang_hua_seat].bet -= an_gang_fen * seats[i].gang_count[3] * seats[i].horse_gang_count;
						mjlog.info("seats[%d].gang_count[3] = [%d] gang_shang_hua_seat[%d] seats[%d].bet [%d] \n" ,
								i, seats[i].gang_count[3], gang_shang_hua_seat ,gang_shang_hua_seat, seats[gang_shang_hua_seat].bet);
					}
					else if (gang_hu_seat >= 0 && has_rob_gang_al)//抢杠胡全包
					{
						seats[gang_hu_seat].bet -= an_gang_fen * seats[i].gang_count[3] * seats[i].horse_gang_count;
						mjlog.info("seats[%d].gang_count[3] = [%d] gang_hu_seat[%d] seats[%d].bet [%d] \n" ,
								i, seats[i].gang_count[3], gang_hu_seat ,gang_hu_seat, seats[gang_hu_seat].bet);
					}
					else
					{
						seats[index].bet -= an_gang_fen * seats[i].gang_count[3] * seats[i].horse_gang_count;
						mjlog.info("seats[%d].gang_count[3] = [%d] index[%d] seats[%d].bet [%d] \n" ,
								i, seats[i].gang_count[3], index ,index, seats[index].bet);
					}
				}
			}
		}	
	}
	for(int i = 0; i <seat_max; i++ ){
		mjlog.debug(" horse with gang gang pai seatid [%d] fang_gang_count[%d] gang_count[%d][%d][%d][%d] bet[%d] \n",
				i, seats[i].fang_gang_count, seats[i].gang_count[0], seats[i].gang_count[1],
				seats[i].gang_count[2], seats[i].gang_count[3],seats[i].bet);
	}
}

//过程记录并通知客户端玩家知道(推倒胡 和潮汕麻将 只有碰杠，只有鸡平胡才有吃)action: 0 为发牌状态，1:吃牌，2:碰牌，3:吃杠，4:碰杠，5:暗杠
void Table::handler_play_procedure(int desseatid, int srcseatid, int card, int action)
{
	if(action  >= 4 )
	{
		if (seats[desseatid].player == NULL)
		{
			return ;
		}
	}
	else 
	{
		if(seats[desseatid].player == NULL || seats[srcseatid].player == NULL)
		{
			return ;
		}
	}
	std::ostringstream oss;
	std::string action_desc[6] = { "发牌", "吃", "碰了", "吃杠了", "碰杠了", "暗杠" };
	Card target_card;
	target_card.set_value(card);
	if (action == 5)
	{
		oss << "玩家[" << seats[desseatid].player->name << "]" << action_desc[action] ;
	}
	else if(action == 4)
	{
		oss << "玩家[" << seats[desseatid].player->name << "]" << action_desc[action]<< target_card.get_card();	
	}
	else
	{
		oss << "玩家[" << seats[desseatid].player->name << "]" << action_desc[action] << "玩家["
			<< seats[srcseatid].player->name<< "]的" << target_card.get_card();
	}
	printf("%s\n",oss.str().c_str());
	seats[desseatid].play_procedure.push_back(oss.str());
	Jpacket packet;
	packet.val["cmd"] = SERVER_PLAY_PROCEDURE_BC;
	packet.val["name"] = seats[desseatid].player->name;
	packet.val["procedure"] = oss.str().c_str();
	if (action == 5)
	{
		packet.val["card"] = 0;
	}
	else 
	{
		packet.val["card"] = card;
	}
	packet.end();
	broadcast(NULL, packet.tostring());
}

//处理测试 测试人员所要的制定牌
int Table::handler_need_card_req(Player *player)
{ 
	Json::Value &val = player->client->packet.tojson();
	Seat & seat = seats[player->seatid];
	int need_card = val["need_card"].asInt();

	if(set_card_flag == 0)
	{
		mjlog.info("handler need card req error[ %d]\n",set_card_flag);
		return 0;
	}

	if (need_card < 0 || need_card > Card::BaiV)
	{
		need_card = 0;
	}

	seat.need_card = need_card;

	return 0;
}

//从redis 中读取测试的所需牌值
int Table::get_set_hole_cards(Player * player)
{
	if(set_card_flag ==0){
		return -1;
	}
	std::ostringstream oss;
	oss<<"hc_"<<player->uid;

	if(zjh.temp_rc->command("LLEN %s",oss.str().c_str()) < 0)
	{
		return-1;
	}

	int len  = zjh.temp_rc->reply->integer;
	if(len < 0)
	{
		return -1;
	}

	for(int i =0;i<len;i++)
	{
		int ret = zjh.temp_rc->command("RPOP %s",oss.str().c_str());
		if(ret < 0)
		{
			continue;
		}

		int card_value = atoi(zjh.temp_rc->reply->str);
		Card card ;
		card.set_value(card_value);
		seats[player->seatid].set_hole_cards.push_back(card);
	}

	return 0;
}

int Table::handler_transfer_owner_req(Player *player)
{
	Json::Value &val = player->client->packet.tojson();
	//Seat &seat = seats[player->seatid];

	int transfer_uid = val["transfer_uid"].asInt();
	if (players.find(transfer_uid) == players.end())
	{
		handler_transfer_owner_req_error(player, 1);
		return -1;
	}

	if (transfer_uid == player->uid || transfer_uid == owner_uid || player->uid != owner_uid)
	{
		handler_transfer_owner_req_error(player, 2);
		return -1;
	}

	if (round_count != 0)
	{
		handler_transfer_owner_req_error(player, 3);
		return -1;
	}

    if (substitute == 1)
    {
        handler_transfer_owner_req_error(player, 4);
		return -1;
	}
	
	//AA付费没没有转让房主
	if(cost_select_flag == 2)
	{
		handler_transfer_owner_req_error(player, 5);
		return -1;
	}


	if (!transfer_flag)
	{
		players[origin_owner_uid]->incr_rmb(0 - create_rmb);
		Player* player1 = players[origin_owner_uid];
		insert_flow_log((int)time(NULL), player1->uid, player1->remote_ip, 0, type, zid, ttid, type, 0, create_rmb, player1->rmb);
	}

	Jpacket packet;
	packet.val["cmd"] = SERVER_TRANSFER_OWNER_SUCC_BC;
	packet.val["old_owner_uid"] = owner_uid;
	packet.val["owner_uid"] = transfer_uid;
	packet.val["owner_name"] = players[transfer_uid]->name;
	packet.val["old_owner_name"] = players[owner_uid]->name;
	packet.val["owner_rmb"] = players[transfer_uid]->rmb;
	packet.val["old_owner_rmb"] = players[owner_uid]->rmb;
	packet.val["owner_seat"] = players[transfer_uid]->seatid;
	packet.val["old_owner_seat"] = players[owner_uid]->seatid;
	packet.end();
	broadcast(NULL, packet.tostring());

	zjh.game->table_owners.erase(owner_uid);
	zjh.game->table_owners[transfer_uid] = tid;

	owner_uid = transfer_uid; 
	transfer_flag = true;

	return 0;
}

void Table::handler_transfer_owner_req_error(Player* player, int reason)
{
	mjlog.error("handler transfer owner error, reason is %d.\n", reason);
	Jpacket packet;
	packet.val["cmd"] = SERVER_TRANSFER_OWNER_ERR_UC;
	packet.val["reason"] = reason;
	packet.end();
	unicast(player, packet.tostring());
}

string Table::format_card_desc(int card_type)
{
	string desc;
	string str = "";
	string str_special = "";

	switch(card_type)
	{
		case CARD_TYPE_PING_HU: // 平胡
			str = "平胡";
			break;
		case CARD_TYPE_PENG_HU: // 碰碰胡
			str = "碰碰胡";
			break;
		case CARD_TYPE_QING_YI_SE:  // 清一色
		case CARD_TYPE_QING_PENG:  // 清一色
			str = "清一色";
			break;
		case CARD_TYPE_QI_XIAO_DUI: // 7小对
			str = "七小对";
			break;
		case CARD_TYPE_HUN_YAO_JIU:   // 混幺九 加清幺九 都算幺九
		case CARD_TYPE_QING_YAO_JIU:
			str = "幺九";
			break;
		case CARD_TYPE_SHI_SAN_YAO:	// 十三幺
			str = "十三幺";
			break;
		case CARD_TYPE_ZI_YI_SE: //全风
			str = "全风";
			break;
		default:
			break;
	}

	if (card_type != 0)
	{
		if (tian_hu_flag == 1)
		{
			str_special = "天胡, ";
		}
		else if (di_hu_flag == 1)
		{
			str_special = "地胡, ";
		}
		else if (hai_di_hu_flag == 1)
		{
			str_special = "海底胡, ";
		}
		else if (gang_shang_hua_flag == 1)
		{
			str_special = "杠上花, ";
		}
		else if (gang_shang_pao == 1)
		{
			str_special = "杠上炮, ";
		}
		else if (hai_di_pao == 1)
		{
			str_special = "海底炮, ";
		}
	}

	desc = str_special + str;
	return desc;
}

void Table::accumulate_hu()
{
    for (int i = 0; i < seat_max; i++)
    {
        Seat &seat = seats[i];
        if (seat.ready == 0)
        {
            continue;
        }

        if (seat.gang_hu_flag == 1 && gang_hu_seat >= 0)
        {
            seat.total_jie_pao++;
        }
        else if (seat.pao_hu_flag == 1 && pao_hu_seat >= 0)
        {
            seat.total_jie_pao++;
        }
        else if (i == win_seatid)
        {
            seat.total_zimo++;
        }
    }

    if (gang_hu_seat >= 0)
    {
        seats[gang_hu_seat].total_fang_pao++;
    }
    else if (pao_hu_seat >= 0)
    {
        seats[pao_hu_seat].total_fang_pao++;
    }  
}

int Table::set_create_rmb(int rmb, int aarmb)
{
    create_rmb = rmb;
	create_aa_rmb = aarmb;
    return 0;
}

int Table::handler_redpacket()
{
    // 需要获取活动时间来判断是否允许派发红包
    int ret = zjh.temp_rc->command("hgetall rac");
    if (ret < 0)
    {
        mjlog.debug("no redpacket task.\n");
        return -1;
    }

    if (zjh.temp_rc->is_array_return_ok() < 0)
    {
        mjlog.debug("no redpacket task 1.\n");
        return -1;
    }

    long btime = zjh.temp_rc->get_value_as_int("btime");
    long etime = zjh.temp_rc->get_value_as_int("etime");
	std::string citys = zjh.temp_rc->get_value_as_string("area");
	long now = time(NULL);

	mjlog.debug("handler_redpacket btime [%ld] etime[%ld] citys[%s] now[%ld]\n", 
			btime, etime, citys.c_str(), now);

	std::string all_city = "*";

	if (now < btime || now > etime)
	{
		mjlog.debug("no redpacket task 2.\n");
		return -1;
	}

	// 获取一个红包值
	ret = zjh.temp_rc->command("rpop red_list");

	if (ret >= 0 && max_ready_players == seat_max )
	{
		if (zjh.temp_rc->reply->str == NULL)
		{
			mjlog.debug("cann't get a redpacket 3.\n");
			return 0;
			
		}
	
		std::vector<int> tmp;
		for (int i = 0; i < seat_max; i++)
		{
			if (seats[i].ready != 1 || seats[i].player == NULL)
			{
				continue;
			}
			mjlog.debug("handler_redpacket btime [%ld] etime[%ld] citys[%s] now[%ld] player->city[%s]\n", 
					btime, etime, citys.c_str(), now, seats[i].player->city.c_str());
			if (citys != all_city)
			{
				std::size_t found  = citys.find(seats[i].player->city);
				if (found != std::string::npos)
				{
					tmp.push_back(i);
					seats[i].city_red_falg = 1;
				}
			}
			else 
			{
				tmp.push_back(i);
				seats[i].city_red_falg = 1;
			}
		}
		if(tmp.size() > 0)
		{
			if (red_type == 0)
			{
				// 预先分配好红包
				random_shuffle(tmp.begin(), tmp.end());
				int len = tmp.size();
				int red_seatid = 0;
				if (len > 0)
				{
					int index = random(0, len - 1);	
					red_seatid = tmp[index];
				}
				int red_values[4] = {0, };
				red_values[red_seatid] = atoi(zjh.temp_rc->reply->str);	
				//random_shuffle(red_value, red_value + 4);
				redpackes.clear();
				for(int i = 0; i < 4; i++)
				{
					redpackes.push_back(red_values[i]);
				}
				//redpackes.assign(red_value, red_value + 4);
				mjlog.debug("red_seatid [%d] red_values[red_seatid] [%d] redpackes.size() [%d] \n", 
						red_seatid ,red_values[red_seatid], redpackes.size()); 
			}
			else if(red_type == 1) 
			{
				redpackes.clear();
				for(int i = 0; i < (seat_max -1 ); i++)
				{
					redpackes.push_back(0);
				}
				int red_values = atoi(zjh.temp_rc->reply->str);
				redpackes.push_back(red_values);
			}
			mjlog.debug("handler_redpacket redpackes.size() [%d]\n", redpackes.size());
			Jpacket packet;
			packet.val["cmd"] = SERVER_DISPATCH_REDPACKET_SUCC_BC;
			packet.end();      
			broadcast(NULL, packet.tostring());
		}
	}
	else
	{
		mjlog.debug("cann't get a redpacket.\n");
	}

	return 0;
}

int Table::record_redpacket(Player *player, int value)
{
	Jpacket packet;
	packet.val["tid"] = ttid;
	packet.val["uid"] = player->uid;
	packet.val["money"] = value;
	packet.val["time"] = (int)time(NULL);
	packet.end();

	string str = packet.val.toStyledString().c_str();

	int ret = zjh.temp_rc->command("LPUSH red_record_list %s", str.c_str());

	if (ret < 0)
	{
		mjlog.error("insert_flow_record %s", str.c_str());
		return - 1;
	}

	player->incr_total_red(value);
	return 0;
}

int Table::handler_get_redpacket_req(Player *player)
{
	if (redpackes.size() == 0)
	{
		Jpacket packet;
		packet.val["cmd"] = SERVER_GET_REDPACKET_ERR_UC;
		packet.val["err_str"] = "红包不存在。";
		packet.end();
		unicast(player, packet.tostring());
		return 0;
	}

	Seat & seat = seats[player->seatid];
	if(seat.already_get_red == 1)
	{
		Jpacket packet;
		packet.val["cmd"] = SERVER_GET_REDPACKET_ERR_UC;
		packet.val["err_str"] = "您的红包已经领取过了。";
		packet.end();
		unicast(player, packet.tostring());
		return 0;
	}

	if (seat.city_red_falg != 1)
	{
		seat.already_get_red = 1;
		Jpacket packet;
		packet.val["cmd"] = SERVER_GET_REDPACKET_ERR_UC;
		packet.val["err_str"] = "您不在活动所在区域，不能参与活动。";
		packet.end();
		unicast(player, packet.tostring());
		return 0;
	}

	Json::Value &val = player->client->packet.tojson();
	int value = 0;
	if(red_type == 0)
	{
		value = redpackes[player->seatid];
	}
	else if (red_type == 1)
	{
		if(redpackes.size() > 0 && seat.city_red_falg == 1)
		{
			value = redpackes.back();
			redpackes.pop_back();
		}
	}
	seat.already_get_red = 1;

	Jpacket packet;
	packet.val["cmd"] = SERVER_GET_REDPACKET_SUCC_UC;	
	packet.val["value"] = value;
	packet.end();
	unicast(player, packet.tostring());

	if (value > 0)
	{
		Jpacket packet1;
		packet1.val["cmd"] = SERVER_GET_REDPACKET_SUCC_BC;
		packet1.val["value"] = value;
		packet1.val["uid"] = player->uid;
		packet1.val["name"] = player->name;
		packet1.end();
		broadcast(NULL, packet1.tostring());

		record_redpacket(player, value);
	}

	return 0;
}

int Table::handler_invite_advantage(Player *player)
{
	if(player->pre_uid < 1000)
	{
		mjlog.debug("handler_invite_advantage player total_board[%d] pre_uid[%d]\n", player->total_board,  player->pre_uid);
		return -1;
	}

	int ret = zjh.temp_rc->command("hgetall bac");
    if (ret < 0)
    {
        mjlog.debug("no invite advantage task.\n");
        return -1;
    }

    if (zjh.temp_rc->is_array_return_ok() < 0)
    {
        mjlog.debug("no invite advantage task 1.\n");
        return -1;
    }

    long btime = zjh.temp_rc->get_value_as_int("btime");
    long etime = zjh.temp_rc->get_value_as_int("etime");
	std::string citys = zjh.temp_rc->get_value_as_string("area");
	std::string all_city = "*";
	long now = time(NULL);

	mjlog.debug("handler_invite_advantage btime [%ld] etime[%ld] citys[%s] now[%ld] player->city[%s]\n", 
					btime, etime, citys.c_str(), now, player->city.c_str());

	if (now < btime || now > etime)
	{
		mjlog.debug("handler_redpacket not at right time now [%d] btime[%d] etime[%d].\n", now, btime, etime);
		return -1;
	}
	
	if(citys != all_city) 
	{
		std::size_t found  = citys.find(player->city);
		if (found == std::string::npos)
		{
			mjlog.debug("handler_redpacket not at activity city citys[%s] player->city[%s].\n", citys.c_str(), player->city.c_str());
			return -1;
		}
	}

	
	player->incr_ac_board(vid, 1);

	mjlog.debug("handler_invite_advantage player uid[%d] ac_board[%d] pre_uid[%d]\n", 
				player->uid, player->ac_board,  player->pre_uid);

	if(player->ac_board != 8)
	{	
		return -1;
	}
	
	ret = zjh.temp_rc->command("sadd tj_uid %d", player->uid);
	if(ret < 0)
	{
		mjlog.debug("handler_invite_advantage sadd tj_uid %d\n", player->uid);
		return -1;
	}
	return 0;
}

void Table::handler_substitute_req(Player* player)
{
    //int create_rmb = zjh.conf["tables"]["create_rmb"].asInt();
	Json::Value &val = player->client->packet.tojson();
	std::string playway_desc = val["playway_desc"].asString();
	int player_max = val["player_max"].asInt();



    player->tid = -1;

    Jpacket packet;
	packet.val["cmd"] = SERVER_SUBSTITUTE_SUCC_UC;
	packet.val["uid"] = player->uid;
    packet.val["ttid"] = ttid;
    packet.val["rmb"] = create_rmb ;
	packet.end();
	unicast(player, packet.tostring());
    owner_uid = player->uid;
    owner_name = player->name;

    player->incr_rmb(0 - create_rmb );

    char buff[128] = {0, };

	if (type == 1)
	{
		snprintf(buff, 128, "推到胡，%d局", max_play_board);
	}
	else if(type == 9)
	{
		snprintf(buff, 128, "做牌推倒胡，%d局", max_play_board);
	}
    
    int ret = zjh.temp_rc->command("hmset create:%d:%d uid %d, tid %d, type %d, size 0, status 0, ts %d, ruler %s player_max %d",
                                   player->uid, ttid, player->uid, ttid, type, (int)time(NULL), playway_desc.c_str(), player_max);

    if (ret < 0)
    {
        mjlog.error("insert substitute info error");
        return;
    }

    ret = zjh.temp_rc->command("lpush create:%d create:%d:%d", player->uid, player->uid, ttid);
    if (ret < 0)
    {
        mjlog.error("add substitute info error");
        return;
    }
}

void Table::modify_substitute_info(Player* player, int flag)
{
    int ret = zjh.temp_rc->command("hget create:%d:%d size", owner_uid, ttid);
    if (ret < 0)
    {
        mjlog.error("get substitute info error");
        return;
    }

    if (zjh.temp_rc->reply->str == NULL)
    {
        mjlog.error("get substitute str error");
        return;
    }
    int size = atoi(zjh.temp_rc->reply->str);

    if (flag == 1)
    {
        size += 1;

        ret = zjh.temp_rc->command("hmset create:%d:%d uid%d %d size %d", owner_uid, ttid, size, player->uid, size);
        if (ret < 0)
        {
            mjlog.error("modify substitute info error");
            return;
        }
    }
    else
    {
        if (size <= 0)
        {
            return;
        }

        vector<int> uids;
        for (int i = 0; i < seat_max; i++)
        {
            if (seats[i].player != NULL)
            {
                uids.push_back(seats[i].uid);
            }
        }

        size = uids.size();

		if (uids.size() == 4)
		{
			ret = zjh.temp_rc->command("hmset create:%d:%d uid1 %d, uid2 %d, uid3 %d, uid4 %d, size %d", owner_uid, ttid,
									   uids[0], uids[1], uids[2], uids[3], size);
		}
        else if (uids.size() == 3)
        {
            ret = zjh.temp_rc->command("hmset create:%d:%d uid1 %d, uid2 %d, uid3 %d, size %d", owner_uid, ttid,
                                       uids[0], uids[1], uids[2], size);
        }
        else if (uids.size() == 2)
        {
            ret = zjh.temp_rc->command("hmset create:%d:%d uid1 %d, uid2 %d, size %d", owner_uid, ttid, uids[0], uids[1], size);
        }
        else if (uids.size() == 1)
        {
            ret = zjh.temp_rc->command("hmset create:%d:%d uid1 %d, size %d", owner_uid, ttid, uids[0], size);
        }
        else if (uids.size() == 0)
        {
            ret = zjh.temp_rc->command("hset create:%d:%d size %d", owner_uid, ttid, size);
        }

        if (ret < 0)
        {
            mjlog.error("set substitute info error");
        }    
    }
}

void Table::modify_substitute_info(int status)
{
    int ret = zjh.temp_rc->command("hset create:%d:%d status %d", owner_uid, ttid, status);
    if (ret < 0)
    {
        mjlog.error("modify substitute status error");
        return;
    }
}

void Table::clear_substitute_info()
{
    // int ret = zjh.temp_rc->command("del create:%d:%d", owner_uid, ttid);
    // if (ret < 0)
    // {
    //     mjlog.error("clear substitute info error");
    // }

    int ret = zjh.temp_rc->command("lrem create:%d 0 create:%d:%d", owner_uid, owner_uid, ttid);
    if (ret < 0)
    {
        mjlog.error("clear substitute info1 error");
    }
}

void Table::create_table_cost()			//创建房间扣费函数
{
    int base_play_board = zjh.conf["tables"]["base_board"].asInt();
    base_play_board = base_play_board <= 0 ? 8 : base_play_board;   
    int ratio = max_play_board / base_play_board;
    ratio = std::max(1, ratio);

	if(cost_select_flag == 1)				//房主扣费
	{
		mjlog.debug("create_table_cost cost_select_flag [%d] uid[%d] create_rmb[%d]\n", 
				cost_select_flag, owner_uid, create_rmb);
		players[owner_uid]->incr_rmb(0 - create_rmb);
		Player* player = players[owner_uid];
		insert_flow_log((int)time(NULL), player->uid, player->remote_ip, 0, type, zid, ttid, type, 0, create_rmb, player->rmb);
	}
	else if (cost_select_flag == 2)		//AA扣费
	{
		for (int i = 0; i < seat_max; i++)
		{
			if (seats[i].player != NULL)
			{
				mjlog.debug("create_table_cost cost_select_flag [%d] uid[%d] create_rmb[%d]\n", 
						cost_select_flag, seats[i].player->uid, create_rmb);
				seats[i].player->incr_rmb(0 - create_rmb);
				insert_flow_log((int) time(NULL), seats[i].player->uid, seats[i].player->remote_ip, 0, type, zid, ttid, type, 0, create_rmb, seats[i].player->rmb);
			}

		}

	}
}

int Table::random_dealer()
{
	std::vector<int> tmp;
	for (int i = 0; i < seat_max; i++)
	{
		if (seats[i].ready == 1)
		{
			tmp.push_back(i);
		}
	}

	int len = tmp.size();
	if (len > 0)
	{
		int index = random(0, len - 1);
		int i = tmp[index];
		mjlog.debug("len[%d] index[%d] i[%d]\n", len, index, i);
		return i;
	}

	return -1;
}

int Table::handler_owner_dismiss_table()
{
	if(substitute == 1)
	{
		Jpacket packet;
		packet.val["cmd"] = SERVER_DISMISS_TABLE_SUCC_BC;
		packet.val["uid"] = owner_uid;
		packet.val["name"] = owner_name;
		packet.val["flag"] = 0;
		packet.end();
		broadcast(NULL, packet.tostring());
	}
	return 0;
}

int Table::handler_get_internet_req(Player * player)
{  
   Json::Value &val = player->client->packet.tojson();
   Jpacket packet;
   packet.val["cmd"] = SERVER_GET_INTERNET_UC;
   packet.val["uid"] = player->uid;
   packet.val["massage"] = val["massage"];
   packet.end();
   unicast(player, packet.tostring());
   return 0;
}
